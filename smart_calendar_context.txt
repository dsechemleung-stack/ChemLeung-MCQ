
--- FILE_PATH: src/services/calendarService.js ---
/**
 * Enhanced Calendar Service
 * Handles calendar events, study plans, and quiz completion tracking
 */

import { db } from '../firebase/config';
import { 
  collection, 
  doc, 
  setDoc, 
  getDoc, 
  getDocs, 
  query, 
  where, 
  orderBy, 
  limit,
  deleteDoc,
  updateDoc,
  arrayUnion,
  Timestamp
} from 'firebase/firestore';

export const EVENT_TYPES = {
  MAJOR_EXAM: 'major_exam',
  SMALL_QUIZ: 'small_quiz',
  STUDY_SUGGESTION: 'study_suggestion',
  SPACED_REPETITION: 'spaced_repetition',
  AI_RECOMMENDATION: 'ai_recommendation'
};

/**
 * Add a major exam to the calendar
 */
export async function addMajorExam(userId, examData) {
  const { date, title, topics, subtopics } = examData;
  
  const examEvent = {
    id: `exam_${Date.now()}`,
    type: EVENT_TYPES.MAJOR_EXAM,
    date,
    title,
    topics,
    subtopics,
    completed: false,
    createdAt: new Date().toISOString()
  };

  // Save main event
  await setDoc(
    doc(db, 'calendar', userId, 'events', examEvent.id),
    examEvent
  );

  // Generate study plan (10-day)
  const studyPlan = generateMajorExamPlan(examEvent);
  
  // Save study suggestions
  for (const suggestion of studyPlan) {
    await setDoc(
      doc(db, 'calendar', userId, 'events', suggestion.id),
      suggestion
    );
  }

  return { examEvent, studyPlan };
}

/**
 * Add a small quiz to the calendar
 */
export async function addSmallQuiz(userId, quizData) {
  const { date, title, topics, subtopics } = quizData;
  
  const quizEvent = {
    id: `quiz_${Date.now()}`,
    type: EVENT_TYPES.SMALL_QUIZ,
    date,
    title,
    topics,
    subtopics,
    completed: false,
    createdAt: new Date().toISOString()
  };

  // Save main event
  await setDoc(
    doc(db, 'calendar', userId, 'events', quizEvent.id),
    quizEvent
  );

  // Generate study plan (3-day)
  const studyPlan = generateSmallQuizPlan(quizEvent);
  
  // Save study suggestions
  for (const suggestion of studyPlan) {
    await setDoc(
      doc(db, 'calendar', userId, 'events', suggestion.id),
      suggestion
    );
  }

  return { quizEvent, studyPlan };
}

/**
 * Generate major exam study plan (10 days before)
 */
function generateMajorExamPlan(examEvent) {
  const examDate = new Date(examEvent.date);
  const suggestions = [];
  
  // 10-day plan with scaled intensity
  const schedule = [
    { days: [10, 9, 8, 7], count: 10, phase: 'Warm-up' },
    { days: [6, 5, 4], count: 20, phase: 'Consolidation' },
    { days: [3, 2, 1], count: 40, phase: 'Sprint' }
  ];
  
  schedule.forEach(({ days, count, phase }) => {
    days.forEach(daysBefore => {
      const suggestionDate = new Date(examDate);
      suggestionDate.setDate(suggestionDate.getDate() - daysBefore);
      
      suggestions.push({
        id: `suggestion_${examEvent.id}_day${daysBefore}`,
        type: EVENT_TYPES.STUDY_SUGGESTION,
        parentEventId: examEvent.id,
        date: suggestionDate.toISOString().split('T')[0],
        title: `${phase} - ${count} MCQs`,
        description: `Day ${daysBefore} before exam`,
        questionCount: count,
        phase,
        topics: examEvent.topics,
        subtopics: examEvent.subtopics,
        completed: false,
        createdAt: new Date().toISOString()
      });
    });
  });
  
  return suggestions;
}

/**
 * Generate small quiz study plan (3 days before)
 */
function generateSmallQuizPlan(quizEvent) {
  const quizDate = new Date(quizEvent.date);
  const suggestions = [];
  
  const schedule = [
    { day: 3, count: 5, phase: 'Initial Review' },
    { day: 2, count: 10, phase: 'Topic Focus' },
    { day: 1, count: 15, phase: 'Final Polish' }
  ];
  
  schedule.forEach(({ day, count, phase }) => {
    const suggestionDate = new Date(quizDate);
    suggestionDate.setDate(suggestionDate.getDate() - day);
    
    suggestions.push({
      id: `suggestion_${quizEvent.id}_day${day}`,
      type: EVENT_TYPES.STUDY_SUGGESTION,
      parentEventId: quizEvent.id,
      date: suggestionDate.toISOString().split('T')[0],
      title: `${phase} - ${count} MCQs`,
      description: `Day ${day} before quiz`,
      questionCount: count,
      phase,
      topics: quizEvent.topics,
      subtopics: quizEvent.subtopics,
      completed: false,
      createdAt: new Date().toISOString()
    });
  });
  
  return suggestions;
}

/**
 * Add completed session to calendar
 * 
 * @param {string} userId - User ID
 * @param {string} dateStr - Date in YYYY-MM-DD format
 * @param {Object} sessionData - Session data
 */
export async function addCompletedSession(userId, dateStr, sessionData) {
  const completionId = `completion_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  
  const completionDoc = {
    id: completionId,
    date: dateStr,
    ...sessionData,
    completedAt: new Date().toISOString()
  };

  await setDoc(
    doc(db, 'calendar', userId, 'completions', completionId),
    completionDoc
  );

  console.log('‚úÖ Completion logged:', completionDoc);
  
  return completionDoc;
}

/**
 * Mark an event as completed
 */
export async function completeEvent(eventId, completionData = {}) {
  const userId = auth.currentUser?.uid;
  if (!userId) throw new Error('User not authenticated');

  await updateDoc(
    doc(db, 'calendar', userId, 'events', eventId),
    {
      completed: true,
      completedAt: new Date().toISOString(),
      completionData
    }
  );
}

/**
 * Delete an event and its children
 */
export async function deleteEvent(eventId, cascadeDelete = true) {
  const userId = auth.currentUser?.uid;
  if (!userId) throw new Error('User not authenticated');

  // Delete main event
  await deleteDoc(doc(db, 'calendar', userId, 'events', eventId));

  // Delete child events if cascade
  if (cascadeDelete) {
    const childrenQuery = query(
      collection(db, 'calendar', userId, 'events'),
      where('parentEventId', '==', eventId)
    );
    
    const childrenSnapshot = await getDocs(childrenQuery);
    
    for (const childDoc of childrenSnapshot.docs) {
      await deleteDoc(childDoc.ref);
    }
  }
}

/**
 * Get calendar data for a specific month
 */
export async function getCalendarData(userId, year, month) {
  const startDate = new Date(year, month, 1);
  const endDate = new Date(year, month + 1, 0);
  
  const startDateStr = startDate.toISOString().split('T')[0];
  const endDateStr = endDate.toISOString().split('T')[0];

  // Get events
  const eventsQuery = query(
    collection(db, 'calendar', userId, 'events'),
    where('date', '>=', startDateStr),
    where('date', '<=', endDateStr)
  );

  const eventsSnapshot = await getDocs(eventsQuery);
  
  // Get completions
  const completionsQuery = query(
    collection(db, 'calendar', userId, 'completions'),
    where('date', '>=', startDateStr),
    where('date', '<=', endDateStr)
  );

  const completionsSnapshot = await getDocs(completionsQuery);

  // Organize by date
  const calendarData = {};

  eventsSnapshot.forEach(doc => {
    const event = doc.data();
    if (!calendarData[event.date]) {
      calendarData[event.date] = {
        exams: [],
        quizzes: [],
        suggestions: [],
        repetitions: [],
        aiRecommendations: [],
        completions: []
      };
    }

    if (event.type === EVENT_TYPES.MAJOR_EXAM) {
      calendarData[event.date].exams.push(event);
    } else if (event.type === EVENT_TYPES.SMALL_QUIZ) {
      calendarData[event.date].quizzes.push(event);
    } else if (event.type === EVENT_TYPES.STUDY_SUGGESTION) {
      calendarData[event.date].suggestions.push(event);
    } else if (event.type === EVENT_TYPES.SPACED_REPETITION) {
      calendarData[event.date].repetitions.push(event);
    } else if (event.type === EVENT_TYPES.AI_RECOMMENDATION) {
      calendarData[event.date].aiRecommendations.push(event);
    }
  });

  completionsSnapshot.forEach(doc => {
    const completion = doc.data();
    if (!calendarData[completion.date]) {
      calendarData[completion.date] = {
        exams: [],
        quizzes: [],
        suggestions: [],
        repetitions: [],
        aiRecommendations: [],
        completions: []
      };
    }
    calendarData[completion.date].completions.push(completion);
  });

  return calendarData;
}

/**
 * Get completion statistics for a date range
 */
export async function getCompletionStats(userId, startDate, endDate) {
  const startDateStr = startDate.toISOString().split('T')[0];
  const endDateStr = endDate.toISOString().split('T')[0];

  const completionsQuery = query(
    collection(db, 'calendar', userId, 'completions'),
    where('date', '>=', startDateStr),
    where('date', '<=', endDateStr)
  );

  const snapshot = await getDocs(completionsQuery);
  
  const stats = {
    totalSessions: snapshot.size,
    totalQuestions: 0,
    totalCorrect: 0,
    averageAccuracy: 0,
    sessionsByType: {},
    dailyActivity: {}
  };

  snapshot.forEach(doc => {
    const completion = doc.data();
    
    stats.totalQuestions += completion.questionCount || 0;
    stats.totalCorrect += completion.correctAnswers || 0;
    
    // Group by session type
    if (!stats.sessionsByType[completion.sessionType]) {
      stats.sessionsByType[completion.sessionType] = 0;
    }
    stats.sessionsByType[completion.sessionType]++;
    
    // Daily activity
    if (!stats.dailyActivity[completion.date]) {
      stats.dailyActivity[completion.date] = {
        sessions: 0,
        questions: 0,
        accuracy: 0
      };
    }
    stats.dailyActivity[completion.date].sessions++;
    stats.dailyActivity[completion.date].questions += completion.questionCount || 0;
    stats.dailyActivity[completion.date].accuracy += completion.accuracy || 0;
  });

  // Calculate average accuracy
  if (stats.totalQuestions > 0) {
    stats.averageAccuracy = Math.round((stats.totalCorrect / stats.totalQuestions) * 100);
  }

  // Average accuracy per day
  Object.keys(stats.dailyActivity).forEach(date => {
    const day = stats.dailyActivity[date];
    if (day.sessions > 0) {
      day.accuracy = Math.round(day.accuracy / day.sessions);
    }
  });

  return stats;
}

export const calendarService = {
  addMajorExam,
  addSmallQuiz,
  addCompletedSession,
  completeEvent,
  deleteEvent,
  getCalendarData,
  getCompletionStats
};

export default calendarService;
--- END_OF_FILE ---

--- FILE_PATH: src/services/performanceService.js ---
import { doc, setDoc, getDoc, getDocs, collection, query, where, writeBatch, serverTimestamp } from 'firebase/firestore';
import { db } from '../firebase/config';

/**
 * Performance Service - Tracks user performance by topic/subtopic
 * Records quiz results and identifies weak areas for AI recommendations
 */

export const performanceService = {
  
  /**
   * Record quiz results grouped by subtopic
   * @param {string} userId - User ID
   * @param {Array} questions - Questions from the quiz
   * @param {Object} answers - User's answers {questionId: selectedOption}
   */
  async recordQuizResults(userId, questions, answers) {
    try {
      // Group questions by topic::subtopic
      const subtopicGroups = {};
      
      questions.forEach(question => {
        const topic = question.Topic || 'General';
        const subtopic = question.Subtopic || 'General';
        const key = `${topic}::${subtopic}`;
        
        if (!subtopicGroups[key]) {
          subtopicGroups[key] = {
            topic,
            subtopic,
            questions: [],
            correct: 0,
            total: 0
          };
        }
        
        subtopicGroups[key].questions.push(question);
        subtopicGroups[key].total++;
        
        // Check if answer is correct
        if (answers[question.ID] === question.CorrectOption) {
          subtopicGroups[key].correct++;
        }
      });
      
      // Update Firestore for each subtopic
      const batch = writeBatch(db);
      
      for (const [key, data] of Object.entries(subtopicGroups)) {
        const subtopicRef = doc(db, 'user_performance', userId, 'subtopics', key);
        
        // Get existing data
        const existingDoc = await getDoc(subtopicRef);
        const existing = existingDoc.exists() ? existingDoc.data() : null;
        
        // Calculate new values
        const totalAttempts = (existing?.totalAttempts || 0) + data.total;
        const correctAttempts = (existing?.correctAttempts || 0) + data.correct;
        const accuracy = totalAttempts > 0 ? correctAttempts / totalAttempts : 0;
        const newAccuracy = data.correct / data.total;
        
        // Track recent attempts (last 10)
        const recentAttempts = existing?.recentAttempts || [];
        recentAttempts.push({
          date: new Date().toISOString(),
          total: data.total,
          correct: data.correct,
          accuracy: newAccuracy
        });
        
        // Keep only last 10 attempts
        if (recentAttempts.length > 10) {
          recentAttempts.shift();
        }
        
        // Merge with existing data
        batch.set(subtopicRef, {
          topic: data.topic,
          subtopic: data.subtopic,
          totalAttempts,
          correctAttempts,
          accuracy,
          lastAttempted: new Date().toISOString(),
          firstAttempted: existing?.firstAttempted || new Date().toISOString(),
          questionsSeen: Array.from(new Set([
            ...(existing?.questionsSeen || []),
            ...data.questions.map(q => q.ID)
          ])),
          recentAttempts,
          updatedAt: new Date().toISOString()
        }, { merge: true });
      }
      
      await batch.commit();
      
      // After recording, trigger AI recommendation generation
      await this.generateAIRecommendations(userId);
      
      return Object.keys(subtopicGroups).length;
    } catch (error) {
      console.error('Error recording quiz results:', error);
      throw error;
    }
  },
  
  /**
   * Get performance data for a specific subtopic
   */
  async getSubtopicPerformance(userId, topic, subtopic) {
    try {
      const key = `${topic}::${subtopic}`;
      const subtopicRef = doc(db, 'user_performance', userId, 'subtopics', key);
      const docSnap = await getDoc(subtopicRef);
      
      return docSnap.exists() ? docSnap.data() : null;
    } catch (error) {
      console.error('Error getting subtopic performance:', error);
      return null;
    }
  },
  
  /**
   * Get all performance data for user
   */
  async getAllPerformance(userId) {
    try {
      const subtopicsRef = collection(db, 'user_performance', userId, 'subtopics');
      const snapshot = await getDocs(subtopicsRef);
      
      const performance = [];
      snapshot.forEach(doc => {
        performance.push({
          id: doc.id,
          ...doc.data()
        });
      });
      
      return performance;
    } catch (error) {
      console.error('Error getting all performance:', error);
      return [];
    }
  },
  
  /**
   * Generate AI recommendations based on performance data
   * Identifies weak subtopics and creates study suggestions
   */
  async generateAIRecommendations(userId) {
    try {
      const performance = await this.getAllPerformance(userId);
      
      // Identify weak subtopics
      const weakAreas = performance.filter(p => {
        // Criteria for weakness:
        // 1. Accuracy < 60% AND attempted at least 5 questions
        // 2. OR accuracy < 70% AND attempted at least 10 questions
        // 3. OR declining trend in recent attempts
        
        const hasLowAccuracy = p.accuracy < 0.6 && p.totalAttempts >= 5;
        const hasModerateWeakness = p.accuracy < 0.7 && p.totalAttempts >= 10;
        
        // Check for declining trend
        const hasDecliningTrend = this.checkDecliningTrend(p.recentAttempts);
        
        return hasLowAccuracy || hasModerateWeakness || hasDecliningTrend;
      });
      
      // Sort by priority (lowest accuracy first)
      weakAreas.sort((a, b) => a.accuracy - b.accuracy);
      
      // Create recommendations for top 5 weak areas
      const recommendations = weakAreas.slice(0, 5).map((area, index) => {
        const priority = area.accuracy < 0.5 ? 'HIGH' : 
                        area.accuracy < 0.6 ? 'MEDIUM' : 'LOW';
        
        // Suggest date: tomorrow + index (spread recommendations)
        const suggestedDate = new Date();
        suggestedDate.setDate(suggestedDate.getDate() + index + 1);
        
        const questionCount = priority === 'HIGH' ? 20 : 
                              priority === 'MEDIUM' ? 15 : 10;
        
        return {
          topic: area.topic,
          subtopic: area.subtopic,
          reason: this.generateReason(area),
          priority,
          suggestedDate: suggestedDate.toISOString().split('T')[0],
          questionCount,
          currentAccuracy: Math.round(area.accuracy * 100),
          attemptsCount: area.totalAttempts,
          status: 'pending', // pending, accepted, dismissed
          createdAt: new Date().toISOString()
        };
      });
      
      // Save recommendations to Firestore
      await this.saveRecommendations(userId, recommendations);
      
      return recommendations;
    } catch (error) {
      console.error('Error generating AI recommendations:', error);
      return [];
    }
  },
  
  /**
   * Check if there's a declining performance trend
   */
  checkDecliningTrend(recentAttempts) {
    if (!recentAttempts || recentAttempts.length < 3) return false;
    
    // Get last 3 attempts
    const last3 = recentAttempts.slice(-3);
    
    // Check if each attempt is worse than the previous
    for (let i = 1; i < last3.length; i++) {
      if (last3[i].accuracy >= last3[i-1].accuracy) {
        return false; // Not consistently declining
      }
    }
    
    return true;
  },
  
  /**
   * Generate human-readable reason for recommendation
   */
  generateReason(area) {
    const accuracy = Math.round(area.accuracy * 100);
    
    if (area.accuracy < 0.5) {
      return `Critical weakness (${accuracy}% accuracy). Needs immediate review.`;
    } else if (area.accuracy < 0.6) {
      return `Below target (${accuracy}% accuracy). Practice recommended.`;
    } else if (area.accuracy < 0.7) {
      return `Room for improvement (${accuracy}% accuracy). Additional practice suggested.`;
    } else {
      return `Recent performance decline detected. Reinforce fundamentals.`;
    }
  },
  
  /**
   * Save recommendations to Firestore
   */
  async saveRecommendations(userId, recommendations) {
    try {
      const batch = writeBatch(db);
      
      // Clear old pending recommendations first
      const oldRecsRef = collection(db, 'ai_recommendations', userId, 'suggestions');
      const oldQuery = query(oldRecsRef, where('status', '==', 'pending'));
      const oldDocs = await getDocs(oldQuery);
      
      oldDocs.forEach(doc => {
        batch.delete(doc.ref);
      });
      
      // Add new recommendations
      recommendations.forEach(rec => {
        const recRef = doc(collection(db, 'ai_recommendations', userId, 'suggestions'));
        batch.set(recRef, rec);
      });
      
      await batch.commit();
    } catch (error) {
      console.error('Error saving recommendations:', error);
      throw error;
    }
  },
  
  /**
   * Get AI recommendations for user
   */
  async getRecommendations(userId) {
    try {
      const recsRef = collection(db, 'ai_recommendations', userId, 'suggestions');
      const q = query(recsRef, where('status', '==', 'pending'));
      const snapshot = await getDocs(q);
      
      const recommendations = [];
      snapshot.forEach(doc => {
        recommendations.push({
          id: doc.id,
          ...doc.data()
        });
      });
      
      // Sort by priority (HIGH -> MEDIUM -> LOW)
      const priorityOrder = { 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3 };
      recommendations.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
      
      return recommendations;
    } catch (error) {
      console.error('Error getting recommendations:', error);
      return [];
    }
  },
  
  /**
   * Accept a recommendation (convert to calendar event)
   */
  async acceptRecommendation(userId, recommendationId) {
    try {
      const recRef = doc(db, 'ai_recommendations', userId, 'suggestions', recommendationId);
      await setDoc(recRef, {
        status: 'accepted',
        acceptedAt: new Date().toISOString()
      }, { merge: true });
    } catch (error) {
      console.error('Error accepting recommendation:', error);
      throw error;
    }
  },
  
  /**
   * Dismiss a recommendation
   */
  async dismissRecommendation(userId, recommendationId) {
    try {
      const recRef = doc(db, 'ai_recommendations', userId, 'suggestions', recommendationId);
      await setDoc(recRef, {
        status: 'dismissed',
        dismissedAt: new Date().toISOString()
      }, { merge: true });
    } catch (error) {
      console.error('Error dismissing recommendation:', error);
      throw error;
    }
  }
};
--- END_OF_FILE ---

--- FILE_PATH: src/utils/calendarEventManager.js ---
/**
 * Calendar Event Manager (Merged)
 * Combines user-specific storage with spaced repetition and event management
 */

import { auth } from '../firebase/config';

// Event Types
export const EVENT_TYPES = {
  MAJOR_EXAM: 'major_exam',
  SMALL_QUIZ: 'small_quiz',
  STUDY_SUGGESTION: 'study_suggestion',
  MISTAKE_REVIEW: 'mistake_review',
  COMPLETED_ACTIVITY: 'completed_activity',
};

// Event Icons
export const EVENT_ICONS = {
  [EVENT_TYPES.MAJOR_EXAM]: 'üö©',
  [EVENT_TYPES.SMALL_QUIZ]: '‚úèÔ∏è',
  [EVENT_TYPES.STUDY_SUGGESTION]: 'üí°',
  [EVENT_TYPES.MISTAKE_REVIEW]: 'üß†',
  [EVENT_TYPES.COMPLETED_ACTIVITY]: '‚úÖ',
};

/**
 * Get user-specific storage key (Firebase auth aware)
 */
function getUserStorageKey(suffix) {
  const user = auth.currentUser;
  if (!user) return `studyCalendar_guest_${suffix}`;
  return `studyCalendar_${user.uid}_${suffix}`;
}

/**
 * Load calendar data from localStorage (user-specific)
 */
export function loadCalendarData() {
  try {
    const data = localStorage.getItem(getUserStorageKey('data'));
    return data ? JSON.parse(data) : { events: [], completedSessions: {} };
  } catch (error) {
    console.error('Error loading calendar data:', error);
    return { events: [], completedSessions: {} };
  }
}

/**
 * Save calendar data to localStorage (user-specific)
 */
export function saveCalendarData(data) {
  try {
    localStorage.setItem(getUserStorageKey('data'), JSON.stringify(data));
    // Trigger storage event for cross-component updates
    window.dispatchEvent(new Event('calendar-update'));
  } catch (error) {
    console.error('Error saving calendar data:', error);
  }
}

/**
 * Get all calendar events
 */
export function getCalendarEvents() {
  const data = loadCalendarData();
  return data.events || [];
}

/**
 * Save calendar events
 */
export function saveCalendarEvents(events) {
  const data = loadCalendarData();
  data.events = events;
  saveCalendarData(data);
}

/**
 * Calculate spaced repetition interval based on mistake improvement count
 * Uses SM-2 inspired algorithm with mistake-specific adjustments
 */
export function calculateSpacedRepetitionDate(mistake) {
  const now = new Date();
  const improvementCount = mistake.improvementCount || 0;
  
  // Spaced repetition intervals (in days)
  const intervals = {
    0: 1,   // First review: next day
    1: 3,   // Second review: 3 days later
    2: 7,   // Third review: 1 week later
    3: 14,  // Mastered but reinforce: 2 weeks
  };
  
  const daysToAdd = intervals[improvementCount] || 14;
  const reviewDate = new Date(now);
  reviewDate.setDate(reviewDate.getDate() + daysToAdd);
  
  return reviewDate.toISOString().split('T')[0];
}

/**
 * Generate study suggestions based on exam date and topic
 * Returns array of suggestion events with scaled MCQ counts
 */
export function generateExamPrepSuggestions(examDate, topic, subtopic = null) {
  const exam = new Date(examDate);
  const suggestions = [];
  
  // Major Exam Scaling Algorithm
  const prepSchedule = [
    { daysBeforeStart: 10, daysBeforeEnd: 7, mcqCount: 10, phase: 'Warm-up' },
    { daysBeforeStart: 6, daysBeforeEnd: 4, mcqCount: 20, phase: 'Consolidation' },
    { daysBeforeStart: 3, daysBeforeEnd: 1, mcqCount: 40, phase: 'Sprint' },
  ];
  
  prepSchedule.forEach(({ daysBeforeStart, daysBeforeEnd, mcqCount, phase }) => {
    for (let day = daysBeforeStart; day >= daysBeforeEnd; day--) {
      const suggestionDate = new Date(exam);
      suggestionDate.setDate(suggestionDate.getDate() - day);
      
      suggestions.push({
        id: `prep_${topic}_${day}`,
        type: EVENT_TYPES.STUDY_SUGGESTION,
        date: suggestionDate.toISOString().split('T')[0],
        title: `${phase} - ${mcqCount} MCQs`,
        description: `Practice ${mcqCount} questions on ${topic}`,
        topic,
        subtopic,
        mcqCount,
        phase,
        linkedExamId: examDate,
      });
    }
  });
  
  return suggestions;
}

/**
 * Generate quiz prep suggestions (smaller scale)
 */
export function generateQuizPrepSuggestions(quizDate, topic, subtopic) {
  const quiz = new Date(quizDate);
  const suggestions = [];
  
  // Small Quiz: 3-1 days before with 5-15 MCQs on subtopic
  for (let day = 3; day >= 1; day--) {
    const suggestionDate = new Date(quiz);
    suggestionDate.setDate(suggestionDate.getDate() - day);
    
    const mcqCount = day === 1 ? 15 : (day === 2 ? 10 : 5);
    
    suggestions.push({
      id: `quiz_prep_${subtopic}_${day}`,
      type: EVENT_TYPES.STUDY_SUGGESTION,
      date: suggestionDate.toISOString().split('T')[0],
      title: `Quiz Prep - ${mcqCount} MCQs`,
      description: `Review ${mcqCount} questions on ${subtopic}`,
      topic,
      subtopic,
      mcqCount,
      linkedQuizId: quizDate,
    });
  }
  
  return suggestions;
}

/**
 * Add a new event (exam or quiz)
 */
export function addCalendarEvent(event) {
  const events = getCalendarEvents();
  
  // Add the main event
  events.push({
    ...event,
    id: event.id || `${event.type}_${Date.now()}`,
    createdAt: new Date().toISOString(),
  });
  
  // Generate prep suggestions if it's an exam or quiz
  if (event.type === EVENT_TYPES.MAJOR_EXAM) {
    const suggestions = generateExamPrepSuggestions(event.date, event.topic, event.subtopic);
    events.push(...suggestions);
  } else if (event.type === EVENT_TYPES.SMALL_QUIZ) {
    const suggestions = generateQuizPrepSuggestions(event.date, event.topic, event.subtopic);
    events.push(...suggestions);
  }
  
  saveCalendarEvents(events);
  return events;
}

/**
 * Delete an event and its associated suggestions
 */
export function deleteCalendarEvent(eventId) {
  const events = getCalendarEvents();
  const filtered = events.filter(e => 
    e.id !== eventId && 
    e.linkedExamId !== eventId && 
    e.linkedQuizId !== eventId
  );
  saveCalendarEvents(filtered);
  return filtered;
}

/**
 * Mark event as completed
 */
export function completeCalendarEvent(eventId, completedData = {}) {
  const events = getCalendarEvents();
  const event = events.find(e => e.id === eventId);
  
  if (event) {
    // Mark original as completed
    event.completed = true;
    event.completedAt = new Date().toISOString();
    event.completedData = completedData;
    
    // Add completion badge
    events.push({
      id: `completed_${eventId}`,
      type: EVENT_TYPES.COMPLETED_ACTIVITY,
      date: event.date,
      title: `‚úÖ ${event.title}`,
      description: `Completed: ${event.description}`,
      parentEventId: eventId,
    });
  }
  
  saveCalendarEvents(events);
  return events;
}

/**
 * Schedule mistake review based on spaced repetition
 */
export function scheduleMistakeReview(mistake) {
  const events = getCalendarEvents();
  const reviewDate = calculateSpacedRepetitionDate(mistake);
  
  // Remove old review for this mistake
  const filtered = events.filter(e => 
    !(e.type === EVENT_TYPES.MISTAKE_REVIEW && e.mistakeId === mistake.ID)
  );
  
  // Add new review
  filtered.push({
    id: `review_${mistake.ID}_${Date.now()}`,
    type: EVENT_TYPES.MISTAKE_REVIEW,
    date: reviewDate,
    title: `Review Mistake`,
    description: `${mistake.Topic} ‚Üí ${mistake.Subtopic}`,
    topic: mistake.Topic,
    subtopic: mistake.Subtopic,
    mistakeId: mistake.ID,
    improvementCount: mistake.improvementCount || 0,
  });
  
  saveCalendarEvents(filtered);
  return filtered;
}

/**
 * Batch schedule mistake reviews for all active mistakes
 */
export function batchScheduleMistakeReviews(mistakes) {
  const events = getCalendarEvents();
  
  // Remove all existing mistake reviews
  const filtered = events.filter(e => e.type !== EVENT_TYPES.MISTAKE_REVIEW);
  
  // Add new reviews for all mistakes
  mistakes.forEach(mistake => {
    const reviewDate = calculateSpacedRepetitionDate(mistake);
    
    filtered.push({
      id: `review_${mistake.ID}_${Date.now()}`,
      type: EVENT_TYPES.MISTAKE_REVIEW,
      date: reviewDate,
      title: `Review Mistake`,
      description: `${mistake.Topic}${mistake.Subtopic ? ` ‚Üí ${mistake.Subtopic}` : ''}`,
      topic: mistake.Topic,
      subtopic: mistake.Subtopic,
      mistakeId: mistake.ID,
      improvementCount: mistake.improvementCount || 0,
    });
  });
  
  saveCalendarEvents(filtered);
  return filtered;
}

/**
 * Get events for a specific date
 */
export function getEventsForDate(dateStr) {
  const events = getCalendarEvents();
  return events.filter(e => e.date === dateStr && !e.completed);
}

/**
 * Get events for a date range
 */
export function getEventsForDateRange(startDate, endDate) {
  const events = getCalendarEvents();
  const start = new Date(startDate);
  const end = new Date(endDate);
  
  return events.filter(e => {
    const eventDate = new Date(e.date);
    return eventDate >= start && eventDate <= end && !e.completed;
  });
}

/**
 * Get events in range (alias for compatibility)
 */
export function getEventsInRange(startDate, endDate) {
  return getEventsForDateRange(startDate, endDate);
}

/**
 * Get upcoming events (next 7 days)
 */
export function getUpcomingEvents(days = 7) {
  const today = new Date();
  const future = new Date();
  future.setDate(future.getDate() + days);
  
  return getEventsForDateRange(
    today.toISOString().split('T')[0],
    future.toISOString().split('T')[0]
  ).sort((a, b) => new Date(a.date) - new Date(b.date));
}

/**
 * Add completed session to calendar
 */
export function addCompletedSession(date, sessionType, details = {}) {
  const calendarData = loadCalendarData();
  const dateStr = date.toISOString().split('T')[0];
  
  if (!calendarData.completedSessions[dateStr]) {
    calendarData.completedSessions[dateStr] = [];
  }
  
  calendarData.completedSessions[dateStr].push({
    type: sessionType,
    timestamp: new Date().toISOString(),
    ...details
  });
  
  saveCalendarData(calendarData);
}

/**
 * Get completed sessions for a specific date
 */
export function getCompletedSessions(date) {
  const calendarData = loadCalendarData();
  const dateStr = date.toISOString().split('T')[0];
  return calendarData.completedSessions[dateStr] || [];
}

/**
 * Remove event from calendar (alias for compatibility)
 */
export function removeCalendarEvent(eventId) {
  return deleteCalendarEvent(eventId);
}

/**
 * Clear old data (older than 6 months)
 */
export function clearOldCalendarData() {
  const calendarData = loadCalendarData();
  const sixMonthsAgo = new Date();
  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
  
  // Filter old events
  calendarData.events = calendarData.events.filter(event => 
    new Date(event.date) >= sixMonthsAgo
  );
  
  // Filter old completed sessions
  Object.keys(calendarData.completedSessions).forEach(dateStr => {
    if (new Date(dateStr) < sixMonthsAgo) {
      delete calendarData.completedSessions[dateStr];
    }
  });
  
  saveCalendarData(calendarData);
}
--- END_OF_FILE ---

--- FILE_PATH: src/utils/storeItems.js ---
// ============================================================================
// STORE ITEMS - ChemStore Catalog
// ============================================================================

export const STORE_ITEMS = {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PROFILE PICTURES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  profilePics: [
    {
      id: 'flask_blue',
      name: 'Blue Flask',
      description: 'Classic chemistry icon',
      price: 0,
      icon: 'üß™',
      rarity: 'common',
      category: 'profilePic'
    },
    {
      id: 'atom_green',
      name: 'Green Atom',
      description: 'Atomic structure design',
      price: 50,
      icon: '‚öõÔ∏è',
      rarity: 'common',
      category: 'profilePic'
    },
    {
      id: 'molecule',
      name: 'Molecule Master',
      description: 'For molecular enthusiasts',
      price: 100,
      icon: 'üî¨',
      rarity: 'uncommon',
      category: 'profilePic'
    },
    {
      id: 'fire',
      name: 'Combustion King',
      description: 'Exothermic reactions only',
      price: 150,
      icon: 'üî•',
      rarity: 'uncommon',
      category: 'profilePic'
    },
    {
      id: 'lightning',
      name: 'Electrochemist',
      description: 'Charged with energy',
      price: 200,
      icon: '‚ö°',
      rarity: 'rare',
      category: 'profilePic'
    },
    {
      id: 'crystal',
      name: 'Crystal Scholar',
      description: 'Perfectly structured',
      price: 250,
      icon: 'üíé',
      rarity: 'rare',
      category: 'profilePic'
    },
    {
      id: 'explosion',
      name: 'Reaction Expert',
      description: 'Explosive personality',
      price: 300,
      icon: 'üí•',
      rarity: 'epic',
      category: 'profilePic'
    },
    {
      id: 'star',
      name: 'Chemistry Star',
      description: 'Shine bright like neon',
      price: 400,
      icon: '‚≠ê',
      rarity: 'epic',
      category: 'profilePic'
    },
    {
      id: 'crown',
      name: 'Noble Gas King',
      description: 'Unreactive royalty',
      price: 500,
      icon: 'üëë',
      rarity: 'legendary',
      category: 'profilePic'
    },
    {
      id: 'trophy',
      name: 'Grand Master',
      description: 'Ultimate achievement',
      price: 1000,
      icon: 'üèÜ',
      rarity: 'legendary',
      category: 'profilePic'
    }
  ],

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BADGES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  badges: [
    {
      id: 'beginner',
      name: 'Beginner Badge',
      description: 'Your first steps',
      price: 0,
      icon: 'üéñÔ∏è',
      rarity: 'common',
      category: 'badge'
    },
    {
      id: 'scholar',
      name: 'Scholar Badge',
      description: '100 questions solved',
      price: 200,
      icon: 'üìö',
      rarity: 'uncommon',
      category: 'badge'
    },
    {
      id: 'expert',
      name: 'Expert Badge',
      description: '500 questions mastered',
      price: 500,
      icon: 'üéì',
      rarity: 'rare',
      category: 'badge'
    }
  ],

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ THEMES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  themes: [
    {
      id: 'default',
      name: 'Classic Blue',
      description: 'Original ChemLeung theme',
      price: 0,
      preview: 'linear-gradient(135deg, #2563eb, #1e40af)',
      rarity: 'common',
      category: 'theme'
    },
    {
      id: 'forest',
      name: 'Forest Green',
      description: 'Organic chemistry vibes',
      price: 150,
      preview: 'linear-gradient(135deg, #10b981, #059669)',
      rarity: 'uncommon',
      category: 'theme'
    },
    {
      id: 'sunset',
      name: 'Sunset Orange',
      description: 'Warm combustion colors',
      price: 200,
      preview: 'linear-gradient(135deg, #f97316, #ea580c)',
      rarity: 'rare',
      category: 'theme'
    },
    {
      id: 'royal',
      name: 'Royal Purple',
      description: 'Permanganate elegance',
      price: 300,
      preview: 'linear-gradient(135deg, #9333ea, #7e22ce)',
      rarity: 'epic',
      category: 'theme'
    }
  ]
};

// Flatten all items for easy lookup
export const ALL_ITEMS = [
  ...STORE_ITEMS.profilePics,
  ...STORE_ITEMS.badges,
  ...STORE_ITEMS.themes
];

// Get item by ID
export function getItemById(itemId) {
  return ALL_ITEMS.find(item => item.id === itemId);
}

// Rarity colors
export const RARITY_COLORS = {
  common: 'from-slate-400 to-slate-500',
  uncommon: 'from-green-400 to-green-600',
  rare: 'from-blue-400 to-blue-600',
  epic: 'from-purple-400 to-purple-600',
  legendary: 'from-amber-400 to-amber-600'
};

export const RARITY_BORDER = {
  common: 'border-slate-300',
  uncommon: 'border-green-300',
  rare: 'border-blue-300',
  epic: 'border-purple-300',
  legendary: 'border-amber-300'
};

export const RARITY_LABELS = {
  common: 'Common',
  uncommon: 'Uncommon',
  rare: 'Rare',
  epic: 'Epic',
  legendary: 'Legendary'
};
--- END_OF_FILE ---

--- FILE_PATH: src/components/dashboard/SmartMonthlyCalendar.jsx ---
import React, { useState, useEffect, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { ChevronLeft, ChevronRight, Plus, Flag, Calendar as CalendarIcon, BookOpen, Brain, CheckCircle, Trash2, X, Sparkles, ThumbsUp, ThumbsDown, Play, Info } from 'lucide-react';
import { calendarService, EVENT_TYPES } from '../../services/calendarService';
import { performanceService } from '../../services/performanceService';
import { quizStorage } from '../../utils/quizStorage';
import { motion, AnimatePresence } from 'framer-motion';
import SpacedRepetitionModal from './SpacedRepetitionModal';

/**
 * SmartMonthlyCalendar - COMPLETE FIX VERSION
 * 
 * FIXES:
 * 1. ‚úÖ Batch review now properly loads ALL repetitions for the selected date
 *    - Fixed line 291: Use repetition.date directly instead of parsing
 * 2. ‚úÖ Better error handling for event deletion with detailed messages
 * 3. ‚úÖ Enhanced console logging for debugging
 */
export default function SmartMonthlyCalendar({ userId, questions = [], onAddEvent }) {
  const navigate = useNavigate();
  const [currentDate, setCurrentDate] = useState(new Date());
  const [calendarData, setCalendarData] = useState({});
  const [loading, setLoading] = useState(true);
  const [selectedDate, setSelectedDate] = useState(null);
  const [hoveredDate, setHoveredDate] = useState(null);
  const [aiRecommendations, setAIRecommendations] = useState([]);
  const [suggestionPreview, setSuggestionPreview] = useState(null);
  const [reviewModal, setReviewModal] = useState(null);
  
  const year = currentDate.getFullYear();
  const month = currentDate.getMonth();
  
  // Load calendar data and AI recommendations
  useEffect(() => {
    loadCalendarData();
    loadAIRecommendations();
  }, [userId, year, month]);

  async function loadCalendarData() {
    if (!userId) return;
    
    try {
      setLoading(true);
      const data = await calendarService.getCalendarData(userId, year, month);
      console.log('üìÖ Calendar data loaded:', data);
      setCalendarData(data);
    } catch (error) {
      console.error('Error loading calendar data:', error);
    } finally {
      setLoading(false);
    }
  }

  async function loadAIRecommendations() {
    if (!userId) return;
    
    try {
      const recommendations = await performanceService.getRecommendations(userId);
      console.log('ü§ñ AI Recommendations loaded:', recommendations);
      setAIRecommendations(recommendations);
    } catch (error) {
      console.error('Error loading AI recommendations:', error);
    }
  }

  // Generate calendar grid
  const calendarGrid = useMemo(() => {
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startingDayOfWeek = firstDay.getDay();
    const daysInMonth = lastDay.getDate();
    
    const grid = [];
    let week = [];
    
    // Add empty cells for days before month starts
    for (let i = 0; i < startingDayOfWeek; i++) {
      week.push(null);
    }
    
    // Add all days in month
    for (let day = 1; day <= daysInMonth; day++) {
      week.push(day);
      
      if (week.length === 7) {
        grid.push(week);
        week = [];
      }
    }
    
    // Add remaining days to complete the last week
    if (week.length > 0) {
      while (week.length < 7) {
        week.push(null);
      }
      grid.push(week);
    }
    
    return grid;
  }, [year, month]);

  const monthName = new Date(year, month, 1).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
  const today = new Date().toISOString().split('T')[0];

  function prevMonth() {
    setCurrentDate(new Date(year, month - 1, 1));
  }

  function nextMonth() {
    setCurrentDate(new Date(year, month + 1, 1));
  }

  function getDateString(day) {
    if (!day) return null;
    return new Date(year, month, day).toISOString().split('T')[0];
  }

  function getDayEvents(day) {
    const dateStr = getDateString(day);
    if (!dateStr) return null;
    return calendarData[dateStr] || null;
  }

  function isToday(day) {
    return getDateString(day) === today;
  }

  function isPast(day) {
    if (!day) return false;
    return getDateString(day) < today;
  }

  // Get available questions for a suggestion
  function getAvailableQuestions(suggestion) {
    if (!questions || questions.length === 0) {
      return { filtered: [], count: 0 };
    }

    let filtered = [...questions];
    
    if (suggestion.topic) {
      filtered = filtered.filter(q => q.Topic === suggestion.topic);
    }
    
    if (suggestion.subtopic) {
      filtered = filtered.filter(q => q.Subtopic === suggestion.subtopic);
    }
    
    return {
      filtered: filtered.slice(0, suggestion.questionCount),
      count: filtered.length,
      requested: suggestion.questionCount
    };
  }

  // Preview suggestion details
  function handleSuggestionPreview(suggestion, event) {
    event?.stopPropagation();
    const questionInfo = getAvailableQuestions(suggestion);
    setSuggestionPreview({ ...suggestion, questionInfo });
  }

  async function handleAcceptRecommendation(recommendation, event) {
    event?.stopPropagation();
    
    try {
      // Create calendar event from recommendation
      await calendarService.createAIRecommendationEvent(userId, recommendation);
      
      // Reload calendar and recommendations
      await loadCalendarData();
      await loadAIRecommendations();
    } catch (error) {
      console.error('Error accepting recommendation:', error);
      alert('Failed to add recommendation to calendar.');
    }
  }

  async function handleDismissRecommendation(recommendationId, event) {
    event?.stopPropagation();
    
    try {
      await performanceService.dismissRecommendation(userId, recommendationId);
      await loadAIRecommendations();
    } catch (error) {
      console.error('Error dismissing recommendation:', error);
    }
  }

  async function handleAIRecommendationClick(aiRec) {
    try {
      let filteredQuestions = questions;
      
      if (aiRec.topic) {
        filteredQuestions = filteredQuestions.filter(q => q.Topic === aiRec.topic);
      }
      
      if (aiRec.subtopic) {
        filteredQuestions = filteredQuestions.filter(q => q.Subtopic === aiRec.subtopic);
      }

      const selectedQuestions = filteredQuestions
        .sort(() => Math.random() - 0.5)
        .slice(0, Math.min(aiRec.questionCount, filteredQuestions.length));

      if (selectedQuestions.length === 0) {
        alert(`No questions available for ${aiRec.topic || 'this topic'}${aiRec.subtopic ? ' - ' + aiRec.subtopic : ''}.`);
        return;
      }

      quizStorage.clearQuizData();
      quizStorage.saveSelectedQuestions(selectedQuestions);
      localStorage.setItem('quiz_mode', 'ai-recommendation');
      localStorage.setItem('quiz_event_id', aiRec.id);
      localStorage.setItem('quiz_timer_enabled', 'true');
      navigate('/quiz');
    } catch (error) {
      console.error('Error starting AI recommendation session:', error);
      alert('Failed to start study session. Please try again.');
    }
  }

  async function handleStudySuggestionClick(suggestion) {
    try {
      // Check if questions are loaded
      if (!questions || questions.length === 0) {
        alert('Questions are still loading. Please wait a moment and try again.');
        return;
      }

      // Filter questions by topic/subtopic if specified
      let filteredQuestions = [...questions];
      
      if (suggestion.topic) {
        filteredQuestions = filteredQuestions.filter(q => q.Topic === suggestion.topic);
      }
      
      if (suggestion.subtopic) {
        filteredQuestions = filteredQuestions.filter(q => q.Subtopic === suggestion.subtopic);
      }

      if (filteredQuestions.length === 0) {
        alert(
          `No questions available for ${suggestion.topic || 'all topics'}${
            suggestion.subtopic ? ' - ' + suggestion.subtopic : ''
          }.\n\nPlease check that your question database includes this topic.`
        );
        return;
      }

      // Select random questions up to the suggested count
      const selectedQuestions = filteredQuestions
        .sort(() => Math.random() - 0.5)
        .slice(0, Math.min(suggestion.questionCount, filteredQuestions.length));

      // Save to quiz storage and navigate
      quizStorage.clearQuizData();
      quizStorage.saveSelectedQuestions(selectedQuestions);
      localStorage.setItem('quiz_mode', 'study-plan');
      localStorage.setItem('quiz_event_id', suggestion.id);
      localStorage.setItem('quiz_event_phase', suggestion.phase || '');
      localStorage.setItem('quiz_timer_enabled', 'true');
      navigate('/quiz');
    } catch (error) {
      console.error('Error starting study session:', error);
      alert('Failed to start study session. Please try again.');
    }
  }

  /**
   * üîß KEY FIX: Spaced repetition click handler
   * 
   * OLD (BROKEN) LINE 291:
   * const dateStr = getDateString(parseInt(repetition.date?.split('-')[2]) || new Date().getDate());
   * ‚ùå This was trying to parse just the day (e.g., "14") and then reconstruct the date
   * ‚ùå This caused it to look at the wrong date in calendarData
   * 
   * NEW (FIXED):
   * const dateStr = repetition.date;
   * ‚úÖ Use the full date string directly from the repetition (e.g., "2026-02-14")
   * ‚úÖ This matches the keys in calendarData correctly
   */
  function handleSpacedRepetitionClick(repetition, event) {
    event?.stopPropagation();
    
    // üéØ FIX: Use the date directly from repetition
    const dateStr = repetition.date; // e.g., "2026-02-14"
    
    // Get ALL repetitions for this date
    const allRepsForDay = calendarData[dateStr]?.repetitions || [];
    
    console.log('üîç Opening review modal:', {
      clickedRep: repetition,
      dateStr,
      totalRepsForDay: allRepsForDay.length,
      allReps: allRepsForDay.map(r => ({ 
        id: r.id, 
        questionId: r.questionId, 
        completed: r.completed,
        topic: r.topic,
        subtopic: r.subtopic
      }))
    });
    
    // Ensure we have the questions array
    if (!questions || questions.length === 0) {
      alert('Questions are still loading. Please wait a moment and try again.');
      return;
    }
    
    // Verify we have repetitions to show
    if (allRepsForDay.length === 0) {
      console.warn('‚ö†Ô∏è No repetitions found for date:', dateStr);
      alert('No review sessions found for this day. This might be a data issue.');
      return;
    }
    
    console.log(`‚úÖ Found ${allRepsForDay.length} repetition(s) for ${dateStr}`);
    
    setReviewModal({
      repetition,
      allRepetitions: allRepsForDay,  // üéØ Pass ALL repetitions
      dateStr
    });
  }

  /**
   * Handle starting review from modal
   */
  async function handleStartReview(reviewMode, questionIds) {
    try {
      console.log('üéØ Starting review:', { reviewMode, questionIds });
      
      const reviewQuestions = questions.filter(q => questionIds.includes(q.ID));
      
      if (reviewQuestions.length === 0) {
        alert('Questions not found in database.');
        return;
      }

      console.log(`‚úÖ Found ${reviewQuestions.length} questions for review`);

      quizStorage.clearQuizData();
      quizStorage.saveSelectedQuestions(reviewQuestions);
      localStorage.setItem('quiz_mode', 'spaced-repetition');
      localStorage.setItem('quiz_review_mode', reviewMode);
      localStorage.setItem('quiz_event_ids', JSON.stringify(
        reviewModal.allRepetitions
          .filter(r => questionIds.includes(r.questionId))
          .map(r => r.id)
      ));
      localStorage.setItem('quiz_timer_enabled', 'true');
      setReviewModal(null);
      navigate('/quiz');
    } catch (error) {
      console.error('Error starting review:', error);
      alert('Failed to start review. Please try again.');
    }
  }

  /**
   * üîß IMPROVED: Delete event with better error handling
   */
  async function handleDeleteEvent(eventId, eventType, event) {
    event.stopPropagation();
    
    const eventTypeLabel = eventType === EVENT_TYPES.MAJOR_EXAM ? 'Major Exam' : 
                          eventType === EVENT_TYPES.SMALL_QUIZ ? 'Small Quiz' : 'Event';
    
    if (!window.confirm(`Delete this ${eventTypeLabel}? This will also remove all linked study suggestions and reviews.`)) {
      return;
    }
    
    try {
      console.log('üóëÔ∏è Deleting event:', eventId);
      await calendarService.deleteEvent(eventId, true); // true = cascade delete
      console.log('‚úÖ Event deleted successfully');
      await loadCalendarData();
      setSelectedDate(null);
      alert('Event deleted successfully!');
    } catch (error) {
      console.error('‚ùå Error deleting event:', error);
      
      // More detailed error message
      let errorMsg = 'Failed to delete event. ';
      if (error.message.includes('permission')) {
        errorMsg += 'Please check that you have permission to delete this event.';
      } else if (error.message.includes('not found')) {
        errorMsg += 'Event not found. It may have already been deleted.';
      } else {
        errorMsg += error.message;
      }
      
      alert(errorMsg);
    }
  }

  // Render day cell content
  function renderDayCell(day) {
    if (!day) return null;
    
    const dateStr = getDateString(day);
    const events = getDayEvents(day);
    const isSelectedDate = selectedDate === dateStr;
    const isHovered = hoveredDate === dateStr;
    const isTodayDate = isToday(day);
    const isPastDate = isPast(day);
    
    const hasExam = events?.exams?.length > 0;
    const hasQuiz = events?.quizzes?.length > 0;
    const hasSuggestions = events?.suggestions?.length > 0;
    const hasRepetitions = events?.repetitions?.length > 0;
    const hasCompletions = events?.completions?.length > 0;
    const hasAIRecommendations = events?.aiRecommendations?.length > 0;
    
    const totalEvents = (events?.exams?.length || 0) + 
                       (events?.quizzes?.length || 0) + 
                       (events?.suggestions?.length || 0) + 
                       (events?.repetitions?.length || 0) +
                       (events?.aiRecommendations?.length || 0);

    return (
      <div className="flex flex-col h-full p-1">
        {/* Day number */}
        <div className={`text-sm font-bold mb-1 ${
          isTodayDate ? 'text-blue-600' : isPastDate ? 'text-slate-400' : 'text-slate-700'
        }`}>
          {day}
        </div>
        
        {/* Event markers */}
        <div className="flex-1 flex flex-col gap-0.5 overflow-hidden">
          {/* Major Exam */}
          {hasExam && events.exams.map((exam, idx) => (
            <div
              key={`exam-${idx}`}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-red-100 text-red-700 font-semibold hover:bg-red-200 transition-colors cursor-pointer group relative"
              onClick={(e) => {
                e.stopPropagation();
                setSelectedDate(dateStr);
              }}
            >
              <Flag size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">{exam.title}</span>
              {!exam.completed && (
                <button
                  onClick={(e) => handleDeleteEvent(exam.id, EVENT_TYPES.MAJOR_EXAM, e)}
                  className="opacity-0 group-hover:opacity-100 transition-opacity"
                >
                  <X size={10} />
                </button>
              )}
            </div>
          ))}
          
          {/* Small Quiz */}
          {hasQuiz && events.quizzes.map((quiz, idx) => (
            <div
              key={`quiz-${idx}`}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-amber-100 text-amber-700 font-semibold hover:bg-amber-200 transition-colors cursor-pointer group relative"
              onClick={(e) => {
                e.stopPropagation();
                setSelectedDate(dateStr);
              }}
            >
              <BookOpen size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">{quiz.title}</span>
              {!quiz.completed && (
                <button
                  onClick={(e) => handleDeleteEvent(quiz.id, EVENT_TYPES.SMALL_QUIZ, e)}
                  className="opacity-0 group-hover:opacity-100 transition-opacity"
                >
                  <X size={10} />
                </button>
              )}
            </div>
          ))}
          
          {/* Study Suggestions */}
          {hasSuggestions && events.suggestions.slice(0, 2).map((suggestion, idx) => (
            <button
              key={`suggestion-${idx}`}
              onClick={(e) => {
                e.stopPropagation();
                handleSuggestionPreview(suggestion, e);
              }}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-blue-100 text-blue-700 font-semibold hover:bg-blue-200 transition-colors group"
            >
              <CalendarIcon size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">{suggestion.questionCount} MCQs</span>
              {suggestion.completed && <CheckCircle size={10} className="text-blue-600" />}
            </button>
          ))}
          
          {/* UPDATED: Spaced Repetition */}
          {hasRepetitions && events.repetitions.slice(0, 1).map((rep, idx) => (
            <button
              key={`rep-${idx}`}
              onClick={(e) => {
                e.stopPropagation();
                handleSpacedRepetitionClick(rep, e);
              }}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-purple-100 text-purple-700 font-semibold hover:bg-purple-200 transition-colors"
            >
              <Brain size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">Review</span>
              {rep.completed && <CheckCircle size={10} className="text-purple-600" />}
            </button>
          ))}

          {/* AI Recommendations */}
          {hasAIRecommendations && events.aiRecommendations.slice(0, 1).map((aiRec, idx) => (
            <button
              key={`ai-${idx}`}
              onClick={(e) => {
                e.stopPropagation();
                handleAIRecommendationClick(aiRec);
              }}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-gradient-to-r from-purple-100 to-pink-100 text-purple-700 font-semibold hover:from-purple-200 hover:to-pink-200 transition-colors border border-purple-300"
            >
              <Sparkles size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">AI: {aiRec.questionCount} MCQs</span>
              {aiRec.completed && <CheckCircle size={10} className="text-purple-600" />}
            </button>
          ))}
          
          {/* Overflow indicator */}
          {totalEvents > 3 && (
            <button
              onClick={(e) => {
                e.stopPropagation();
                setSelectedDate(dateStr);
              }}
              className="text-xs text-slate-500 hover:text-slate-700 font-semibold px-1"
            >
              +{totalEvents - 3} more
            </button>
          )}
          
          {/* Completion dots */}
          {hasCompletions && events.completions.length <= 3 && (
            <div className="flex gap-0.5 mt-auto">
              {events.completions.slice(0, 3).map((comp, idx) => (
                <div
                  key={`comp-${idx}`}
                  className="w-1.5 h-1.5 rounded-full bg-green-500"
                  title={`Completed: ${comp.questionCount} questions`}
                />
              ))}
            </div>
          )}
          {hasCompletions && events.completions.length > 3 && (
            <div className="text-xs text-green-600 font-bold px-1">
              ‚úì {events.completions.length}
            </div>
          )}
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-2xl shadow-lg border-2 border-slate-100 p-6">
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center gap-3">
          <div className="w-12 h-12 rounded-xl bg-blue-100 flex items-center justify-center">
            <CalendarIcon className="text-blue-600" size={28} />
          </div>
          <div>
            <h3 className="text-xl font-black text-slate-800">Smart Study Calendar</h3>
            <p className="text-xs text-slate-500 mt-1">{monthName}</p>
          </div>
        </div>
        
        <div className="flex items-center gap-2">
          <button
            onClick={prevMonth}
            className="p-2 hover:bg-slate-100 rounded-lg transition-all"
          >
            <ChevronLeft size={20} className="text-slate-600" />
          </button>
          <button
            onClick={nextMonth}
            className="p-2 hover:bg-slate-100 rounded-lg transition-all"
          >
            <ChevronRight size={20} className="text-slate-600" />
          </button>
          <button
            onClick={onAddEvent}
            className="ml-2 px-4 py-2 bg-indigo-600 text-white rounded-lg font-bold hover:bg-indigo-700 transition-all flex items-center gap-2"
          >
            <Plus size={16} />
            Add Event
          </button>
        </div>
      </div>

      {/* AI Recommendations Panel */}
      {aiRecommendations.length > 0 && (
        <div className="mb-6 p-4 rounded-xl bg-gradient-to-r from-purple-50 to-pink-50 border-2 border-purple-200">
          <div className="flex items-center gap-2 mb-3">
            <Sparkles className="text-purple-600" size={24} />
            <h4 className="text-lg font-black text-purple-900">AI Study Recommendations</h4>
            <span className="ml-auto text-xs font-bold text-purple-600 bg-white px-2 py-1 rounded-full">
              {aiRecommendations.length} suggestions
            </span>
          </div>
          
          <div className="space-y-2">
            {aiRecommendations.slice(0, 3).map((rec) => (
              <div
                key={rec.id}
                className="bg-white rounded-lg p-3 border border-purple-200"
              >
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <div className="flex items-center gap-2 mb-1">
                      <span className={`px-2 py-0.5 rounded text-xs font-bold ${
                        rec.priority === 'HIGH' ? 'bg-red-100 text-red-700' :
                        rec.priority === 'MEDIUM' ? 'bg-amber-100 text-amber-700' :
                        'bg-blue-100 text-blue-700'
                      }`}>
                        {rec.priority}
                      </span>
                      <span className="font-bold text-sm text-slate-800">
                        {rec.subtopic}
                      </span>
                    </div>
                    <p className="text-xs text-slate-600">{rec.reason}</p>
                    <div className="flex gap-2 mt-2 text-xs text-slate-500">
                      <span>üìÖ Suggested: {new Date(rec.suggestedDate).toLocaleDateString()}</span>
                      <span>‚Ä¢</span>
                      <span>üìä Current: {rec.currentAccuracy}%</span>
                    </div>
                  </div>
                  
                  <div className="flex gap-1 ml-3">
                    <button
                      onClick={(e) => handleAcceptRecommendation(rec, e)}
                      className="p-2 bg-purple-100 hover:bg-purple-200 rounded-lg transition-all"
                      title="Add to calendar"
                    >
                      <ThumbsUp size={16} className="text-purple-600" />
                    </button>
                    <button
                      onClick={(e) => handleDismissRecommendation(rec.id, e)}
                      className="p-2 bg-slate-100 hover:bg-slate-200 rounded-lg transition-all"
                      title="Dismiss"
                    >
                      <ThumbsDown size={16} className="text-slate-600" />
                    </button>
                  </div>
                </div>
              </div>
            ))}
          </div>
          
          {aiRecommendations.length > 3 && (
            <div className="text-center mt-3">
              <button
                className="text-sm font-bold text-purple-600 hover:text-purple-700"
                onClick={() => {/* Show all recommendations modal */}}
              >
                View all {aiRecommendations.length} recommendations ‚Üí
              </button>
            </div>
          )}
        </div>
      )}

      {/* Legend */}
      <div className="grid grid-cols-2 md:grid-cols-6 gap-2 mb-4 text-xs">
        <div className="flex items-center gap-1.5">
          <Flag size={12} className="text-red-600" />
          <span className="text-slate-600 font-semibold">Major Exam</span>
        </div>
        <div className="flex items-center gap-1.5">
          <BookOpen size={12} className="text-amber-600" />
          <span className="text-slate-600 font-semibold">Quiz</span>
        </div>
        <div className="flex items-center gap-1.5">
          <CalendarIcon size={12} className="text-blue-600" />
          <span className="text-slate-600 font-semibold">Study Plan</span>
        </div>
        <div className="flex items-center gap-1.5">
          <Brain size={12} className="text-purple-600" />
          <span className="text-slate-600 font-semibold">Review</span>
        </div>
        <div className="flex items-center gap-1.5">
          <Sparkles size={12} className="text-purple-600" />
          <span className="text-slate-600 font-semibold">AI Suggestion</span>
        </div>
        <div className="flex items-center gap-1.5">
          <div className="w-2 h-2 rounded-full bg-green-500" />
          <span className="text-slate-600 font-semibold">Completed</span>
        </div>
      </div>

      {/* Calendar Grid */}
      <div className="border-2 border-slate-200 rounded-lg overflow-hidden">
        {/* Day headers */}
        <div className="grid grid-cols-7 bg-slate-50 border-b-2 border-slate-200">
          {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day) => (
            <div
              key={day}
              className="p-2 text-center text-sm font-black text-slate-600 uppercase tracking-wider"
            >
              {day}
            </div>
          ))}
        </div>

        {/* Calendar body */}
        {calendarGrid.map((week, weekIdx) => (
          <div key={weekIdx} className="grid grid-cols-7 border-b border-slate-200 last:border-b-0">
            {week.map((day, dayIdx) => (
              <div
                key={dayIdx}
                onMouseEnter={() => day && setHoveredDate(getDateString(day))}
                onMouseLeave={() => setHoveredDate(null)}
                onClick={() => day && setSelectedDate(getDateString(day))}
                className={`min-h-[100px] border-r border-slate-200 last:border-r-0 transition-all cursor-pointer ${
                  day ? 'hover:bg-slate-50' : 'bg-slate-50/30'
                } ${
                  isToday(day) ? 'bg-blue-50 ring-2 ring-inset ring-blue-400' : ''
                } ${
                  isPast(day) ? 'opacity-60' : ''
                }`}
              >
                {renderDayCell(day)}
              </div>
            ))}
          </div>
        ))}
      </div>

      {/* Suggestion Preview Modal */}
      <AnimatePresence>
        {suggestionPreview && (
          <div 
            className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4"
            onClick={() => setSuggestionPreview(null)}
          >
            <motion.div
              initial={{ opacity: 0, scale: 0.95 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.95 }}
              onClick={(e) => e.stopPropagation()}
              className="bg-white rounded-2xl shadow-2xl max-w-lg w-full"
            >
              <div className="p-6 border-b flex justify-between items-center">
                <h3 className="text-lg font-black text-slate-800">Study Session Preview</h3>
                <button
                  onClick={() => setSuggestionPreview(null)}
                  className="p-2 hover:bg-slate-100 rounded-lg transition-all"
                >
                  <X size={20} />
                </button>
              </div>
              
              <div className="p-6 space-y-4">
                {/* Session Info */}
                <div className="p-4 rounded-lg bg-blue-50 border-2 border-blue-200">
                  <h4 className="font-bold text-blue-900 mb-2">{suggestionPreview.title}</h4>
                  <div className="space-y-1 text-sm text-blue-800">
                    <div className="flex items-center gap-2">
                      <CalendarIcon size={16} />
                      <span>Phase: <strong>{suggestionPreview.phase}</strong></span>
                    </div>
                    {suggestionPreview.topic && (
                      <div className="flex items-center gap-2">
                        <BookOpen size={16} />
                        <span>
                          <strong>{suggestionPreview.topic}</strong>
                          {suggestionPreview.subtopic && ` ‚Üí ${suggestionPreview.subtopic}`}
                        </span>
                      </div>
                    )}
                  </div>
                </div>

                {/* Questions Available */}
                <div className={`p-4 rounded-lg border-2 ${
                  suggestionPreview.questionInfo.count >= suggestionPreview.questionInfo.requested
                    ? 'bg-green-50 border-green-200'
                    : 'bg-amber-50 border-amber-200'
                }`}>
                  <div className="flex items-center gap-2 mb-2">
                    <Info size={18} className={
                      suggestionPreview.questionInfo.count >= suggestionPreview.questionInfo.requested
                        ? 'text-green-600'
                        : 'text-amber-600'
                    } />
                    <span className={`font-bold ${
                      suggestionPreview.questionInfo.count >= suggestionPreview.questionInfo.requested
                        ? 'text-green-900'
                        : 'text-amber-900'
                    }`}>
                      Questions Available
                    </span>
                  </div>
                  <p className={`text-sm ${
                    suggestionPreview.questionInfo.count >= suggestionPreview.questionInfo.requested
                      ? 'text-green-800'
                      : 'text-amber-800'
                  }`}>
                    <strong>{suggestionPreview.questionInfo.count}</strong> questions found
                    {suggestionPreview.questionInfo.count < suggestionPreview.questionInfo.requested && (
                      <span> (requested: {suggestionPreview.questionInfo.requested})</span>
                    )}
                  </p>
                  
                  {suggestionPreview.questionInfo.count === 0 && (
                    <p className="text-xs text-red-600 mt-2">
                      ‚ö†Ô∏è No questions available for this topic/subtopic combination.
                    </p>
                  )}
                </div>

                {/* Action Button */}
                <button
                  onClick={() => {
                    handleStudySuggestionClick(suggestionPreview);
                    setSuggestionPreview(null);
                  }}
                  disabled={suggestionPreview.questionInfo.count === 0}
                  className="w-full px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold transition-all flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <Play size={18} fill="currentColor" />
                  Start Practice ({Math.min(suggestionPreview.questionInfo.count, suggestionPreview.questionInfo.requested)} Questions)
                </button>
              </div>
            </motion.div>
          </div>
        )}
      </AnimatePresence>

      {/* Day Detail Modal */}
      <AnimatePresence>
        {selectedDate && (
          <div 
            className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4"
            onClick={() => setSelectedDate(null)}
          >
            <motion.div
              initial={{ opacity: 0, scale: 0.95 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.95 }}
              onClick={(e) => e.stopPropagation()}
              className="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] overflow-y-auto"
            >
              <div className="sticky top-0 bg-white border-b p-4 flex justify-between items-center">
                <h3 className="text-lg font-black text-slate-800">
                  {new Date(selectedDate).toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    month: 'long', 
                    day: 'numeric',
                    year: 'numeric'
                  })}
                </h3>
                <button
                  onClick={() => setSelectedDate(null)}
                  className="p-2 hover:bg-slate-100 rounded-lg transition-all"
                >
                  <X size={20} />
                </button>
              </div>
              
              <div className="p-6 space-y-4">
                {calendarData[selectedDate] ? (
                  <>
                    {/* UPDATED: Exams with event type delete */}
                    {calendarData[selectedDate].exams?.map((exam) => (
                      <div key={exam.id} className="p-4 rounded-lg bg-red-50 border-2 border-red-200">
                        <div className="flex items-center justify-between mb-2">
                          <div className="flex items-center gap-2">
                            <Flag className="text-red-600" size={20} />
                            <span className="font-bold text-red-900">{exam.title}</span>
                          </div>
                          {!exam.completed && (
                            <button
                              onClick={(e) => handleDeleteEvent(exam.id, EVENT_TYPES.MAJOR_EXAM, e)}
                              className="p-2 hover:bg-red-100 rounded-lg transition-all"
                              title="Delete exam and study plan"
                            >
                              <Trash2 size={16} className="text-red-600" />
                            </button>
                          )}
                        </div>
                        {exam.topic && (
                          <div className="text-sm text-red-700">
                            üìö Topic: {exam.topic}
                            {exam.subtopic && ` ‚Üí ${exam.subtopic}`}
                          </div>
                        )}
                      </div>
                    ))}
                    
                    {/* UPDATED: Quizzes with event type delete */}
                    {calendarData[selectedDate].quizzes?.map((quiz) => (
                      <div key={quiz.id} className="p-4 rounded-lg bg-amber-50 border-2 border-amber-200">
                        <div className="flex items-center justify-between mb-2">
                          <div className="flex items-center gap-2">
                            <BookOpen className="text-amber-600" size={20} />
                            <span className="font-bold text-amber-900">{quiz.title}</span>
                          </div>
                          {!quiz.completed && (
                            <button
                              onClick={(e) => handleDeleteEvent(quiz.id, EVENT_TYPES.SMALL_QUIZ, e)}
                              className="p-2 hover:bg-amber-100 rounded-lg transition-all"
                              title="Delete quiz and study plan"
                            >
                              <Trash2 size={16} className="text-amber-600" />
                            </button>
                          )}
                        </div>
                        {quiz.topic && (
                          <div className="text-sm text-amber-700">
                            üìö Topic: {quiz.topic}
                            {quiz.subtopic && ` ‚Üí ${quiz.subtopic}`}
                          </div>
                        )}
                      </div>
                    ))}
                    
                    {/* Study Suggestions */}
                    {calendarData[selectedDate].suggestions?.map((suggestion) => {
                      const questionInfo = getAvailableQuestions(suggestion);
                      return (
                        <div
                          key={suggestion.id}
                          className="p-4 rounded-lg bg-blue-50 border-2 border-blue-200"
                        >
                          <div className="flex items-center gap-2 mb-2">
                            <CalendarIcon className="text-blue-600" size={20} />
                            <span className="font-bold text-blue-900">{suggestion.title}</span>
                            {suggestion.completed && <CheckCircle size={16} className="text-blue-600 ml-auto" />}
                          </div>
                          <div className="text-sm text-blue-700 mb-3 space-y-1">
                            <div>üìù {suggestion.questionCount} questions ‚Ä¢ Phase: {suggestion.phase}</div>
                            {suggestion.topic && (
                              <div>üìö {suggestion.topic}{suggestion.subtopic && ` ‚Üí ${suggestion.subtopic}`}</div>
                            )}
                            <div className={questionInfo.count >= questionInfo.requested ? 'text-green-600' : 'text-amber-600'}>
                              ‚úì {questionInfo.count} questions available
                            </div>
                          </div>
                          {!suggestion.completed && (
                            <button
                              onClick={() => {
                                handleStudySuggestionClick(suggestion);
                                setSelectedDate(null);
                              }}
                              disabled={questionInfo.count === 0}
                              className="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-bold transition-all flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                              <Play size={16} fill="currentColor" />
                              Start Practice
                            </button>
                          )}
                        </div>
                      );
                    })}
                    
                    {/* UPDATED: Spaced Repetitions */}
                    {calendarData[selectedDate].repetitions?.map((rep) => (
                      <button
                        key={rep.id}
                        onClick={(e) => {
                          handleSpacedRepetitionClick(rep, e);
                          setSelectedDate(null);
                        }}
                        className="w-full p-4 rounded-lg bg-purple-50 border-2 border-purple-200 hover:bg-purple-100 transition-all text-left"
                      >
                        <div className="flex items-center gap-2 mb-2">
                          <Brain className="text-purple-600" size={20} />
                          <span className="font-bold text-purple-900">{rep.title}</span>
                          {rep.completed && <CheckCircle size={16} className="text-purple-600 ml-auto" />}
                        </div>
                        <div className="text-sm text-purple-700">
                          Review interval: {rep.interval} days ‚Ä¢ Attempt #{rep.attemptCount}
                        </div>
                      </button>
                    ))}

                    {/* AI Recommendations */}
                    {calendarData[selectedDate].aiRecommendations?.map((aiRec) => (
                      <div
                        key={aiRec.id}
                        className="p-4 rounded-lg bg-gradient-to-r from-purple-50 to-pink-50 border-2 border-purple-200"
                      >
                        <div className="flex items-center gap-2 mb-2">
                          <Sparkles className="text-purple-600" size={20} />
                          <span className="font-bold text-purple-900">{aiRec.title}</span>
                        </div>
                        <div className="text-sm text-purple-700 mb-3">
                          {aiRec.description}
                        </div>
                        <div className="flex gap-2">
                          <button
                            onClick={() => {
                              handleAIRecommendationClick(aiRec);
                              setSelectedDate(null);
                            }}
                            className="flex-1 px-3 py-2 bg-purple-600 text-white rounded-lg font-bold hover:bg-purple-700 transition-all flex items-center justify-center gap-2"
                          >
                            <Play size={16} fill="currentColor" />
                            Start Practice
                          </button>
                        </div>
                      </div>
                    ))}
                    
                    {/* Completions */}
                    {calendarData[selectedDate].completions?.length > 0 && (
                      <div className="p-4 rounded-lg bg-green-50 border-2 border-green-200">
                        <div className="flex items-center gap-2 mb-2">
                          <CheckCircle className="text-green-600" size={20} />
                          <span className="font-bold text-green-900">
                            {calendarData[selectedDate].completions.length} Session(s) Completed
                          </span>
                        </div>
                        <div className="space-y-1">
                          {calendarData[selectedDate].completions.map((comp, idx) => (
                            <div key={idx} className="text-sm text-green-700">
                              {comp.questionCount} questions ‚Ä¢ {Math.round(comp.accuracy * 100)}% accuracy
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </>
                ) : (
                  <div className="text-center py-8 text-slate-400">
                    No events scheduled for this day
                  </div>
                )}
              </div>
            </motion.div>
          </div>
        )}
      </AnimatePresence>

      {/* NEW: Spaced Repetition Review Modal */}
      {reviewModal && (
        <SpacedRepetitionModal
          repetition={reviewModal.repetition}
          allRepetitions={reviewModal.allRepetitions}
          questions={questions}
          onClose={() => setReviewModal(null)}
          onStartReview={handleStartReview}
        />
      )}
    </div>
  );
}
--- END_OF_FILE ---

--- FILE_PATH: src/components/dashboard/EventCreationModal.jsx ---
import React, { useState, useMemo } from 'react';
import { X, Flag, BookOpen, Calendar, Tag, Layers, CheckSquare, ArrowUpCircle } from 'lucide-react';
import { motion } from 'framer-motion';
import { calendarService } from '../../services/calendarService';

/**
 * EventCreationModal - ENHANCED VERSION v2
 * 
 * FEATURES:
 * ‚úÖ Default to "All" topics
 * ‚úÖ "Select up to" feature for bulk topic selection
 * ‚úÖ Auto-select ALL subtopics when topics are selected
 * ‚úÖ Improved side-by-side layout for topics/subtopics
 * ‚úÖ DD/MM/YYYY date format
 */
export default function EventCreationModal({ userId, questions = [], onClose, onEventCreated }) {
  const [eventType, setEventType] = useState('major_exam');
  const [title, setTitle] = useState('');
  const [dateInput, setDateInput] = useState('');
  const [selectAllTopics, setSelectAllTopics] = useState(true);
  const [selectedTopics, setSelectedTopics] = useState([]);
  const [selectedSubtopics, setSelectedSubtopics] = useState([]);
  const [loading, setLoading] = useState(false);

  // Extract unique topics from questions (sorted)
  const allTopics = useMemo(() => {
    const topicSet = new Set(questions.map(q => q.Topic).filter(Boolean));
    return Array.from(topicSet).sort();
  }, [questions]);

  // Extract subtopics based on selected topics
  const availableSubtopics = useMemo(() => {
    if (selectAllTopics) {
      // If "All" is selected, show all subtopics
      const subtopicSet = new Set(
        questions
          .filter(q => q.Subtopic)
          .map(q => q.Subtopic)
      );
      return Array.from(subtopicSet).sort();
    }
    
    if (selectedTopics.length === 0) return [];
    
    const subtopicSet = new Set(
      questions
        .filter(q => selectedTopics.includes(q.Topic) && q.Subtopic)
        .map(q => q.Subtopic)
    );
    return Array.from(subtopicSet).sort();
  }, [questions, selectedTopics, selectAllTopics]);

  // Auto-select ALL subtopics when topics change or "All" is toggled
  React.useEffect(() => {
    // Always auto-select all available subtopics
    setSelectedSubtopics(availableSubtopics);
  }, [availableSubtopics]);

  // Convert DD/MM/YYYY to YYYY-MM-DD
  function parseDate(ddmmyyyy) {
    if (!ddmmyyyy) return null;
    const parts = ddmmyyyy.split('/');
    if (parts.length !== 3) return null;
    
    const [day, month, year] = parts;
    const d = parseInt(day);
    const m = parseInt(month);
    const y = parseInt(year);
    
    if (d < 1 || d > 31 || m < 1 || m > 12 || y < 2000 || y > 2100) {
      return null;
    }
    
    return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
  }

  // Handle date input with auto-formatting
  function handleDateInput(value) {
    const digits = value.replace(/\D/g, '');
    
    let formatted = '';
    if (digits.length > 0) {
      formatted = digits.substring(0, 2);
      if (digits.length >= 3) {
        formatted += '/' + digits.substring(2, 4);
      }
      if (digits.length >= 5) {
        formatted += '/' + digits.substring(4, 8);
      }
    }
    
    setDateInput(formatted);
  }

  // Toggle "Select All" topics
  function toggleSelectAll() {
    setSelectAllTopics(!selectAllTopics);
    if (!selectAllTopics) {
      setSelectedTopics([]); // Clear individual selections when "All" is enabled
    }
  }

  // Toggle individual topic
  function toggleTopic(topic) {
    if (selectAllTopics) {
      // If switching from "All", disable "All" first
      setSelectAllTopics(false);
      setSelectedTopics([topic]);
    } else {
      setSelectedTopics(prev => 
        prev.includes(topic) 
          ? prev.filter(t => t !== topic)
          : [...prev, topic]
      );
    }
  }

  // Select topics "up to" a certain number
  function selectUpTo(targetTopic) {
    setSelectAllTopics(false);
    const targetIndex = allTopics.indexOf(targetTopic);
    if (targetIndex === -1) return;
    
    // Select from first topic up to target topic (inclusive)
    const topicsToSelect = allTopics.slice(0, targetIndex + 1);
    setSelectedTopics(topicsToSelect);
  }

  // Toggle subtopic (manual override)
  function toggleSubtopic(subtopic) {
    setSelectedSubtopics(prev => 
      prev.includes(subtopic)
        ? prev.filter(s => s !== subtopic)
        : [...prev, subtopic]
    );
  }

  // Select subtopics up to target
  function selectSubtopicsUpTo(targetSubtopic) {
    const targetIndex = availableSubtopics.indexOf(targetSubtopic);
    if (targetIndex === -1) return;
    setSelectedSubtopics(availableSubtopics.slice(0, targetIndex + 1));
  }

  // Generate title if not provided
  function generateTitle() {
    if (title.trim()) return title.trim();
    
    let generatedTitle = '';
    
    if (eventType === 'major_exam') {
      if (selectAllTopics) {
        generatedTitle = 'Comprehensive Exam';
      } else if (selectedTopics.length > 0) {
        generatedTitle = `${selectedTopics.slice(0, 2).join(', ')}${selectedTopics.length > 2 ? '...' : ''} Exam`;
      } else {
        generatedTitle = 'Major Exam';
      }
    } else {
      if (selectAllTopics) {
        generatedTitle = 'Comprehensive Quiz';
      } else if (selectedTopics.length > 0) {
        generatedTitle = `${selectedTopics.slice(0, 2).join(', ')}${selectedTopics.length > 2 ? '...' : ''} Quiz`;
      } else {
        generatedTitle = 'Quiz';
      }
    }
    
    return generatedTitle;
  }

  async function handleSubmit(e) {
    e.preventDefault();
    
    const parsedDate = parseDate(dateInput);
    
    if (!parsedDate) {
      alert('Please enter a valid date in DD/MM/YYYY format (e.g., 25/12/2024)');
      return;
    }

    // Check if date is in the past
    const selectedDate = new Date(parsedDate);
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    if (selectedDate < today) {
      const proceed = window.confirm('Warning: This date is in the past. Continue anyway?');
      if (!proceed) return;
    }

    setLoading(true);
    
    try {
      const eventData = {
        date: parsedDate,
        title: generateTitle(),
        // If "All" is selected, pass null to indicate all topics
        topics: selectAllTopics ? null : (selectedTopics.length > 0 ? selectedTopics : null),
        subtopics: selectedSubtopics.length > 0 ? selectedSubtopics : null
      };

      console.log('üìù Creating event:', eventData);

      if (eventType === 'major_exam') {
        await calendarService.addMajorExam(userId, eventData);
      } else {
        await calendarService.addSmallQuiz(userId, eventData);
      }

      onEventCreated();
      onClose();
    } catch (error) {
      console.error('Error creating event:', error);
      alert('Failed to create event: ' + error.message);
    } finally {
      setLoading(false);
    }
  }

  return (
    <div 
      className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4"
      onClick={onClose}
    >
      <motion.div
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        onClick={(e) => e.stopPropagation()}
        className="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-y-auto"
      >
        {/* Header */}
        <div className="border-b p-6 flex justify-between items-center sticky top-0 bg-white z-10 rounded-t-2xl">
          <div>
            <h2 className="text-2xl font-black text-slate-800">Add Event</h2>
            <p className="text-sm text-slate-500 mt-1">Schedule an exam or quiz and get a smart study plan</p>
          </div>
          <button
            onClick={onClose}
            className="p-2 hover:bg-slate-100 rounded-lg transition-all"
          >
            <X size={24} />
          </button>
        </div>

        {/* Form */}
        <form onSubmit={handleSubmit} className="p-6 space-y-6">
          {/* Event Type Selector */}
          <div>
            <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-3">
              Event Type
            </label>
            <div className="grid grid-cols-2 gap-3">
              <button
                type="button"
                onClick={() => setEventType('major_exam')}
                className={`p-4 rounded-xl border-2 transition-all ${
                  eventType === 'major_exam'
                    ? 'border-red-500 bg-red-50 shadow-lg'
                    : 'border-slate-200 hover:border-slate-300'
                }`}
              >
                <div className="flex items-center gap-3 mb-2">
                  <Flag className={eventType === 'major_exam' ? 'text-red-600' : 'text-slate-400'} size={20} />
                  <span className={`font-bold ${
                    eventType === 'major_exam' ? 'text-red-900' : 'text-slate-600'
                  }`}>
                    Major Exam
                  </span>
                </div>
                <div className="text-xs text-slate-500 text-left">
                  10-day study plan with scaled intensity
                </div>
              </button>

              <button
                type="button"
                onClick={() => setEventType('small_quiz')}
                className={`p-4 rounded-xl border-2 transition-all ${
                  eventType === 'small_quiz'
                    ? 'border-amber-500 bg-amber-50 shadow-lg'
                    : 'border-slate-200 hover:border-slate-300'
                }`}
              >
                <div className="flex items-center gap-3 mb-2">
                  <BookOpen className={eventType === 'small_quiz' ? 'text-amber-600' : 'text-slate-400'} size={20} />
                  <span className={`font-bold ${
                    eventType === 'small_quiz' ? 'text-amber-900' : 'text-slate-600'
                  }`}>
                    Small Quiz
                  </span>
                </div>
                <div className="text-xs text-slate-500 text-left">
                  3-day focused review plan
                </div>
              </button>
            </div>
          </div>

          {/* Date Input */}
          <div>
            <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-2">
              Exam/Quiz Date <span className="text-red-500">*</span>
            </label>
            <input
              type="text"
              value={dateInput}
              onChange={(e) => handleDateInput(e.target.value)}
              placeholder="DD/MM/YYYY (e.g., 25/12/2024)"
              maxLength={10}
              className="w-full px-4 py-3 rounded-lg border-2 border-slate-200 focus:border-indigo-500 focus:outline-none transition-all font-medium text-lg"
              required
            />
            <p className="text-xs text-slate-500 mt-1">
              üìÖ Enter date as DD/MM/YYYY (e.g., 31/12/2024)
            </p>
          </div>

          {/* Topics & Subtopics - IMPROVED: Side-by-side layout */}
          <div>
            <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-3">
              Topics & Subtopics
            </label>

            {/* "Select All" Toggle */}
            <button
              type="button"
              onClick={toggleSelectAll}
              className={`w-full mb-4 px-4 py-3 rounded-lg border-2 transition-all flex items-center gap-2 font-bold ${
                selectAllTopics
                  ? 'bg-indigo-100 border-indigo-500 text-indigo-900 shadow-lg'
                  : 'bg-slate-50 border-slate-200 hover:bg-slate-100'
              }`}
            >
              <CheckSquare size={18} className={selectAllTopics ? 'text-indigo-600' : 'text-slate-400'} />
              <span>All Topics ({allTopics.length} topics)</span>
              {selectAllTopics && <span className="ml-auto text-xs bg-white px-2 py-1 rounded font-bold">‚úì Selected</span>}
            </button>

            {/* Side-by-side Topics and Subtopics */}
            {!selectAllTopics && (
              <div className="grid grid-cols-2 gap-4">
                {/* Topics Column */}
                <div>
                  <label className="block text-xs font-black text-slate-600 mb-2 flex items-center gap-1">
                    <Tag size={12} />
                    Topics ({selectedTopics.length}/{allTopics.length})
                  </label>
                  <div className="border-2 border-slate-200 rounded-lg p-3 h-72 overflow-y-auto bg-white">
                    {allTopics.length === 0 ? (
                      <p className="text-sm text-slate-400 text-center py-4">No topics available</p>
                    ) : (
                      <div className="space-y-2">
                        {allTopics.map((topic) => (
                          <div key={topic} className="flex items-center gap-2">
                            <button
                              type="button"
                              onClick={() => toggleTopic(topic)}
                              className={`flex-1 px-3 py-2 rounded-lg text-left transition-all flex items-center gap-2 ${
                                selectedTopics.includes(topic)
                                  ? 'bg-indigo-100 border-2 border-indigo-500 text-indigo-900'
                                  : 'bg-slate-50 border-2 border-transparent hover:bg-slate-100'
                              }`}
                            >
                              <div className={`w-4 h-4 rounded border-2 flex items-center justify-center ${
                                selectedTopics.includes(topic)
                                  ? 'border-indigo-600 bg-indigo-600'
                                  : 'border-slate-300'
                              }`}>
                                {selectedTopics.includes(topic) && (
                                  <svg className="w-3 h-3 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
                                  </svg>
                                )}
                              </div>
                              <span className="font-semibold text-sm">{topic}</span>
                            </button>

                            <button
                              type="button"
                              onClick={() => selectUpTo(topic)}
                              className="px-2 py-2 bg-purple-100 hover:bg-purple-200 rounded-lg transition-all flex items-center gap-1 text-xs font-bold text-purple-700"
                              title={`Select all topics up to ${topic}`}
                            >
                              <ArrowUpCircle size={14} />
                            </button>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                  <p className="text-xs text-slate-500 mt-2">
                    üí° {selectedTopics.length === 0 
                      ? 'Select topics or click "Up to" button' 
                      : `${selectedTopics.length} topic${selectedTopics.length > 1 ? 's' : ''} selected`}
                  </p>
                </div>

                {/* Subtopics Column */}
                <div>
                  <label className="block text-xs font-black text-slate-600 mb-2 flex items-center gap-1">
                    <Layers size={12} />
                    Subtopics ({selectedSubtopics.length}/{availableSubtopics.length})
                    <span className="ml-auto text-xs text-green-600 font-normal">‚úì Auto-selected</span>
                  </label>
                  <div className="border-2 border-slate-200 rounded-lg p-3 h-72 overflow-y-auto bg-white">
                    {availableSubtopics.length === 0 ? (
                      <p className="text-sm text-slate-400 text-center py-4">
                        {selectedTopics.length === 0 ? 'Select topics first' : 'No subtopics available'}
                      </p>
                    ) : (
                      <div className="space-y-2">
                        {availableSubtopics.map((subtopic) => (
                          <div key={subtopic} className="flex items-center gap-2">
                            <button
                              type="button"
                              onClick={() => toggleSubtopic(subtopic)}
                              className={`flex-1 px-3 py-2 rounded-lg text-left transition-all flex items-center gap-2 ${
                                selectedSubtopics.includes(subtopic)
                                  ? 'bg-purple-100 border-2 border-purple-500 text-purple-900'
                                  : 'bg-slate-50 border-2 border-transparent hover:bg-slate-100'
                              }`}
                            >
                              <div className={`w-4 h-4 rounded border-2 flex items-center justify-center ${
                                selectedSubtopics.includes(subtopic)
                                  ? 'border-purple-600 bg-purple-600'
                                  : 'border-slate-300'
                              }`}>
                                {selectedSubtopics.includes(subtopic) && (
                                  <svg className="w-3 h-3 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
                                  </svg>
                                )}
                              </div>
                              <span className="font-semibold text-sm">{subtopic}</span>
                            </button>

                            <button
                              type="button"
                              onClick={() => selectSubtopicsUpTo(subtopic)}
                              className="px-2 py-2 bg-purple-100 hover:bg-purple-200 rounded-lg transition-all flex items-center gap-1 text-xs font-bold text-purple-700"
                              title={`Select up to ${subtopic}`}
                            >
                              <ArrowUpCircle size={14} />
                            </button>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                  <p className="text-xs text-slate-500 mt-2">
                    üí° All subtopics auto-selected. Uncheck to customize.
                  </p>
                </div>
              </div>
            )}

            {/* Subtopics for "All Topics" mode */}
            {selectAllTopics && availableSubtopics.length > 0 && (
              <div className="mt-4">
                <label className="block text-xs font-black text-slate-600 mb-2 flex items-center gap-1">
                  <Layers size={12} />
                  All Subtopics ({selectedSubtopics.length}/{availableSubtopics.length})
                  <span className="ml-auto text-xs text-green-600 font-normal">‚úì Auto-selected</span>
                </label>
                <div className="border-2 border-slate-200 rounded-lg p-3 max-h-48 overflow-y-auto bg-white">
                  <div className="grid grid-cols-2 gap-2">
                    {availableSubtopics.map((subtopic) => (
                      <button
                        key={subtopic}
                        type="button"
                        onClick={() => toggleSubtopic(subtopic)}
                        className={`px-3 py-2 rounded-lg text-left transition-all flex items-center gap-2 ${
                          selectedSubtopics.includes(subtopic)
                            ? 'bg-purple-100 border-2 border-purple-500 text-purple-900'
                            : 'bg-slate-50 border-2 border-transparent hover:bg-slate-100'
                        }`}
                      >
                        <div className={`w-3.5 h-3.5 rounded border-2 flex items-center justify-center flex-shrink-0 ${
                          selectedSubtopics.includes(subtopic)
                            ? 'border-purple-600 bg-purple-600'
                            : 'border-slate-300'
                        }`}>
                          {selectedSubtopics.includes(subtopic) && (
                            <svg className="w-2.5 h-2.5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
                            </svg>
                          )}
                        </div>
                        <span className="font-semibold text-xs truncate">{subtopic}</span>
                      </button>
                    ))}
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* Custom Title */}
          <div>
            <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-2">
              Custom Title <span className="text-slate-400 text-xs font-normal">(Optional - auto-generated)</span>
            </label>
            <input
              type="text"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder={`Auto: ${generateTitle()}`}
              className="w-full px-4 py-3 rounded-lg border-2 border-slate-200 focus:border-indigo-500 focus:outline-none transition-all font-medium"
            />
          </div>

          {/* Study Plan Preview */}
          <div className={`p-4 rounded-xl border-2 ${
            eventType === 'major_exam' 
              ? 'bg-red-50 border-red-200' 
              : 'bg-amber-50 border-amber-200'
          }`}>
            <div className="flex items-center gap-2 mb-3">
              <Calendar className={eventType === 'major_exam' ? 'text-red-600' : 'text-amber-600'} size={18} />
              <span className={`font-bold text-sm ${
                eventType === 'major_exam' ? 'text-red-900' : 'text-amber-900'
              }`}>
                Auto-Generated Study Plan
              </span>
            </div>
            {eventType === 'major_exam' ? (
              <ul className="space-y-1 text-xs text-red-700">
                <li>‚Ä¢ <strong>10-7 days before:</strong> 10 MCQs/day (Warm-up)</li>
                <li>‚Ä¢ <strong>6-4 days before:</strong> 20 MCQs/day (Consolidation)</li>
                <li>‚Ä¢ <strong>3-1 days before:</strong> 40 MCQs/day (Sprint Intensity)</li>
              </ul>
            ) : (
              <ul className="space-y-1 text-xs text-amber-700">
                <li>‚Ä¢ <strong>3 days before:</strong> 5 MCQs (Initial Review)</li>
                <li>‚Ä¢ <strong>2 days before:</strong> 10 MCQs (Topic Focus)</li>
                <li>‚Ä¢ <strong>1 day before:</strong> 15 MCQs + Mistake Review (Final Polish)</li>
              </ul>
            )}
            <p className="text-xs font-bold mt-2 text-slate-700">
              üìö Focus: {
                selectAllTopics ? 'All Topics' :
                selectedTopics.length > 0 ? selectedTopics.join(', ') : 'General Review'
              }
              {selectedSubtopics.length > 0 && selectedSubtopics.length < availableSubtopics.length && 
                ` (${selectedSubtopics.length} subtopics)`}
            </p>
          </div>

          {/* Submit Buttons */}
          <div className="flex gap-3 pt-4 border-t">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 px-6 py-3 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-xl font-bold transition-all"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={loading}
              className={`flex-1 px-6 py-3 rounded-xl font-bold transition-all text-white ${
                eventType === 'major_exam'
                  ? 'bg-red-600 hover:bg-red-700'
                  : 'bg-amber-600 hover:bg-amber-700'
              } disabled:opacity-50 disabled:cursor-not-allowed shadow-lg`}
            >
              {loading ? 'Creating...' : `Create Event & Study Plan`}
            </button>
          </div>
        </form>
      </motion.div>
    </div>
  );
}
--- END_OF_FILE ---

--- FILE_PATH: src/components/QuizEngine.jsx ---
import React, { useState, useEffect, useRef } from 'react';
import QuestionCard from './QuestionCard';
import { ChevronLeft, ChevronRight, Send, Timer, FlaskConical, Flag, Clock, X } from 'lucide-react';
import { calendarService } from '../services/calendarService';
import { useAuth } from '../context/AuthContext';

export default function QuizEngine({ questions, onComplete }) {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [answers, setAnswers] = useState({});
  const [flagged, setFlagged] = useState(new Set());
  const [showPeriodicTable, setShowPeriodicTable] = useState(false);
  const [showQuestionPanel, setShowQuestionPanel] = useState(false);
  const [timerEnabled, setTimerEnabled] = useState(null);
  const [questionTimes, setQuestionTimes] = useState({});
  const [currentQuestionStartTime, setCurrentQuestionStartTime] = useState(null);
  const [currentTime, setCurrentTime] = useState(Date.now());
  const [sessionStartTime, setSessionStartTime] = useState(null);
  const timerInitialized = useRef(false);
  
  const { currentUser } = useAuth();
  const currentQuestion = questions[currentIndex];
  const totalQuestions = questions.length;
  const progress = ((currentIndex + 1) / totalQuestions) * 100;

  // Timer initialization prompt - only once
  useEffect(() => {
    if (timerEnabled === null && !timerInitialized.current) {
      timerInitialized.current = true;
      const enableTimer = window.confirm(
        "Do you want to enable the timer?\n\n" +
        "The timer will track how long you spend on each question.\n\n" +
        "Click OK to enable, Cancel to skip."
      );
      setTimerEnabled(enableTimer);
      if (enableTimer) {
        const now = Date.now();
        setCurrentQuestionStartTime(now);
        setSessionStartTime(now);
      }
    }
  }, [timerEnabled]);

  // Live timer update - updates every second
  useEffect(() => {
    if (!timerEnabled) return;
    
    const interval = setInterval(() => {
      setCurrentTime(Date.now());
    }, 1000);

    return () => clearInterval(interval);
  }, [timerEnabled]);

  // Start timer when changing questions
  useEffect(() => {
    if (timerEnabled && currentQuestion) {
      setCurrentQuestionStartTime(Date.now());
    }
  }, [currentIndex, timerEnabled]);

  // Record time when leaving a question
  const recordQuestionTime = () => {
    if (timerEnabled && currentQuestionStartTime) {
      const timeSpent = Date.now() - currentQuestionStartTime;
      setQuestionTimes(prev => ({
        ...prev,
        [currentQuestion.ID]: (prev[currentQuestion.ID] || 0) + timeSpent
      }));
    }
  };

  /**
   * Handle quiz completion with calendar AND performance tracking integration
   */
  async function handleQuizComplete(finalAnswers, finalQuestionTimes) {
    try {
      const quizMode = localStorage.getItem('quiz_mode');
      const eventId = localStorage.getItem('quiz_event_id');
      
      if (currentUser?.uid) {
        const correctCount = Object.entries(finalAnswers).filter(([qId, answer]) => {
          const question = questions.find(q => q.ID === qId);
          return question && answer === question.CorrectOption;
        }).length;

        // Log completion WITH performance tracking
        await calendarService.logCompletion(
          currentUser.uid, 
          new Date().toISOString(), 
          {
            type: quizMode || 'practice',
            topic: questions[0]?.Topic || 'Mixed',
            questionCount: questions.length,
            correctCount
          },
          questions,  // Pass questions for performance analysis
          finalAnswers  // Pass answers for performance analysis
        );

        // Mark linked event as completed if exists
        if (eventId && (quizMode === 'study-plan' || quizMode === 'spaced-repetition' || quizMode === 'ai-recommendation')) {
          await calendarService.markEventCompleted(eventId);
        }
      }

      // Clear event tracking
      localStorage.removeItem('quiz_event_id');
      localStorage.removeItem('quiz_mode');
      
      // Call original completion handler
      onComplete(finalAnswers, timerEnabled ? finalQuestionTimes : null);
    } catch (error) {
      console.error('Error handling quiz completion:', error);
      // Still complete the quiz even if logging fails
      onComplete(finalAnswers, timerEnabled ? finalQuestionTimes : null);
    }
  }

  const handleOptionSelect = (option) => {
    setAnswers({
      ...answers,
      [currentQuestion.ID]: option
    });
  };

  const toggleFlag = () => {
    const questionId = currentQuestion.ID;
    setFlagged(prev => {
      const newSet = new Set(prev);
      if (newSet.has(questionId)) {
        newSet.delete(questionId);
      } else {
        newSet.add(questionId);
      }
      return newSet;
    });
  };

  const nextQuestion = () => {
    recordQuestionTime();
    if (currentIndex < totalQuestions - 1) {
      setCurrentIndex(currentIndex + 1);
    }
  };

  const prevQuestion = () => {
    recordQuestionTime();
    if (currentIndex > 0) {
      setCurrentIndex(currentIndex - 1);
    }
  };

  const jumpToQuestion = (index) => {
    recordQuestionTime();
    setCurrentIndex(index);
    setShowQuestionPanel(false);
  };

  const isLastQuestion = currentIndex === totalQuestions - 1;
  const allAnswered = Object.keys(answers).length === totalQuestions;

  // Calculate total time spent (accumulated + current question time)
  const getTotalTimeSpent = () => {
    const accumulated = Object.values(questionTimes).reduce((sum, time) => sum + time, 0);
    if (timerEnabled && currentQuestionStartTime) {
      const currentQuestionTime = currentTime - currentQuestionStartTime;
      return accumulated + currentQuestionTime;
    }
    return accumulated;
  };

  // Calculate session time
  const getSessionTime = () => {
    if (timerEnabled && sessionStartTime) {
      return currentTime - sessionStartTime;
    }
    return 0;
  };

  const formatTime = (ms) => {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hrs = Math.floor(minutes / 60);
    if (hrs > 0) {
      return `${hrs}:${String(minutes % 60).padStart(2, '0')}:${String(seconds % 60).padStart(2, '0')}`;
    }
    return `${minutes}:${String(seconds % 60).padStart(2, '0')}`;
  };

  // Get question status
  const getQuestionStatus = (q) => {
    if (answers[q.ID]) return 'answered';
    if (flagged.has(q.ID)) return 'flagged';
    return 'skipped';
  };

  if (timerEnabled === null) {
    return (
      <div className="flex h-screen items-center justify-center">
        <div className="text-center">
          <Clock className="animate-pulse text-lab-blue w-12 h-12 mx-auto mb-4" />
          <p className="text-slate-600">Initializing quiz...</p>
        </div>
      </div>
    );
  }

  const totalTimeSpent = getTotalTimeSpent();
  const sessionTime = getSessionTime();

  return (
    <div className="relative h-screen overflow-hidden">
      {/* Fixed Left Sidebar */}
      <div className="fixed left-8 top-32 flex flex-col gap-4 z-30 h-[calc(100vh-10rem)]">
        {/* Timer Display */}
        {timerEnabled && (
          <div className="bg-white rounded-2xl shadow-xl border-2 border-lab-blue p-6 w-48">
            <div className="text-center">
              <div className="flex items-center justify-center gap-2 mb-2">
                <Timer className="text-lab-blue" size={24} />
                <span className="text-sm font-bold text-slate-600">SESSION TIME</span>
              </div>
              <div className="text-4xl font-black text-lab-blue mb-4 font-mono">
                {formatTime(sessionTime)}
              </div>
              <div className="text-xs text-slate-500 border-t pt-2">
                <div className="flex justify-between mb-1">
                  <span>Active Time:</span>
                  <span className="font-bold">{formatTime(totalTimeSpent)}</span>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Periodic Table Button */}
        <button
          onClick={() => setShowPeriodicTable(true)}
          className="flex items-center gap-2 px-6 py-4 bg-purple-600 text-white rounded-xl font-bold hover:bg-purple-700 transition-all shadow-lg hover:scale-105 active:scale-95"
        >
          <FlaskConical size={20} />
          <span>Periodic Table</span>
        </button>

        {/* Question Panel Button */}
        <button
          onClick={() => setShowQuestionPanel(!showQuestionPanel)}
          className="flex items-center gap-2 px-6 py-4 bg-slate-700 text-white rounded-xl font-bold hover:bg-slate-800 transition-all shadow-lg hover:scale-105 active:scale-95"
        >
          <Flag size={20} />
          <span>Overview</span>
        </button>

        {/* Spacer to push button to bottom */}
        <div className="flex-1"></div>

        {/* Previous Button - Left Side - Aligned to bottom */}
        <button
          onClick={prevQuestion}
          disabled={currentIndex === 0}
          className="flex items-center justify-center w-16 h-16 bg-lab-blue text-white rounded-full font-bold hover:bg-blue-800 disabled:bg-slate-300 disabled:cursor-not-allowed transition-all shadow-lg hover:scale-110 active:scale-95"
        >
          <ChevronLeft size={32} />
        </button>
      </div>

      {/* Fixed Right Sidebar */}
      <div className="fixed right-8 top-32 flex flex-col gap-4 z-30 h-[calc(100vh-10rem)]">
        {/* Flag Button */}
        <button
          onClick={toggleFlag}
          className={`w-16 h-16 rounded-full flex items-center justify-center transition-all shadow-lg hover:scale-110 active:scale-95 ${
            flagged.has(currentQuestion?.ID)
              ? 'bg-amber-500 text-white hover:bg-amber-600'
              : 'bg-white text-amber-500 border-2 border-amber-500 hover:bg-amber-50'
          }`}
          title={flagged.has(currentQuestion?.ID) ? 'Unflag Question' : 'Flag Question'}
        >
          <Flag size={28} fill={flagged.has(currentQuestion?.ID) ? 'currentColor' : 'none'} />
        </button>

        {/* Spacer to push button to bottom */}
        <div className="flex-1"></div>

        {/* Next/Submit Button - Right Side - Aligned to bottom */}
        {!isLastQuestion ? (
          <button
            onClick={nextQuestion}
            className="flex items-center justify-center w-16 h-16 bg-lab-blue text-white rounded-full font-bold hover:bg-blue-800 transition-all shadow-lg hover:scale-110 active:scale-95"
          >
            <ChevronRight size={32} />
          </button>
        ) : (
          <button
            onClick={() => {
              recordQuestionTime();
              handleQuizComplete(answers, timerEnabled ? questionTimes : null);
            }}
            className={`flex items-center justify-center w-16 h-16 rounded-full font-bold transition-all shadow-lg hover:scale-110 active:scale-95 ${
              allAnswered 
                ? 'bg-chemistry-green text-white hover:opacity-90' 
                : 'bg-slate-300 text-slate-500 cursor-not-allowed'
            }`}
            title="Finish & Submit"
          >
            <Send size={28} />
          </button>
        )}
      </div>

      {/* Question Overview Panel - Floating Left Sidebar */}
      {showQuestionPanel && (
        <>
          {/* Backdrop - semi-transparent to see content behind */}
          <div 
            className="fixed inset-0 z-40"
            style={{ backgroundColor: 'rgba(0, 0, 0, 0.15)' }}
            onClick={() => setShowQuestionPanel(false)}
          />
          
          {/* Panel - narrower sidebar on the left */}
          <div className="fixed left-0 top-0 h-full w-80 bg-white shadow-2xl z-50 overflow-y-auto animate-in slide-in-from-left duration-300">
            <div className="sticky top-0 bg-white border-b p-6 flex justify-between items-center">
              <h3 className="text-lg font-bold text-slate-800">Question Overview</h3>
              <button 
                onClick={() => setShowQuestionPanel(false)}
                className="text-slate-400 hover:text-slate-600 p-2 rounded-full hover:bg-slate-100"
              >
                <X size={20} />
              </button>
            </div>
            
            <div className="p-6">
              <div className="flex flex-col gap-3 mb-6 text-sm">
                <div className="flex items-center gap-2">
                  <div className="w-6 h-6 rounded bg-chemistry-green"></div>
                  <span>Answered ({Object.keys(answers).length})</span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-6 h-6 rounded bg-amber-500"></div>
                  <span>Flagged ({flagged.size})</span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-6 h-6 rounded bg-slate-200"></div>
                  <span>Skipped ({totalQuestions - Object.keys(answers).length})</span>
                </div>
              </div>

              <div className="grid grid-cols-4 gap-3">
                {questions.map((q, idx) => {
                  const status = getQuestionStatus(q);
                  return (
                    <button
                      key={q.ID}
                      onClick={() => jumpToQuestion(idx)}
                      className={`aspect-square rounded-xl font-bold text-base transition-all border-2 ${
                        idx === currentIndex
                          ? 'border-lab-blue ring-2 ring-lab-blue ring-offset-2'
                          : 'border-transparent'
                      } ${
                        status === 'answered'
                          ? 'bg-chemistry-green text-white hover:opacity-80'
                          : status === 'flagged'
                          ? 'bg-amber-500 text-white hover:opacity-80'
                          : 'bg-slate-200 text-slate-600 hover:bg-slate-300'
                      }`}
                    >
                      {idx + 1}
                    </button>
                  );
                })}
              </div>
            </div>
          </div>
        </>
      )}

      {/* Periodic Table Modal */}
      {showPeriodicTable && (
        <div 
          className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
          onClick={() => setShowPeriodicTable(false)}
        >
          <div 
            className="bg-white rounded-2xl shadow-2xl max-w-6xl w-full max-h-[90vh] overflow-auto"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="sticky top-0 bg-white border-b p-4 flex justify-between items-center">
              <h3 className="text-xl font-bold text-slate-800">Periodic Table of Elements</h3>
              <button 
                onClick={() => setShowPeriodicTable(false)}
                className="text-slate-400 hover:text-slate-600 p-2 rounded-full hover:bg-slate-100"
              >
                <X size={24} />
              </button>
            </div>
            <div className="p-4">
              <img 
                src="https://upload.wikimedia.org/wikipedia/commons/2/2e/Simple_Periodic_Table_Chart-en.svg"
                alt="Periodic Table"
                className="w-full h-auto"
              />
            </div>
          </div>
        </div>
      )}

      {/* Main Content Area - Centered and compact */}
      <div className="max-w-5xl mx-auto px-4 py-6 h-full flex flex-col">
        {/* Progress Header - More Compact */}
        <div className="bg-white p-4 rounded-xl shadow-sm border border-slate-200 mb-4">
          <div className="flex justify-between items-center mb-2">
            <div className="flex items-baseline gap-3">
              <span className="text-3xl font-black text-lab-blue">
                Q{currentIndex + 1}
              </span>
              <span className="text-sm font-medium text-slate-500">
                of {totalQuestions}
              </span>
            </div>
            <span className="text-xl font-bold text-lab-blue">
              {Math.round(progress)}%
            </span>
          </div>
          <div className="w-full bg-slate-100 h-2 rounded-full overflow-hidden">
            <div 
              className="bg-lab-blue h-full transition-all duration-300" 
              style={{ width: `${progress}%` }}
            />
          </div>
        </div>

        {/* Question Card Component - Takes remaining space */}
        <div className="flex-1 overflow-y-auto">
          <QuestionCard 
            question={currentQuestion}
            selectedOption={answers[currentQuestion.ID]}
            onSelect={handleOptionSelect}
          />
        </div>

        {/* Mini Progress Dots */}
        <div className="flex justify-center gap-1 mt-4 py-2">
          {questions.slice(0, Math.min(30, totalQuestions)).map((_, idx) => (
            <div 
              key={idx}
              className={`w-2 h-2 rounded-full transition-all ${
                idx === currentIndex ? 'bg-lab-blue w-6' : 
                answers[questions[idx].ID] ? 'bg-chemistry-green' : 
                flagged.has(questions[idx].ID) ? 'bg-amber-500' : 'bg-slate-200'
              }`}
            />
          ))}
          {totalQuestions > 30 && <span className="text-slate-400 text-xs">...</span>}
        </div>

        {!allAnswered && isLastQuestion && (
          <p className="text-center text-sm text-amber-600 font-medium mt-2">
            Please answer all questions before submitting.
          </p>
        )}
      </div>
    </div>
  );
}
--- END_OF_FILE ---

--- FILE_PATH: src/firebase/config.js ---
// Firebase configuration and initialization
import { initializeApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';

// Your web app's Firebase configuration
// TODO: Replace with your own Firebase config from Firebase Console
const firebaseConfig = {
  apiKey: "AIzaSyBKk_TsWIVQCXfIwPQXnFOXvSNQNDgyvFg",
  authDomain: "chemleung-hkdse-mcq-platform.firebaseapp.com",
  projectId: "chemleung-hkdse-mcq-platform",
  storageBucket: "chemleung-hkdse-mcq-platform.firebasestorage.app",
  messagingSenderId: "811594644247",
  appId: "1:811594644247:web:5282c3c73f1d3566955552",
  measurementId: "G-85R118KESK"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);

// Initialize Firebase services
export const auth = getAuth(app);
export const db = getFirestore(app);

export default app;
--- END_OF_FILE ---
