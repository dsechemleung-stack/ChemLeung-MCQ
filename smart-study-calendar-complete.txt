=== src/services/calendarService.js ===
import { doc, setDoc, collection, addDoc, updateDoc, deleteDoc, query, where, getDocs, getDoc, writeBatch } from 'firebase/firestore';
import { db } from '../firebase/config';
import { performanceService } from './performanceService';

/**
 * Calendar Service - Manages user events, exams, quizzes, and AI-generated study plans
 */

export const EVENT_TYPES = {
  MAJOR_EXAM: 'major_exam',
  SMALL_QUIZ: 'small_quiz',
  STUDY_SUGGESTION: 'study_suggestion',
  SPACED_REPETITION: 'spaced_repetition',
  COMPLETION_LOG: 'completion_log',
  AI_RECOMMENDATION: 'ai_recommendation'  // AI-generated recommendation
};

export const calendarService = {
  /**
   * Add a major exam event
   */
  async addMajorExam(userId, examData) {
    try {
      const { date, topic, subtopic, title } = examData;
      
      const examRef = await addDoc(collection(db, 'calendar_events'), {
        userId,
        type: EVENT_TYPES.MAJOR_EXAM,
        date: new Date(date).toISOString().split('T')[0],
        topic: topic || null,
        subtopic: subtopic || null,
        title: title || 'Major Exam',
        createdAt: new Date().toISOString(),
        completed: false
      });

      await this.generateMajorExamStudyPlan(userId, examRef.id, date, topic, subtopic);

      return examRef.id;
    } catch (error) {
      console.error('Error adding major exam:', error);
      throw error;
    }
  },

  /**
   * Add a small quiz event
   */
  async addSmallQuiz(userId, quizData) {
    try {
      const { date, topic, subtopic, title } = quizData;
      
      const quizRef = await addDoc(collection(db, 'calendar_events'), {
        userId,
        type: EVENT_TYPES.SMALL_QUIZ,
        date: new Date(date).toISOString().split('T')[0],
        topic: topic || null,
        subtopic: subtopic || null,
        title: title || 'Quiz',
        createdAt: new Date().toISOString(),
        completed: false
      });

      await this.generateSmallQuizStudyPlan(userId, quizRef.id, date, topic, subtopic);

      return quizRef.id;
    } catch (error) {
      console.error('Error adding small quiz:', error);
      throw error;
    }
  },

  /**
   * Generate study plan for major exam
   */
  async generateMajorExamStudyPlan(userId, examId, examDate, topic, subtopic) {
    const batch = writeBatch(db);
    const examDateObj = new Date(examDate);

    // Phase 1: Warm-up (10-7 days before)
    for (let daysBeforeExam = 10; daysBeforeExam >= 7; daysBeforeExam--) {
      const studyDate = new Date(examDateObj);
      studyDate.setDate(studyDate.getDate() - daysBeforeExam);
      
      const ref = doc(collection(db, 'calendar_events'));
      batch.set(ref, {
        userId,
        type: EVENT_TYPES.STUDY_SUGGESTION,
        date: studyDate.toISOString().split('T')[0],
        topic,
        subtopic,
        questionCount: 10,
        phase: 'warm-up',
        linkedEventId: examId,
        linkedEventType: EVENT_TYPES.MAJOR_EXAM,
        parentId: examId,
        title: `Warm-up: 10 MCQs${topic ? ` - ${topic}` : ''}`,
        createdAt: new Date().toISOString(),
        completed: false
      });
    }

    // Phase 2: Consolidation (6-4 days before)
    for (let daysBeforeExam = 6; daysBeforeExam >= 4; daysBeforeExam--) {
      const studyDate = new Date(examDateObj);
      studyDate.setDate(studyDate.getDate() - daysBeforeExam);
      
      const ref = doc(collection(db, 'calendar_events'));
      batch.set(ref, {
        userId,
        type: EVENT_TYPES.STUDY_SUGGESTION,
        date: studyDate.toISOString().split('T')[0],
        topic,
        subtopic,
        questionCount: 20,
        phase: 'consolidation',
        linkedEventId: examId,
        linkedEventType: EVENT_TYPES.MAJOR_EXAM,
        parentId: examId,
        title: `Consolidation: 20 MCQs${topic ? ` - ${topic}` : ''}`,
        createdAt: new Date().toISOString(),
        completed: false
      });
    }

    // Phase 3: Sprint (3-1 days before)
    for (let daysBeforeExam = 3; daysBeforeExam >= 1; daysBeforeExam--) {
      const studyDate = new Date(examDateObj);
      studyDate.setDate(studyDate.getDate() - daysBeforeExam);
      
      const ref = doc(collection(db, 'calendar_events'));
      batch.set(ref, {
        userId,
        type: EVENT_TYPES.STUDY_SUGGESTION,
        date: studyDate.toISOString().split('T')[0],
        topic,
        subtopic,
        questionCount: 40,
        phase: 'sprint',
        linkedEventId: examId,
        linkedEventType: EVENT_TYPES.MAJOR_EXAM,
        parentId: examId,
        title: `Sprint: 40 MCQs${topic ? ` - ${topic}` : ''}`,
        createdAt: new Date().toISOString(),
        completed: false
      });
    }

    await batch.commit();
  },

  /**
   * Generate study plan for small quiz
   */
  async generateSmallQuizStudyPlan(userId, quizId, quizDate, topic, subtopic) {
    const batch = writeBatch(db);
    const quizDateObj = new Date(quizDate);

    const plan = [
      { days: 3, count: 5, phase: 'initial-review', title: 'Initial Review: 5 MCQs' },
      { days: 2, count: 10, phase: 'topic-focus', title: 'Topic Focus: 10 MCQs' },
      { days: 1, count: 15, phase: 'final-polish', title: 'Final Polish: 15 MCQs + Mistakes' }
    ];

    for (const { days, count, phase, title } of plan) {
      const studyDate = new Date(quizDateObj);
      studyDate.setDate(studyDate.getDate() - days);
      
      const ref = doc(collection(db, 'calendar_events'));
      batch.set(ref, {
        userId,
        type: EVENT_TYPES.STUDY_SUGGESTION,
        date: studyDate.toISOString().split('T')[0],
        topic,
        subtopic,
        questionCount: count,
        phase,
        linkedEventId: quizId,
        linkedEventType: EVENT_TYPES.SMALL_QUIZ,
        parentId: quizId,
        title: `${title}${topic ? ` - ${topic}` : ''}`,
        createdAt: new Date().toISOString(),
        completed: false,
        includeMistakes: phase === 'final-polish'
      });
    }

    await batch.commit();
  },

  /**
   * Schedule spaced repetition for a mistake
   * IMPROVED: Reschedules ALL 5 intervals (1,3,7,14,30 days) and deletes old incomplete reviews
   */
  async scheduleSpacedRepetition(userId, mistakeData) {
    try {
      const { questionId, topic, subtopic, attemptCount = 1 } = mistakeData;
      
      // Spaced repetition intervals: Day 1, 3, 7, 14, 30
      const intervals = [1, 3, 7, 14, 30];
      
      // Check existing reviews for this question
      const existingQuery = query(
        collection(db, 'calendar_events'),
        where('userId', '==', userId),
        where('type', '==', EVENT_TYPES.SPACED_REPETITION),
        where('questionId', '==', questionId)
      );
      
      const existingDocs = await getDocs(existingQuery);
      
      // Delete old incomplete reviews
      const batch = writeBatch(db);
      existingDocs.forEach(doc => {
        if (!doc.data().completed) {
          batch.delete(doc.ref);
        }
      });
      
      // Schedule ALL intervals from current attempt onward
      const scheduledEvents = [];
      
      for (let i = 0; i < intervals.length; i++) {
        const interval = intervals[i];
        const reviewDate = new Date();
        reviewDate.setDate(reviewDate.getDate() + interval);
        const dateStr = reviewDate.toISOString().split('T')[0];
        
        const eventRef = doc(collection(db, 'calendar_events'));
        const eventData = {
          userId,
          type: EVENT_TYPES.SPACED_REPETITION,
          date: dateStr,
          questionId,
          topic: topic || 'General',
          subtopic: subtopic || 'General',
          title: `Review: ${subtopic || topic || 'Question'}`,
          interval,
          attemptNumber: i + 1, // 1st review, 2nd review, etc.
          completed: false,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        
        batch.set(eventRef, eventData);
        scheduledEvents.push({ id: eventRef.id, ...eventData });
        
        console.log(`üìÖ Scheduled review ${i + 1}/5 for ${questionId} on ${dateStr} (+${interval} days)`);
      }
      
      await batch.commit();
      console.log(`‚úÖ Scheduled ${scheduledEvents.length} reviews for question ${questionId}`);
      
      return scheduledEvents;
    } catch (error) {
      console.error('Error scheduling spaced repetition:', error);
      throw error;
    }
  },

  /**
   * Create AI recommendation event from suggestion
   */
  async createAIRecommendationEvent(userId, recommendation) {
    try {
      const eventRef = await addDoc(collection(db, 'calendar_events'), {
        userId,
        type: EVENT_TYPES.AI_RECOMMENDATION,
        date: recommendation.suggestedDate,
        topic: recommendation.topic,
        subtopic: recommendation.subtopic,
        questionCount: recommendation.questionCount,
        priority: recommendation.priority,
        reason: recommendation.reason,
        recommendationId: recommendation.id,
        title: `ü§ñ AI Suggests: ${recommendation.subtopic}`,
        description: recommendation.reason,
        createdAt: new Date().toISOString(),
        completed: false
      });

      // Mark recommendation as accepted
      await performanceService.acceptRecommendation(userId, recommendation.id);

      return eventRef.id;
    } catch (error) {
      console.error('Error creating AI recommendation event:', error);
      throw error;
    }
  },

  /**
   * Log completion of a study session
   */
  async logCompletion(userId, date, sessionData, questions = null, answers = null) {
    try {
      const { type, topic, questionCount, correctCount } = sessionData;
      
      // Log to calendar
      await addDoc(collection(db, 'calendar_events'), {
        userId,
        type: EVENT_TYPES.COMPLETION_LOG,
        date: new Date(date).toISOString().split('T')[0],
        sessionType: type,
        topic,
        questionCount,
        correctCount,
        accuracy: correctCount / questionCount,
        timestamp: new Date().toISOString()
      });

      // Record performance if questions and answers provided
      if (questions && answers) {
        await performanceService.recordQuizResults(userId, questions, answers);
      }
    } catch (error) {
      console.error('Error logging completion:', error);
      throw error;
    }
  },

  /**
   * Mark an event as completed (legacy method)
   */
  async markEventCompleted(eventId) {
    try {
      const eventRef = doc(db, 'calendar_events', eventId);
      await updateDoc(eventRef, {
        completed: true,
        completedAt: new Date().toISOString()
      });
    } catch (error) {
      console.error('Error marking event completed:', error);
      throw error;
    }
  },

  /**
   * Mark an event as complete with detailed completion data
   */
  async markEventComplete(eventId, completionData) {
    try {
      const eventRef = doc(db, 'calendar_events', eventId);
      await updateDoc(eventRef, {
        completed: true,
        completedAt: completionData.completedAt,
        completionData,
        updatedAt: new Date().toISOString()
      });
      
      console.log('‚úÖ Event marked as complete:', eventId);
      return true;
    } catch (error) {
      console.error('‚ùå Error marking event complete:', error);
      throw error;
    }
  },

  /**
   * Get all events for a user in a date range
   */
  async getUserEvents(userId, startDate, endDate) {
    try {
      const q = query(
        collection(db, 'calendar_events'),
        where('userId', '==', userId),
        where('date', '>=', startDate),
        where('date', '<=', endDate)
      );
      
      const querySnapshot = await getDocs(q);
      const events = [];
      
      querySnapshot.forEach((doc) => {
        events.push({ id: doc.id, ...doc.data() });
      });
      
      return events;
    } catch (error) {
      console.error('Error getting user events:', error);
      throw error;
    }
  },

  /**
   * Delete event and optionally cascade delete children
   */
  async deleteEvent(eventId, cascadeDelete = true) {
    try {
      const batch = writeBatch(db);
      
      // Get the event to check if it's a parent
      const eventRef = doc(db, 'calendar_events', eventId);
      const eventSnap = await getDoc(eventRef);
      
      if (!eventSnap.exists()) {
        throw new Error('Event not found');
      }
      
      const eventData = eventSnap.data();
      
      // Delete the main event
      batch.delete(eventRef);
      
      // If cascade delete, delete all child events using parentId
      if (cascadeDelete && (eventData.type === EVENT_TYPES.MAJOR_EXAM || eventData.type === EVENT_TYPES.SMALL_QUIZ)) {
        // Delete all study suggestions and repetitions with this parentId
        const childQuery = query(
          collection(db, 'calendar_events'),
          where('parentId', '==', eventId)
        );
        
        const childSnap = await getDocs(childQuery);
        childSnap.forEach(doc => batch.delete(doc.ref));
        
        // Also check for linked events (backward compatibility)
        const linkedQuery = query(
          collection(db, 'calendar_events'),
          where('linkedEventId', '==', eventId)
        );
        
        const linkedSnap = await getDocs(linkedQuery);
        linkedSnap.forEach(doc => {
          // Avoid double-deleting if already in child batch
          if (!childSnap.docs.find(d => d.id === doc.id)) {
            batch.delete(doc.ref);
          }
        });
        
        console.log(`üóëÔ∏è Cascade deleting ${childSnap.size} children and ${linkedSnap.size} linked events`);
      }
      
      await batch.commit();
      console.log('‚úÖ Event deleted successfully');
      return true;
    } catch (error) {
      console.error('‚ùå Error deleting event:', error);
      throw error;
    }
  },

  /**
   * Get events grouped by date for calendar display
   */
  async getCalendarData(userId, year, month) {
    try {
      const startDate = new Date(year, month, 1).toISOString().split('T')[0];
      const endDate = new Date(year, month + 1, 0).toISOString().split('T')[0];
      
      const events = await this.getUserEvents(userId, startDate, endDate);
      
      // Group events by date
      const calendar = {};
      
      events.forEach(event => {
        if (!calendar[event.date]) {
          calendar[event.date] = {
            exams: [],
            quizzes: [],
            suggestions: [],
            repetitions: [],
            completions: [],
            aiRecommendations: []
          };
        }
        
        switch (event.type) {
          case EVENT_TYPES.MAJOR_EXAM:
            calendar[event.date].exams.push(event);
            break;
          case EVENT_TYPES.SMALL_QUIZ:
            calendar[event.date].quizzes.push(event);
            break;
          case EVENT_TYPES.STUDY_SUGGESTION:
            calendar[event.date].suggestions.push(event);
            break;
          case EVENT_TYPES.SPACED_REPETITION:
            calendar[event.date].repetitions.push(event);
            break;
          case EVENT_TYPES.COMPLETION_LOG:
            calendar[event.date].completions.push(event);
            break;
          case EVENT_TYPES.AI_RECOMMENDATION:
            calendar[event.date].aiRecommendations.push(event);
            break;
        }
      });
      
      return calendar;
    } catch (error) {
      console.error('Error getting calendar data:', error);
      throw error;
    }
  }
};

=== src/services/performanceService.js ===
import { doc, setDoc, getDoc, getDocs, collection, query, where, writeBatch, serverTimestamp } from 'firebase/firestore';
import { db } from '../firebase/config';

/**
 * Performance Service - Tracks user performance by topic/subtopic
 * Records quiz results and identifies weak areas for AI recommendations
 */

export const performanceService = {
  
  /**
   * Record quiz results grouped by subtopic
   * @param {string} userId - User ID
   * @param {Array} questions - Questions from the quiz
   * @param {Object} answers - User's answers {questionId: selectedOption}
   */
  async recordQuizResults(userId, questions, answers) {
    try {
      // Group questions by topic::subtopic
      const subtopicGroups = {};
      
      questions.forEach(question => {
        const topic = question.Topic || 'General';
        const subtopic = question.Subtopic || 'General';
        const key = `${topic}::${subtopic}`;
        
        if (!subtopicGroups[key]) {
          subtopicGroups[key] = {
            topic,
            subtopic,
            questions: [],
            correct: 0,
            total: 0
          };
        }
        
        subtopicGroups[key].questions.push(question);
        subtopicGroups[key].total++;
        
        // Check if answer is correct
        if (answers[question.ID] === question.CorrectOption) {
          subtopicGroups[key].correct++;
        }
      });
      
      // Update Firestore for each subtopic
      const batch = writeBatch(db);
      
      for (const [key, data] of Object.entries(subtopicGroups)) {
        const subtopicRef = doc(db, 'user_performance', userId, 'subtopics', key);
        
        // Get existing data
        const existingDoc = await getDoc(subtopicRef);
        const existing = existingDoc.exists() ? existingDoc.data() : null;
        
        // Calculate new values
        const totalAttempts = (existing?.totalAttempts || 0) + data.total;
        const correctAttempts = (existing?.correctAttempts || 0) + data.correct;
        const accuracy = totalAttempts > 0 ? correctAttempts / totalAttempts : 0;
        const newAccuracy = data.correct / data.total;
        
        // Track recent attempts (last 10)
        const recentAttempts = existing?.recentAttempts || [];
        recentAttempts.push({
          date: new Date().toISOString(),
          total: data.total,
          correct: data.correct,
          accuracy: newAccuracy
        });
        
        // Keep only last 10 attempts
        if (recentAttempts.length > 10) {
          recentAttempts.shift();
        }
        
        // Merge with existing data
        batch.set(subtopicRef, {
          topic: data.topic,
          subtopic: data.subtopic,
          totalAttempts,
          correctAttempts,
          accuracy,
          lastAttempted: new Date().toISOString(),
          firstAttempted: existing?.firstAttempted || new Date().toISOString(),
          questionsSeen: Array.from(new Set([
            ...(existing?.questionsSeen || []),
            ...data.questions.map(q => q.ID)
          ])),
          recentAttempts,
          updatedAt: new Date().toISOString()
        }, { merge: true });
      }
      
      await batch.commit();
      
      // After recording, trigger AI recommendation generation
      await this.generateAIRecommendations(userId);
      
      return Object.keys(subtopicGroups).length;
    } catch (error) {
      console.error('Error recording quiz results:', error);
      throw error;
    }
  },
  
  /**
   * Get performance data for a specific subtopic
   */
  async getSubtopicPerformance(userId, topic, subtopic) {
    try {
      const key = `${topic}::${subtopic}`;
      const subtopicRef = doc(db, 'user_performance', userId, 'subtopics', key);
      const docSnap = await getDoc(subtopicRef);
      
      return docSnap.exists() ? docSnap.data() : null;
    } catch (error) {
      console.error('Error getting subtopic performance:', error);
      return null;
    }
  },
  
  /**
   * Get all performance data for user
   */
  async getAllPerformance(userId) {
    try {
      const subtopicsRef = collection(db, 'user_performance', userId, 'subtopics');
      const snapshot = await getDocs(subtopicsRef);
      
      const performance = [];
      snapshot.forEach(doc => {
        performance.push({
          id: doc.id,
          ...doc.data()
        });
      });
      
      return performance;
    } catch (error) {
      console.error('Error getting all performance:', error);
      return [];
    }
  },
  
  /**
   * Generate AI recommendations based on performance data
   * Identifies weak subtopics and creates study suggestions
   */
  async generateAIRecommendations(userId) {
    try {
      const performance = await this.getAllPerformance(userId);
      
      // Identify weak subtopics
      const weakAreas = performance.filter(p => {
        // Criteria for weakness:
        // 1. Accuracy < 60% AND attempted at least 5 questions
        // 2. OR accuracy < 70% AND attempted at least 10 questions
        // 3. OR declining trend in recent attempts
        
        const hasLowAccuracy = p.accuracy < 0.6 && p.totalAttempts >= 5;
        const hasModerateWeakness = p.accuracy < 0.7 && p.totalAttempts >= 10;
        
        // Check for declining trend
        const hasDecliningTrend = this.checkDecliningTrend(p.recentAttempts);
        
        return hasLowAccuracy || hasModerateWeakness || hasDecliningTrend;
      });
      
      // Sort by priority (lowest accuracy first)
      weakAreas.sort((a, b) => a.accuracy - b.accuracy);
      
      // Create recommendations for top 5 weak areas
      const recommendations = weakAreas.slice(0, 5).map((area, index) => {
        const priority = area.accuracy < 0.5 ? 'HIGH' : 
                        area.accuracy < 0.6 ? 'MEDIUM' : 'LOW';
        
        // Suggest date: tomorrow + index (spread recommendations)
        const suggestedDate = new Date();
        suggestedDate.setDate(suggestedDate.getDate() + index + 1);
        
        const questionCount = priority === 'HIGH' ? 20 : 
                              priority === 'MEDIUM' ? 15 : 10;
        
        return {
          topic: area.topic,
          subtopic: area.subtopic,
          reason: this.generateReason(area),
          priority,
          suggestedDate: suggestedDate.toISOString().split('T')[0],
          questionCount,
          currentAccuracy: Math.round(area.accuracy * 100),
          attemptsCount: area.totalAttempts,
          status: 'pending', // pending, accepted, dismissed
          createdAt: new Date().toISOString()
        };
      });
      
      // Save recommendations to Firestore
      await this.saveRecommendations(userId, recommendations);
      
      return recommendations;
    } catch (error) {
      console.error('Error generating AI recommendations:', error);
      return [];
    }
  },
  
  /**
   * Check if there's a declining performance trend
   */
  checkDecliningTrend(recentAttempts) {
    if (!recentAttempts || recentAttempts.length < 3) return false;
    
    // Get last 3 attempts
    const last3 = recentAttempts.slice(-3);
    
    // Check if each attempt is worse than the previous
    for (let i = 1; i < last3.length; i++) {
      if (last3[i].accuracy >= last3[i-1].accuracy) {
        return false; // Not consistently declining
      }
    }
    
    return true;
  },
  
  /**
   * Generate human-readable reason for recommendation
   */
  generateReason(area) {
    const accuracy = Math.round(area.accuracy * 100);
    
    if (area.accuracy < 0.5) {
      return `Critical weakness (${accuracy}% accuracy). Needs immediate review.`;
    } else if (area.accuracy < 0.6) {
      return `Below target (${accuracy}% accuracy). Practice recommended.`;
    } else if (area.accuracy < 0.7) {
      return `Room for improvement (${accuracy}% accuracy). Additional practice suggested.`;
    } else {
      return `Recent performance decline detected. Reinforce fundamentals.`;
    }
  },
  
  /**
   * Save recommendations to Firestore
   */
  async saveRecommendations(userId, recommendations) {
    try {
      const batch = writeBatch(db);
      
      // Clear old pending recommendations first
      const oldRecsRef = collection(db, 'ai_recommendations', userId, 'suggestions');
      const oldQuery = query(oldRecsRef, where('status', '==', 'pending'));
      const oldDocs = await getDocs(oldQuery);
      
      oldDocs.forEach(doc => {
        batch.delete(doc.ref);
      });
      
      // Add new recommendations
      recommendations.forEach(rec => {
        const recRef = doc(collection(db, 'ai_recommendations', userId, 'suggestions'));
        batch.set(recRef, rec);
      });
      
      await batch.commit();
    } catch (error) {
      console.error('Error saving recommendations:', error);
      throw error;
    }
  },
  
  /**
   * Get AI recommendations for user
   */
  async getRecommendations(userId) {
    try {
      const recsRef = collection(db, 'ai_recommendations', userId, 'suggestions');
      const q = query(recsRef, where('status', '==', 'pending'));
      const snapshot = await getDocs(q);
      
      const recommendations = [];
      snapshot.forEach(doc => {
        recommendations.push({
          id: doc.id,
          ...doc.data()
        });
      });
      
      // Sort by priority (HIGH -> MEDIUM -> LOW)
      const priorityOrder = { 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3 };
      recommendations.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
      
      return recommendations;
    } catch (error) {
      console.error('Error getting recommendations:', error);
      return [];
    }
  },
  
  /**
   * Accept a recommendation (convert to calendar event)
   */
  async acceptRecommendation(userId, recommendationId) {
    try {
      const recRef = doc(db, 'ai_recommendations', userId, 'suggestions', recommendationId);
      await setDoc(recRef, {
        status: 'accepted',
        acceptedAt: new Date().toISOString()
      }, { merge: true });
    } catch (error) {
      console.error('Error accepting recommendation:', error);
      throw error;
    }
  },
  
  /**
   * Dismiss a recommendation
   */
  async dismissRecommendation(userId, recommendationId) {
    try {
      const recRef = doc(db, 'ai_recommendations', userId, 'suggestions', recommendationId);
      await setDoc(recRef, {
        status: 'dismissed',
        dismissedAt: new Date().toISOString()
      }, { merge: true });
    } catch (error) {
      console.error('Error dismissing recommendation:', error);
      throw error;
    }
  }
};

=== src/services/quizCompletionService.js ===
import { performanceService } from './performanceService';
import { calendarService } from './calendarService';

/**
 * Quiz Completion Service
 * Handles all post-quiz processing: performance tracking and spaced repetition
 */
export const quizCompletionService = {
  
  /**
   * Process quiz completion - records performance and schedules reviews
   */
  async processQuizCompletion(userId, questions, answers) {
    if (!userId || !questions || !answers) {
      console.error('‚ùå Missing required data for quiz completion processing');
      return {
        performanceRecorded: false,
        repetitionsScheduled: 0,
        errors: ['Missing required data']
      };
    }

    const results = {
      performanceRecorded: false,
      repetitionsScheduled: 0,
      errors: []
    };

    // STEP 1: Record Performance (for AI recommendations)
    try {
      console.log('üìä Recording performance data...');
      await performanceService.recordQuizResults(userId, questions, answers);
      results.performanceRecorded = true;
      console.log('‚úÖ Performance data recorded successfully');
    } catch (error) {
      console.error('‚ùå Error recording performance:', error);
      results.errors.push(`Performance recording failed: ${error.message}`);
    }

    // STEP 2: Schedule Spaced Repetition for Mistakes
    try {
      console.log('üìÖ Scheduling spaced repetition for mistakes...');
      
      const mistakes = questions.filter(q => {
        const userAnswer = answers[q.ID];
        return userAnswer && userAnswer !== q.CorrectOption;
      });

      console.log(`Found ${mistakes.length} mistake(s) to schedule`);

      if (mistakes.length === 0) {
        console.log('üéâ No mistakes - perfect score!');
        return results;
      }

      const improvements = JSON.parse(
        localStorage.getItem('mistake_improvements') || '{}'
      );

      let scheduledCount = 0;
      const batchSize = 5;
      
      for (let i = 0; i < mistakes.length; i += batchSize) {
        const batch = mistakes.slice(i, i + batchSize);
        
        await Promise.all(
          batch.map(async (mistake) => {
            try {
              const improvementCount = improvements[mistake.ID]?.correctCount || 0;
              
              if (improvementCount < 3) {
                // Schedule ALL future reviews at once
                const scheduled = await calendarService.scheduleSpacedRepetition(userId, {
                  questionId: mistake.ID,
                  topic: mistake.Topic,
                  subtopic: mistake.Subtopic,
                  attemptCount: improvementCount + 1 // Current attempt number
                });
                
                if (scheduled && scheduled.length > 0) {
                  scheduledCount += scheduled.length;
                }
              } else {
                console.log(`‚è≠Ô∏è Skipping ${mistake.ID} - already mastered`);
              }
            } catch (error) {
              console.error(`‚ùå Failed to schedule ${mistake.ID}:`, error);
              results.errors.push(`Question ${mistake.ID}: ${error.message}`);
            }
          })
        );
        
        if (i + batchSize < mistakes.length) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }

      results.repetitionsScheduled = scheduledCount;
      console.log(`‚úÖ Successfully scheduled ${scheduledCount} spaced repetition review(s)`);

    } catch (error) {
      console.error('‚ùå Error in spaced repetition scheduling:', error);
      results.errors.push(`Spaced repetition failed: ${error.message}`);
    }

    return results;
  },

  async refreshAIRecommendations(userId) {
    try {
      console.log('üîÑ Forcing AI recommendation refresh...');
      await performanceService.generateAIRecommendations(userId);
      console.log('‚úÖ AI recommendations refreshed successfully');
      return true;
    } catch (error) {
      console.error('‚ùå Error refreshing AI recommendations:', error);
      return false;
    }
  }
};

=== src/components/dashboard/CalendarHeatmap.jsx ===
import React, { useMemo } from 'react';
import { Calendar } from 'lucide-react';
import { useLanguage } from '../../contexts/LanguageContext';

/**
 * CalendarHeatmap: 30-day mistake-clearing activity visualization
 * Shows daily progress on a calendar grid with color intensity
 */
export default function CalendarHeatmap({ mistakes = [] }) {
  const { t } = useLanguage();

  const activityMap = useMemo(() => {
    const map = {};
    const now = new Date();

    // Initialize 30-day map
    for (let i = 0; i < 30; i++) {
      const d = new Date(now);
      d.setDate(d.getDate() - i);
      const dateStr = d.toISOString().split('T')[0];
      map[dateStr] = 0;
    }

    // Count correct answers by date
    mistakes.forEach((mistake) => {
      if (mistake.lastCorrect) {
        const dateStr = new Date(mistake.lastCorrect).toISOString().split('T')[0];
        if (map[dateStr] !== undefined) {
          map[dateStr]++;
        }
      }
    });

    return map;
  }, [mistakes]);

  const days = Object.entries(activityMap).reverse();
  const maxActivity = Math.max(...Object.values(activityMap), 1);

  const getColor = (count) => {
    const intensity = count / maxActivity;
    if (intensity === 0) return 'bg-slate-100 hover:bg-slate-200';
    if (intensity < 0.33) return 'bg-green-200 hover:bg-green-300';
    if (intensity < 0.67) return 'bg-green-400 hover:bg-green-500';
    return 'bg-green-600 hover:bg-green-700';
  };

  const getTotalCleared = () => Object.values(activityMap).reduce((a, b) => a + b, 0);

  return (
    <div className="bg-white rounded-2xl shadow-lg border-2 border-slate-100 p-6">
      {/* Header */}
      <div className="flex items-center gap-3 mb-6">
        <div className="w-12 h-12 rounded-xl bg-green-100 flex items-center justify-center">
          <Calendar className="text-green-600" size={28} />
        </div>
        <div>
          <h3 className="text-xl font-black text-slate-800">Activity Tracker</h3>
          <p className="text-xs text-slate-500 mt-1">30-day mistake-clearing consistency</p>
        </div>
      </div>

      {/* Stats Row */}
      <div className="grid grid-cols-2 gap-4 mb-6">
        <div className="text-center">
          <div className="text-sm text-slate-600 font-medium mb-1">Total Cleared (30 days)</div>
          <div className="text-3xl font-black text-green-600">{getTotalCleared()}</div>
        </div>
        <div className="text-center">
          <div className="text-sm text-slate-600 font-medium mb-1">Busiest Day</div>
          <div className="text-3xl font-black text-green-600">{maxActivity}</div>
        </div>
      </div>

      {/* Calendar Grid */}
      <div className="overflow-x-auto mb-4">
        <div className="inline-block min-w-full">
          <div className="grid gap-1" style={{ gridTemplateColumns: 'repeat(7, 1fr)' }}>
            {/* Day headers */}
            {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day, idx) => (
              <div
                key={`header-${idx}`}
                className="text-center text-xs font-bold text-slate-400 h-6 flex items-center justify-center"
              >
                {day.slice(0, 1)}
              </div>
            ))}

            {/* Calendar cells */}
            {days.map(([dateStr, count]) => {
              const date = new Date(dateStr);
              const dayOfWeek = date.getDay();
              const isToday = dateStr === new Date().toISOString().split('T')[0];

              return (
                <div
                  key={dateStr}
                  className={`w-8 h-8 rounded flex items-center justify-center text-xs font-bold text-slate-700 transition-all cursor-pointer ring-2 ring-offset-1 ${
                    isToday ? 'ring-indigo-400 ring-offset-slate-100' : 'ring-transparent'
                  } ${getColor(count)}`}
                  title={`${dateStr}: ${count} question${count !== 1 ? 's' : ''} cleared`}
                >
                  {count > 0 && <span className="text-white font-black text-xs">{count}</span>}
                </div>
              );
            })}
          </div>
        </div>
      </div>

      {/* Legend */}
      <div className="flex items-center justify-center gap-3 text-xs text-slate-600 pt-4 border-t border-slate-200">
        <span className="font-medium">Less</span>
        <div className="flex gap-1">
          {[0, 0.33, 0.67, 1.0].map((i, idx) => (
            <div
              key={idx}
              className={`w-3 h-3 rounded transition-colors ${getColor(i * maxActivity).split(' ')[0]}`}
            />
          ))}
        </div>
        <span className="font-medium">More</span>
      </div>

      {/* Motivational Message */}
      <div className="mt-4 pt-4 border-t border-slate-200 bg-green-50 rounded-lg p-3">
        <p className="text-sm text-green-800 font-semibold text-center">
          üî• Keep the streak going! Consistency builds mastery.{' '}
        </p>
      </div>
    </div>
  );
}


=== src/components/dashboard/CompactAttemptsList.jsx ===
import React from 'react';
import { Clock, ChevronRight, AlertCircle } from 'lucide-react';
import { useLanguage } from '../../contexts/LanguageContext';

/**
 * CompactAttemptsList: More compact version of Recent Attempts
 * Adds Topic Badges and better visual hierarchy
 */
export default function CompactAttemptsList({ attempts = [], onSelectAttempt = () => {}, loading = false }) {
  const { t } = useLanguage();

  const formatDate = (iso) =>
    new Date(iso).toLocaleDateString('en-GB', {
      day: '2-digit',
      month: 'short',
      hour: '2-digit',
      minute: '2-digit',
    });

  const formatTime = (ms) => {
    if (!ms) return 'N/A';
    const s = Math.floor(ms / 1000),
      m = Math.floor(s / 60),
      h = Math.floor(m / 60);
    if (h > 0) return `${h}h ${m % 60}m`;
    if (m > 0) return `${m}m ${s % 60}s`;
    return `${s}s`;
  };

  const getAccuracyColor = (percentage) => {
    if (percentage >= 70) return 'from-emerald-100 to-emerald-200 text-emerald-800 border-emerald-300';
    if (percentage >= 50) return 'from-amber-100 to-amber-200 text-amber-800 border-amber-300';
    return 'from-rose-100 to-rose-200 text-rose-800 border-rose-300';
  };

  const getTopicBadgeColor = (index) => {
    const colors = [
      'bg-blue-100 text-blue-700',
      'bg-purple-100 text-purple-700',
      'bg-pink-100 text-pink-700',
      'bg-green-100 text-green-700',
      'bg-orange-100 text-orange-700',
    ];
    return colors[index % colors.length];
  };

  return (
    <div className="bg-white rounded-2xl shadow-lg border-2 border-slate-100 overflow-hidden">
      {/* Header */}
      <div className="bg-slate-50 p-5 border-b-2 border-slate-200 flex items-center justify-between">
        <h2 className="text-xl font-bold text-slate-800 flex items-center gap-2">
          <Clock className="text-slate-600" size={24} />
          Recent Attempts
        </h2>
        <span className="text-sm text-slate-500 font-medium">{attempts.length} Quiz Session(s)</span>
      </div>

      {/* Content */}
      <div className="p-6">
        {attempts.length === 0 ? (
          <div className="text-center py-12">
            <AlertCircle className="w-16 h-16 text-slate-300 mx-auto mb-4" />
            <p className="text-slate-600 text-lg font-semibold mb-2">No attempts yet</p>
            <p className="text-slate-500 text-sm">Complete a quiz to see your results here</p>
          </div>
        ) : (
          <div className="space-y-2">
            {attempts.map((attempt) => (
              <button
                key={attempt.id}
                onClick={() => onSelectAttempt(attempt)}
                className="w-full flex items-center justify-between p-3 rounded-xl border-2 border-slate-100 hover:border-indigo-300 hover:bg-indigo-50/50 transition-all group"
              >
                {/* Left Side: Score + Details */}
                <div className="flex items-center gap-3 flex-1 min-w-0">
                  {/* Score Badge */}
                  <div
                    className={`w-12 h-12 rounded-lg flex items-center justify-center font-black text-lg shadow-sm flex-shrink-0 border-2 bg-gradient-to-br ${getAccuracyColor(
                      attempt.percentage
                    )}`}
                  >
                    {attempt.percentage}%
                  </div>

                  {/* Info */}
                  <div className="min-w-0 flex-1">
                    <div className="flex items-center gap-2 mb-1">
                      <div className="font-bold text-slate-800">
                        {attempt.correctAnswers}/{attempt.totalQuestions} Correct
                      </div>
                      {attempt.timeSpent && (
                        <span className="text-xs text-slate-500">
                          ‚è±Ô∏è {formatTime(attempt.timeSpent)}
                        </span>
                      )}
                    </div>

                    {/* Date & Topics */}
                    <div className="flex flex-col gap-1">
                      <div className="text-xs text-slate-500 font-medium">{formatDate(attempt.timestamp)}</div>

                      {/* Topic Badges */}
                      {attempt.topics && attempt.topics.length > 0 && (
                        <div className="flex flex-wrap gap-1">
                          {attempt.topics.slice(0, 3).map((topic, idx) => (
                            <span
                              key={idx}
                              className={`px-2 py-0.5 rounded-full text-xs font-bold truncate ${getTopicBadgeColor(
                                idx
                              )}`}
                            >
                              {topic}
                            </span>
                          ))}
                          {attempt.topics.length > 3 && (
                            <span className="px-2 py-0.5 rounded-full text-xs font-bold text-slate-600 bg-slate-100">
                              +{attempt.topics.length - 3}
                            </span>
                          )}
                        </div>
                      )}
                    </div>
                  </div>
                </div>

                {/* Right Side: Arrow */}
                <ChevronRight size={18} className="text-slate-400 group-hover:text-indigo-500 transition-colors flex-shrink-0 ml-2" />
              </button>
            ))}
          </div>
        )}
      </div>

      {/* Footer CTA */}
      {attempts.length > 0 && (
        <div className="border-t border-slate-200 p-4 bg-slate-50">
          <p className="text-xs text-center text-slate-500">
            üëÜ <span className="font-semibold">Click any attempt</span> to see detailed analysis and insights
          </p>
        </div>
      )}
    </div>
  );
}


=== src/components/dashboard/CurrentGoalWidget.jsx ===
import React, { useMemo } from 'react';
import { Target, ThumbsUp } from 'lucide-react';
import { getMasteryState, findClosestToMastery } from '../../utils/masteryHelper';

/**
 * CurrentGoalWidget: Shows the user's next mastery milestone
 * "You are 5 questions away from mastering Organic Chemistry."
 */
export default function CurrentGoalWidget({ mistakes }) {
  const goal = useMemo(() => findClosestToMastery(mistakes || []), [mistakes]);

  if (!goal) {
    return (
      <div className="bg-gradient-to-br from-indigo-50 to-blue-50 rounded-2xl shadow-lg border-2 border-indigo-200 p-6">
        <div className="flex items-center gap-3 mb-4">
          <div className="w-12 h-12 rounded-xl bg-indigo-200 flex items-center justify-center">
            <Target className="text-indigo-600" size={28} />
          </div>
          <h3 className="text-xl font-black text-indigo-900">Your Next Goal</h3>
        </div>
        <p className="text-indigo-700">No tracked mistakes yet. Complete quizzes to start your learning journey!</p>
      </div>
    );
  }

  const progressPercentage = (goal.mastered / goal.total) * 100;

  return (
    <div className="bg-gradient-to-br from-indigo-50 to-blue-50 rounded-2xl shadow-lg border-2 border-indigo-200 p-6">
      {/* Header */}
      <div className="flex items-center gap-3 mb-4">
        <div className="w-12 h-12 rounded-xl bg-indigo-200 flex items-center justify-center">
          <Target className="text-indigo-600" size={28} />
        </div>
        <h3 className="text-xl font-black text-indigo-900">Your Next Goal</h3>
      </div>

      {/* Goal Statement */}
      <div className="mb-4">
        <p className="text-indigo-900 text-lg font-bold">
          You are{' '}
          <span className="text-indigo-600 font-black">
            {Math.max(0, goal.questionsUntilMastery)}
          </span>{' '}
          questions away from mastering{' '}
          <span className="text-indigo-600 bg-indigo-200 px-2 py-1 rounded font-bold">
            {goal.topic}
          </span>
        </p>
        <p className="text-indigo-600 text-sm mt-2 flex items-center gap-1">
          <ThumbsUp size={16} /> {goal.mastered} of {goal.total} topics already solidified
        </p>
      </div>

      {/* Progress Bar */}
      <div className="bg-indigo-200/50 rounded-full h-3 overflow-hidden mb-3 border border-indigo-300">
        <div
          className="h-full bg-gradient-to-r from-indigo-500 to-indigo-600 transition-all duration-500 rounded-full"
          style={{ width: `${progressPercentage}%` }}
        ></div>
      </div>
      <div className="flex justify-between text-xs font-semibold text-indigo-700">
        <span>{goal.mastered}/{goal.total} Mastered</span>
        <span>{Math.round(progressPercentage)}%</span>
      </div>

      {/* Action CTA */}
      <div className="mt-4 pt-4 border-t border-indigo-200">
        <p className="text-xs text-indigo-600 font-medium mb-2">Pro Tip:</p>
        <p className="text-sm text-indigo-800 font-semibold">
          Focus your daily mission on {goal.topic} to reach mastery faster!
        </p>
      </div>
    </div>
  );
}


=== src/components/dashboard/DailyMissionCard.jsx ===
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { Zap, BookOpen } from 'lucide-react';

/**
 * DailyMissionCard: Hero section with primary "Resume AI Daily Mission" action
 * This is the main call-to-action for the dashboard
 */
export default function DailyMissionCard() {
  const navigate = useNavigate();

  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
      {/* Daily Mission - Primary Action */}
      <button
        onClick={() => navigate('/')}
        className="group relative overflow-hidden rounded-2xl shadow-xl border-2 border-indigo-200 bg-gradient-to-br from-indigo-500 via-indigo-600 to-indigo-700 p-8 text-white hover:shadow-2xl transition-all active:scale-95"
      >
        {/* Background accent */}
        <div className="absolute inset-0 opacity-10 group-hover:opacity-20 transition-opacity">
          <div className="absolute -top-20 -right-20 w-64 h-64 bg-white rounded-full blur-3xl"></div>
        </div>

        <div className="relative z-10">
          {/* Icon */}
          <div className="inline-block p-4 bg-white/20 rounded-xl mb-4 group-hover:scale-110 transition-transform">
            <Zap size={40} className="text-white drop-shadow-lg" />
          </div>

          {/* Text */}
          <h2 className="text-3xl font-black mb-2 text-white drop-shadow-md">
            Resume AI Daily Mission
          </h2>
          <p className="text-indigo-100 font-semibold mb-1">20 interleaved questions</p>
          <p className="text-indigo-200 text-sm mb-6">
            AI-powered selection optimized for your learning curve
          </p>

          {/* Stats Pills */}
          <div className="flex flex-wrap gap-2 mb-6">
            <div className="px-3 py-1 bg-white/20 rounded-full text-sm font-bold text-white">
              ‚úì Spaced Repetition
            </div>
            <div className="px-3 py-1 bg-white/20 rounded-full text-sm font-bold text-white">
              ‚ö° Adaptive Difficulty
            </div>
          </div>

          {/* CTA Button */}
          <div className="flex items-center gap-3 font-black text-lg group-hover:translate-x-1 transition-transform">
            <span className="text-white drop-shadow-md">Start Now</span>
            <span>‚Üí</span>
          </div>
        </div>

        {/* Bottom accent line */}
        <div className="absolute bottom-0 left-0 right-0 h-1 bg-gradient-to-r from-transparent via-white to-transparent opacity-40 group-hover:opacity-60 transition-opacity"></div>
      </button>

      {/* Browse Forum - Secondary Action */}
      <button
        onClick={() => navigate('/forum')}
        className="group relative overflow-hidden rounded-2xl shadow-lg border-2 border-purple-200 bg-gradient-to-br from-purple-50 to-pink-50 p-8 text-slate-800 hover:shadow-xl transition-all active:scale-95"
      >
        {/* Background accent */}
        <div className="absolute inset-0 opacity-5 group-hover:opacity-10 transition-opacity">
          <div className="absolute -top-20 -right-20 w-64 h-64 bg-purple-400 rounded-full blur-3xl"></div>
        </div>

        <div className="relative z-10">
          {/* Icon */}
          <div className="inline-block p-4 bg-purple-200 rounded-xl mb-4 group-hover:scale-110 transition-transform">
            <BookOpen size={40} className="text-purple-600" />
          </div>

          {/* Text */}
          <h2 className="text-3xl font-black mb-2 text-slate-800">
            Browse Community
          </h2>
          <div className="inline-block px-3 py-1 bg-red-100 rounded-full text-sm font-bold text-red-700 mb-3">
            2 New Discussions
          </div>

          <p className="text-slate-600 font-semibold mb-1">Connect with learners</p>
          <p className="text-slate-600 text-sm mb-6">
            Share insights, ask questions, and learn from peers in the community
          </p>

          {/* CTA Button */}
          <div className="flex items-center gap-3 font-black text-lg group-hover:translate-x-1 transition-transform text-purple-600">
            <span>Visit Forum</span>
            <span>‚Üí</span>
          </div>
        </div>
      </button>
    </div>
  );
}


=== src/components/dashboard/EventCreationModal.jsx ===
import React, { useState, useMemo } from 'react';
import { X, Flag, BookOpen, Calendar, Tag, Layers } from 'lucide-react';
import { motion } from 'framer-motion';
import { calendarService } from '../../services/calendarService';

/**
 * EventCreationModal - UI for adding Major Exams and Small Quizzes
 * FIXED: Title is now optional and auto-generated
 */
export default function EventCreationModal({ userId, questions = [], onClose, onEventCreated }) {
  const [eventType, setEventType] = useState('major_exam'); // 'major_exam' or 'small_quiz'
  const [title, setTitle] = useState('');
  const [date, setDate] = useState('');
  const [topic, setTopic] = useState('');
  const [subtopic, setSubtopic] = useState('');
  const [loading, setLoading] = useState(false);

  // Extract unique topics and subtopics from questions
  const topics = useMemo(() => {
    const topicSet = new Set(questions.map(q => q.Topic).filter(Boolean));
    return ['', ...Array.from(topicSet)].sort();
  }, [questions]);

  const subtopics = useMemo(() => {
    if (!topic) return [''];
    const subtopicSet = new Set(
      questions
        .filter(q => q.Topic === topic && q.Subtopic)
        .map(q => q.Subtopic)
    );
    return ['', ...Array.from(subtopicSet)].sort();
  }, [questions, topic]);

  // Reset subtopic when topic changes
  React.useEffect(() => {
    setSubtopic('');
  }, [topic]);

  const minDate = new Date().toISOString().split('T')[0];

  // Auto-generate title if not provided
  function generateTitle() {
    if (title.trim()) return title.trim();
    
    // Generate title based on event type and topic
    let generatedTitle = '';
    
    if (eventType === 'major_exam') {
      if (topic && subtopic) {
        generatedTitle = `${topic} - ${subtopic} Exam`;
      } else if (topic) {
        generatedTitle = `${topic} Exam`;
      } else {
        generatedTitle = 'Major Exam';
      }
    } else {
      if (topic && subtopic) {
        generatedTitle = `${subtopic} Quiz`;
      } else if (topic) {
        generatedTitle = `${topic} Quiz`;
      } else {
        generatedTitle = 'Quiz';
      }
    }
    
    return generatedTitle;
  }

  async function handleSubmit(e) {
    e.preventDefault();
    
    if (!date) {
      alert('Please select a date for the event.');
      return;
    }

    // Warn if no topic selected
    if (!topic) {
      const proceed = window.confirm(
        'No topic selected. Study plan will include general review from all topics. Continue?'
      );
      if (!proceed) return;
    }

    setLoading(true);
    
    try {
      const eventData = {
        date,
        title: generateTitle(), // Auto-generate if not provided
        topic: topic || null,
        subtopic: subtopic || null
      };

      if (eventType === 'major_exam') {
        await calendarService.addMajorExam(userId, eventData);
      } else {
        await calendarService.addSmallQuiz(userId, eventData);
      }

      onEventCreated();
      onClose();
    } catch (error) {
      console.error('Error creating event:', error);
      alert('Failed to create event. Please try again.');
    } finally {
      setLoading(false);
    }
  }

  return (
    <div 
      className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4"
      onClick={onClose}
    >
      <motion.div
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        onClick={(e) => e.stopPropagation()}
        className="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[90vh] overflow-y-auto"
      >
        {/* Header */}
        <div className="border-b p-6 flex justify-between items-center sticky top-0 bg-white z-10">
          <div>
            <h2 className="text-2xl font-black text-slate-800">Add Event</h2>
            <p className="text-sm text-slate-500 mt-1">Schedule an exam or quiz and get a smart study plan</p>
          </div>
          <button
            onClick={onClose}
            className="p-2 hover:bg-slate-100 rounded-lg transition-all"
          >
            <X size={24} />
          </button>
        </div>

        {/* Form */}
        <form onSubmit={handleSubmit} className="p-6 space-y-6">
          {/* Event Type Selector */}
          <div>
            <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-3">
              Event Type
            </label>
            <div className="grid grid-cols-2 gap-3">
              <button
                type="button"
                onClick={() => setEventType('major_exam')}
                className={`p-4 rounded-xl border-2 transition-all ${
                  eventType === 'major_exam'
                    ? 'border-red-500 bg-red-50'
                    : 'border-slate-200 hover:border-slate-300'
                }`}
              >
                <div className="flex items-center gap-3 mb-2">
                  <div className={`w-10 h-10 rounded-lg flex items-center justify-center ${
                    eventType === 'major_exam' ? 'bg-red-100' : 'bg-slate-100'
                  }`}>
                    <Flag className={eventType === 'major_exam' ? 'text-red-600' : 'text-slate-400'} size={20} />
                  </div>
                  <span className={`font-bold ${
                    eventType === 'major_exam' ? 'text-red-900' : 'text-slate-600'
                  }`}>
                    Major Exam
                  </span>
                </div>
                <div className="text-xs text-slate-500 text-left">
                  10-day study plan with scaled intensity
                </div>
              </button>

              <button
                type="button"
                onClick={() => setEventType('small_quiz')}
                className={`p-4 rounded-xl border-2 transition-all ${
                  eventType === 'small_quiz'
                    ? 'border-amber-500 bg-amber-50'
                    : 'border-slate-200 hover:border-slate-300'
                }`}
              >
                <div className="flex items-center gap-3 mb-2">
                  <div className={`w-10 h-10 rounded-lg flex items-center justify-center ${
                    eventType === 'small_quiz' ? 'bg-amber-100' : 'bg-slate-100'
                  }`}>
                    <BookOpen className={eventType === 'small_quiz' ? 'text-amber-600' : 'text-slate-400'} size={20} />
                  </div>
                  <span className={`font-bold ${
                    eventType === 'small_quiz' ? 'text-amber-900' : 'text-slate-600'
                  }`}>
                    Small Quiz
                  </span>
                </div>
                <div className="text-xs text-slate-500 text-left">
                  3-day focused review plan
                </div>
              </button>
            </div>
          </div>

          {/* Date Input - REQUIRED */}
          <div>
            <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-2">
              Exam/Quiz Date <span className="text-red-500">*</span>
            </label>
            <input
              type="date"
              value={date}
              onChange={(e) => setDate(e.target.value)}
              min={minDate}
              className="w-full px-4 py-3 rounded-lg border-2 border-slate-200 focus:border-indigo-500 focus:outline-none transition-all font-medium"
              required
            />
          </div>

          {/* Topic Selection - OPTIONAL but recommended */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-2 flex items-center gap-1">
                <Tag size={14} />
                Topic <span className="text-slate-400 text-xs font-normal">(Optional)</span>
              </label>
              <select
                value={topic}
                onChange={(e) => {
                  setTopic(e.target.value);
                  setSubtopic('');
                }}
                className="w-full px-4 py-3 rounded-lg border-2 border-slate-200 focus:border-indigo-500 focus:outline-none transition-all font-medium"
              >
                <option value="">All Topics (General Review)</option>
                {topics.slice(1).map((t) => (
                  <option key={t} value={t}>{t}</option>
                ))}
              </select>
              <p className="text-xs text-slate-500 mt-1">
                üí° Study plan will focus on this topic
              </p>
            </div>

            <div>
              <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-2 flex items-center gap-1">
                <Layers size={14} />
                Subtopic <span className="text-slate-400 text-xs font-normal">(Optional)</span>
              </label>
              <select
                value={subtopic}
                onChange={(e) => setSubtopic(e.target.value)}
                disabled={!topic}
                className="w-full px-4 py-3 rounded-lg border-2 border-slate-200 focus:border-indigo-500 focus:outline-none transition-all font-medium disabled:bg-slate-50 disabled:text-slate-400"
              >
                <option value="">All Subtopics</option>
                {subtopics.slice(1).map((s) => (
                  <option key={s} value={s}>{s}</option>
                ))}
              </select>
              {topic && (
                <p className="text-xs text-slate-500 mt-1">
                  üí° Narrow down to specific subtopic
                </p>
              )}
            </div>
          </div>

          {/* Title Input - OPTIONAL (auto-generated) */}
          <div>
            <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-2">
              Custom Title <span className="text-slate-400 text-xs font-normal">(Optional - auto-generated if empty)</span>
            </label>
            <input
              type="text"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder={`Auto: ${generateTitle()}`}
              className="w-full px-4 py-3 rounded-lg border-2 border-slate-200 focus:border-indigo-500 focus:outline-none transition-all font-medium"
            />
            <p className="text-xs text-slate-500 mt-1">
              Leave blank to auto-generate based on event type and topic
            </p>
          </div>

          {/* Study Plan Preview */}
          <div className={`p-4 rounded-xl border-2 ${
            eventType === 'major_exam' 
              ? 'bg-red-50 border-red-200' 
              : 'bg-amber-50 border-amber-200'
          }`}>
            <div className="flex items-center gap-2 mb-3">
              <Calendar className={eventType === 'major_exam' ? 'text-red-600' : 'text-amber-600'} size={18} />
              <span className={`font-bold text-sm ${
                eventType === 'major_exam' ? 'text-red-900' : 'text-amber-900'
              }`}>
                Auto-Generated Study Plan
              </span>
            </div>
            {eventType === 'major_exam' ? (
              <ul className="space-y-1 text-xs text-red-700">
                <li>‚Ä¢ <strong>10-7 days before:</strong> 10 MCQs/day (Warm-up)</li>
                <li>‚Ä¢ <strong>6-4 days before:</strong> 20 MCQs/day (Consolidation)</li>
                <li>‚Ä¢ <strong>3-1 days before:</strong> 40 MCQs/day (Sprint Intensity)</li>
              </ul>
            ) : (
              <ul className="space-y-1 text-xs text-amber-700">
                <li>‚Ä¢ <strong>3 days before:</strong> 5 MCQs (Initial Review)</li>
                <li>‚Ä¢ <strong>2 days before:</strong> 10 MCQs (Topic Focus)</li>
                <li>‚Ä¢ <strong>1 day before:</strong> 15 MCQs + Mistake Review (Final Polish)</li>
              </ul>
            )}
            {topic && (
              <p className="text-xs font-bold mt-2 text-slate-700">
                üìö All sessions will focus on: {topic}
                {subtopic && ` ‚Üí ${subtopic}`}
              </p>
            )}
          </div>

          {/* Info Box */}
          <div className="p-4 rounded-lg bg-blue-50 border border-blue-200">
            <p className="text-sm text-blue-900">
              <strong>‚ú® Smart Study Plan:</strong> Daily study suggestions will be created automatically. 
              Each suggestion is clickable and will start a quiz with questions filtered by your selected 
              topic{subtopic && ' and subtopic'}.
              {!topic && ' Without a topic, questions will be randomly selected from all available topics.'}
            </p>
          </div>

          {/* Submit Buttons */}
          <div className="flex gap-3 pt-4 border-t">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 px-6 py-3 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-xl font-bold transition-all"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={loading}
              className={`flex-1 px-6 py-3 rounded-xl font-bold transition-all text-white ${
                eventType === 'major_exam'
                  ? 'bg-red-600 hover:bg-red-700'
                  : 'bg-amber-600 hover:bg-amber-700'
              } disabled:opacity-50 disabled:cursor-not-allowed`}
            >
              {loading ? 'Creating...' : `Create Event & Study Plan`}
            </button>
          </div>
        </form>
      </motion.div>
    </div>
  );
}

=== src/components/dashboard/MasteryProgressHub.jsx ===
import React, { useMemo } from 'react';
import { BarChart3, Zap, Target } from 'lucide-react';
import { getMasteryState, calculateMasteryStats } from '../../utils/masteryHelper';

/**
 * MasteryProgressHub: Displays the syllabus progress with Unseen/In-Progress/Mastered breakdown
 * Replaces the 5 basic stat boxes with a more meaningful visual
 */
export default function MasteryProgressHub({ userProfile, mistakes }) {
  const stats = useMemo(() => calculateMasteryStats(userProfile, mistakes || []), [userProfile, mistakes]);

  const total = stats.unseenCount + stats.inProgressCount + stats.masteredCount;
  const unseenPct = total > 0 ? Math.round((stats.unseenCount / total) * 100) : 0;
  const inProgressPct = total > 0 ? Math.round((stats.inProgressCount / total) * 100) : 0;
  const masteredPct = total > 0 ? Math.round((stats.masteredCount / total) * 100) : 0;

  return (
    <div className="bg-white rounded-2xl shadow-lg border-2 border-indigo-100 p-8">
      {/* Header */}
      <div className="flex items-center gap-3 mb-6">
        <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-indigo-100 to-indigo-200 flex items-center justify-center">
          <BarChart3 className="text-indigo-600" size={28} />
        </div>
        <div>
          <h2 className="text-2xl font-black text-slate-800">Mastery Health Bar</h2>
          <p className="text-sm text-slate-500 mt-1">Based on the Rule of 3 system</p>
        </div>
      </div>

      {/* Main Progress Bar with Stacked Sections */}
      <div className="mb-8">
        <div className="flex items-center justify-between mb-2">
          <h3 className="text-lg font-bold text-slate-700">Syllabus Coverage</h3>
          <span className="text-sm font-semibold text-slate-600">{total} Topics Tracked</span>
        </div>

        {/* 3-Segment Progress Bar */}
        <div className="flex h-6 rounded-full overflow-hidden bg-slate-100 shadow-inner border border-slate-200">
          {/* Red: Unseen */}
          <div
            className="bg-red-500 flex items-center justify-center transition-all duration-300"
            style={{ width: `${unseenPct}%` }}
            title={`${unseenPct}% Unseen (${stats.unseenCount} topics)`}
          >
            {unseenPct > 5 && <span className="text-white text-xs font-bold">{unseenPct}%</span>}
          </div>

          {/* Amber: In-Progress */}
          <div
            className="bg-amber-400 flex items-center justify-center transition-all duration-300"
            style={{ width: `${inProgressPct}%` }}
            title={`${inProgressPct}% Improving (${stats.inProgressCount} topics)`}
          >
            {inProgressPct > 5 && <span className="text-white text-xs font-bold">{inProgressPct}%</span>}
          </div>

          {/* Green: Mastered */}
          <div
            className="bg-green-500 flex items-center justify-center transition-all duration-300"
            style={{ width: `${masteredPct}%` }}
            title={`${masteredPct}% Mastered (${stats.masteredCount} topics)`}
          >
            {masteredPct > 5 && <span className="text-white text-xs font-bold">{masteredPct}%</span>}
          </div>
        </div>
      </div>

      {/* Legend & Stats */}
      <div className="grid grid-cols-3 gap-4">
        {/* Unseen */}
        <div className="bg-red-50 rounded-xl p-4 border-l-4 border-red-500">
          <div className="flex items-center gap-2 mb-2">
            <div className="w-3 h-3 rounded-full bg-red-500"></div>
            <span className="text-xs font-bold text-red-700 uppercase tracking-wide">New</span>
          </div>
          <div className="text-3xl font-black text-red-600">{stats.unseenCount}</div>
          <p className="text-xs text-red-600 mt-1">Not yet attempted</p>
        </div>

        {/* In-Progress */}
        <div className="bg-amber-50 rounded-xl p-4 border-l-4 border-amber-400">
          <div className="flex items-center gap-2 mb-2">
            <div className="w-3 h-3 rounded-full bg-amber-400"></div>
            <span className="text-xs font-bold text-amber-700 uppercase tracking-wide">Improving</span>
          </div>
          <div className="text-3xl font-black text-amber-600">{stats.inProgressCount}</div>
          <p className="text-xs text-amber-600 mt-1">1-2 correct answers</p>
        </div>

        {/* Mastered */}
        <div className="bg-green-50 rounded-xl p-4 border-l-4 border-green-500">
          <div className="flex items-center gap-2 mb-2">
            <div className="w-3 h-3 rounded-full bg-green-500"></div>
            <span className="text-xs font-bold text-green-700 uppercase tracking-wide">Mastered</span>
          </div>
          <div className="text-3xl font-black text-green-600">{stats.masteredCount}</div>
          <p className="text-xs text-green-600 mt-1">3+ correct answers ‚úì</p>
        </div>
      </div>

      {/* Legacy Stats Row */}
      <div className="grid grid-cols-3 gap-4 mt-6 pt-6 border-t border-slate-200">
        <div className="text-center">
          <div className="text-sm text-slate-600 font-medium mb-1">Total Attempts</div>
          <div className="text-2xl font-black text-slate-800">{userProfile?.totalAttempts || 0}</div>
        </div>
        <div className="text-center">
          <div className="text-sm text-slate-600 font-medium mb-1">Overall Accuracy</div>
          <div className="text-2xl font-black text-slate-800">
            {userProfile?.totalQuestions > 0 ? Math.round((userProfile.totalCorrect / userProfile.totalQuestions) * 100) : 0}%
          </div>
        </div>
        <div className="text-center">
          <div className="text-sm text-slate-600 font-medium mb-1">Questions Solved</div>
          <div className="text-2xl font-black text-slate-800">{userProfile?.totalQuestions || 0}</div>
        </div>
      </div>
    </div>
  );
}


=== src/components/dashboard/PriorityReviewSection.jsx ===
import React, { useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { AlertTriangle, Play, ArrowRight, Zap } from 'lucide-react';
import { getTopMistakesByPriority, getMasteryState } from '../../utils/masteryHelper';

/**
 * PriorityReviewSection: Shows top 3 urgent mistakes based on ISRS priority
 * Displays with Quick Fix button to practice immediately
 */
export default function PriorityReviewSection({ mistakes, recentTopics = [] }) {
  const navigate = useNavigate();
  const topMistakes = useMemo(() => getTopMistakesByPriority(mistakes || [], recentTopics, 3), [mistakes, recentTopics]);

  if (!topMistakes || topMistakes.length === 0) {
    return (
      <div className="bg-gradient-to-br from-slate-50 to-slate-100 rounded-2xl shadow-lg border-2 border-slate-200 p-6">
        <div className="flex items-center gap-3 mb-4">
          <div className="w-12 h-12 rounded-xl bg-slate-200 flex items-center justify-center">
            <Zap className="text-slate-600" size={28} />
          </div>
          <h3 className="text-xl font-black text-slate-800">Priority Review</h3>
        </div>
        <p className="text-slate-600 text-center py-8">
          No mistakes tracked yet. Complete quizzes and log your mistakes to get personalized review recommendations!
        </p>
      </div>
    );
  }

  const handleQuickFix = (questionId) => {
    // Navigate to quiz engine with specific question
    navigate('/', { state: { focusQuestionId: questionId } });
  };

  return (
    <div className="bg-white rounded-2xl shadow-lg border-2 border-slate-100 p-6">
      {/* Header */}
      <div className="flex items-center gap-3 mb-6">
        <div className="w-12 h-12 rounded-xl bg-red-100 flex items-center justify-center">
          <AlertTriangle className="text-red-600" size={28} />
        </div>
        <div>
          <h3 className="text-xl font-black text-slate-800">Priority Review</h3>
          <p className="text-xs text-slate-500 mt-1">Top 3 Urgent Mistakes (ISRS Algorithm)</p>
        </div>
      </div>

      {/* Mistakes List */}
      <div className="space-y-3">
        {topMistakes.map((mistake, index) => {
          const state = getMasteryState(mistake.correctCount || 0);
          const priority = mistake.masteryPriority || 0;
          const priorityLabel = priority > 8 ? 'Critical' : priority > 5 ? 'High' : 'Medium';
          const priorityColor = priority > 8 ? 'text-red-700 bg-red-50' : priority > 5 ? 'text-orange-700 bg-orange-50' : 'text-yellow-700 bg-yellow-50';

          return (
            <div
              key={mistake.questionId || index}
              className={`rounded-xl p-4 border-l-4 transition-all $${state.borderClass} ${state.bgClass}`}
            >
              {/* Top Row: Rank + Priority + Status */}
              <div className="flex items-start justify-between mb-2">
                <div className="flex items-center gap-2">
                  <span className="text-sm font-bold text-slate-600">#{index + 1}</span>
                  <span className={`px-2 py-1 rounded-full text-xs font-bold ${priorityColor}`}>
                    {priorityLabel} Priority
                  </span>
                  <span className={`px-2 py-1 rounded-full text-xs font-bold ${state.badgeClass}`}>
                    {state.label}
                  </span>
                </div>
              </div>

              {/* Question Preview */}
              <div className="mb-3">
                <p className="text-sm font-semibold text-slate-700 line-clamp-2">
                  {mistake.Question || 'Question text not available'}
                </p>
                <div className="flex items-center gap-2 mt-2 text-xs text-slate-600">
                  <span className="font-bold text-slate-700">{mistake.Topic}</span>
                  {mistake.errorType && (
                    <>
                      <span>‚Ä¢</span>
                      <span className="capitalize">{mistake.errorType}</span>
                    </>
                  )}
                </div>
              </div>

              {/* Stats & Button */}
              <div className="flex items-center justify-between">
                <div className="flex gap-4 text-xs text-slate-600">
                  <span>Attempts: <span className="font-bold">{mistake.attemptCount || 1}</span></span>
                  <span>Correct: <span className="font-bold">{mistake.correctCount || 0}</span></span>
                </div>
                <button
                  onClick={() => handleQuickFix(mistake.questionId)}
                  className="flex items-center gap-2 px-3 py-2 bg-gradient-to-r from-red-500 to-orange-500 text-white rounded-lg font-bold text-sm hover:shadow-lg hover:from-red-600 hover:to-orange-600 transition-all active:scale-95"
                >
                  <Play size={14} />
                  Quick Fix
                </button>
              </div>
            </div>
          );
        })}
      </div>

      {/* CTA Footer */}
      <div className="mt-6 pt-4 border-t border-slate-200">
        <button
          onClick={() => navigate('/notebook')}
          className="w-full flex items-center justify-center gap-2 px-4 py-3 bg-slate-100 hover:bg-slate-200 text-slate-800 rounded-xl font-bold transition-all"
        >
          View Full Mistake Notebook
          <ArrowRight size={16} />
        </button>
      </div>
    </div>
  );
}


=== src/components/dashboard/SmartMonthlyCalendar.jsx ===
import React, { useState, useEffect, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { ChevronLeft, ChevronRight, Plus, Flag, Calendar as CalendarIcon, BookOpen, Brain, CheckCircle, Trash2, X, Sparkles, ThumbsUp, ThumbsDown, Play, Info } from 'lucide-react';
import { calendarService, EVENT_TYPES } from '../../services/calendarService';
import { performanceService } from '../../services/performanceService';
import { quizStorage } from '../../utils/quizStorage';
import { motion, AnimatePresence } from 'framer-motion';
import SpacedRepetitionModal from './SpacedRepetitionModal';

/**
 * SmartMonthlyCalendar - Real monthly calendar with exam tracking, study plans, spaced repetition, and AI recommendations
 * FIXED: Better study suggestion details and validation, enhanced delete functionality with event type
 * ADDED: Spaced repetition modal for review sessions
 */
export default function SmartMonthlyCalendar({ userId, questions = [], onAddEvent }) {
  const navigate = useNavigate();
  const [currentDate, setCurrentDate] = useState(new Date());
  const [calendarData, setCalendarData] = useState({});
  const [loading, setLoading] = useState(true);
  const [selectedDate, setSelectedDate] = useState(null);
  const [hoveredDate, setHoveredDate] = useState(null);
  const [aiRecommendations, setAIRecommendations] = useState([]);
  const [suggestionPreview, setSuggestionPreview] = useState(null);
  const [reviewModal, setReviewModal] = useState(null);
  
  const year = currentDate.getFullYear();
  const month = currentDate.getMonth();
  
  // Load calendar data and AI recommendations
  useEffect(() => {
    loadCalendarData();
    loadAIRecommendations();
  }, [userId, year, month]);

  async function loadCalendarData() {
    if (!userId) return;
    
    try {
      setLoading(true);
      const data = await calendarService.getCalendarData(userId, year, month);
      setCalendarData(data);
    } catch (error) {
      console.error('Error loading calendar data:', error);
    } finally {
      setLoading(false);
    }
  }

  async function loadAIRecommendations() {
    if (!userId) return;
    
    try {
      const recommendations = await performanceService.getRecommendations(userId);
      setAIRecommendations(recommendations);
    } catch (error) {
      console.error('Error loading AI recommendations:', error);
    }
  }

  // Generate calendar grid
  const calendarGrid = useMemo(() => {
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startingDayOfWeek = firstDay.getDay();
    const daysInMonth = lastDay.getDate();
    
    const grid = [];
    let week = [];
    
    // Add empty cells for days before month starts
    for (let i = 0; i < startingDayOfWeek; i++) {
      week.push(null);
    }
    
    // Add all days in month
    for (let day = 1; day <= daysInMonth; day++) {
      week.push(day);
      
      if (week.length === 7) {
        grid.push(week);
        week = [];
      }
    }
    
    // Add remaining days to complete the last week
    if (week.length > 0) {
      while (week.length < 7) {
        week.push(null);
      }
      grid.push(week);
    }
    
    return grid;
  }, [year, month]);

  const monthName = new Date(year, month, 1).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
  const today = new Date().toISOString().split('T')[0];

  function prevMonth() {
    setCurrentDate(new Date(year, month - 1, 1));
  }

  function nextMonth() {
    setCurrentDate(new Date(year, month + 1, 1));
  }

  function getDateString(day) {
    if (!day) return null;
    return new Date(year, month, day).toISOString().split('T')[0];
  }

  function getDayEvents(day) {
    const dateStr = getDateString(day);
    if (!dateStr) return null;
    return calendarData[dateStr] || null;
  }

  function isToday(day) {
    return getDateString(day) === today;
  }

  function isPast(day) {
    if (!day) return false;
    return getDateString(day) < today;
  }

  // Get available questions for a suggestion
  function getAvailableQuestions(suggestion) {
    if (!questions || questions.length === 0) {
      return { filtered: [], count: 0 };
    }

    let filtered = [...questions];
    
    if (suggestion.topic) {
      filtered = filtered.filter(q => q.Topic === suggestion.topic);
    }
    
    if (suggestion.subtopic) {
      filtered = filtered.filter(q => q.Subtopic === suggestion.subtopic);
    }
    
    return {
      filtered: filtered.slice(0, suggestion.questionCount),
      count: filtered.length,
      requested: suggestion.questionCount
    };
  }

  // Preview suggestion details
  function handleSuggestionPreview(suggestion, event) {
    event?.stopPropagation();
    const questionInfo = getAvailableQuestions(suggestion);
    setSuggestionPreview({ ...suggestion, questionInfo });
  }

  async function handleAcceptRecommendation(recommendation, event) {
    event?.stopPropagation();
    
    try {
      // Create calendar event from recommendation
      await calendarService.createAIRecommendationEvent(userId, recommendation);
      
      // Reload calendar and recommendations
      await loadCalendarData();
      await loadAIRecommendations();
    } catch (error) {
      console.error('Error accepting recommendation:', error);
      alert('Failed to add recommendation to calendar.');
    }
  }

  async function handleDismissRecommendation(recommendationId, event) {
    event?.stopPropagation();
    
    try {
      await performanceService.dismissRecommendation(userId, recommendationId);
      await loadAIRecommendations();
    } catch (error) {
      console.error('Error dismissing recommendation:', error);
    }
  }

  async function handleAIRecommendationClick(aiRec) {
    try {
      let filteredQuestions = questions;
      
      if (aiRec.topic) {
        filteredQuestions = filteredQuestions.filter(q => q.Topic === aiRec.topic);
      }
      
      if (aiRec.subtopic) {
        filteredQuestions = filteredQuestions.filter(q => q.Subtopic === aiRec.subtopic);
      }

      const selectedQuestions = filteredQuestions
        .sort(() => Math.random() - 0.5)
        .slice(0, Math.min(aiRec.questionCount, filteredQuestions.length));

      if (selectedQuestions.length === 0) {
        alert(`No questions available for ${aiRec.topic || 'this topic'}${aiRec.subtopic ? ' - ' + aiRec.subtopic : ''}.`);
        return;
      }

      quizStorage.clearQuizData();
      quizStorage.saveSelectedQuestions(selectedQuestions);
      localStorage.setItem('quiz_mode', 'ai-recommendation');
      localStorage.setItem('quiz_event_id', aiRec.id);
      localStorage.setItem('quiz_timer_enabled', 'true');
      navigate('/quiz');
    } catch (error) {
      console.error('Error starting AI recommendation session:', error);
      alert('Failed to start study session. Please try again.');
    }
  }

  async function handleStudySuggestionClick(suggestion) {
    try {
      // Check if questions are loaded
      if (!questions || questions.length === 0) {
        alert('Questions are still loading. Please wait a moment and try again.');
        return;
      }

      // Filter questions by topic/subtopic if specified
      let filteredQuestions = [...questions];
      
      if (suggestion.topic) {
        filteredQuestions = filteredQuestions.filter(q => q.Topic === suggestion.topic);
      }
      
      if (suggestion.subtopic) {
        filteredQuestions = filteredQuestions.filter(q => q.Subtopic === suggestion.subtopic);
      }

      if (filteredQuestions.length === 0) {
        alert(
          `No questions available for ${suggestion.topic || 'all topics'}${
            suggestion.subtopic ? ' - ' + suggestion.subtopic : ''
          }.\n\nPlease check that your question database includes this topic.`
        );
        return;
      }

      // Select random questions up to the suggested count
      const selectedQuestions = filteredQuestions
        .sort(() => Math.random() - 0.5)
        .slice(0, Math.min(suggestion.questionCount, filteredQuestions.length));

      // Save to quiz storage and navigate
      quizStorage.clearQuizData();
      quizStorage.saveSelectedQuestions(selectedQuestions);
      localStorage.setItem('quiz_mode', 'study-plan');
      localStorage.setItem('quiz_event_id', suggestion.id);
      localStorage.setItem('quiz_event_phase', suggestion.phase || '');
      localStorage.setItem('quiz_timer_enabled', 'true');
      navigate('/quiz');
    } catch (error) {
      console.error('Error starting study session:', error);
      alert('Failed to start study session. Please try again.');
    }
  }

  /**
   * UPDATED: Spaced repetition click handler - opens modal instead of direct navigation
   */
  function handleSpacedRepetitionClick(repetition, event) {
    event?.stopPropagation();
    
    const dateStr = getDateString(parseInt(repetition.date?.split('-')[2]) || new Date().getDate());
    const allRepsForDay = calendarData[dateStr]?.repetitions || [];
    
    setReviewModal({
      repetition,
      allRepetitions: allRepsForDay
    });
  }

  /**
   * NEW: Handle starting review from modal
   */
  async function handleStartReview(reviewMode, questionIds) {
    try {
      const reviewQuestions = questions.filter(q => questionIds.includes(q.ID));
      
      if (reviewQuestions.length === 0) {
        alert('Questions not found in database.');
        return;
      }

      quizStorage.clearQuizData();
      quizStorage.saveSelectedQuestions(reviewQuestions);
      localStorage.setItem('quiz_mode', 'spaced-repetition');
      localStorage.setItem('quiz_review_mode', reviewMode);
      localStorage.setItem('quiz_event_ids', JSON.stringify(
        reviewModal.allRepetitions
          .filter(r => questionIds.includes(r.questionId))
          .map(r => r.id)
      ));
      localStorage.setItem('quiz_timer_enabled', 'true');
      setReviewModal(null);
      navigate('/quiz');
    } catch (error) {
      console.error('Error starting review:', error);
      alert('Failed to start review. Please try again.');
    }
  }

  /**
   * UPDATED: Delete event with event type for better user confirmation
   */
  async function handleDeleteEvent(eventId, eventType, event) {
    event.stopPropagation();
    
    const eventTypeLabel = eventType === EVENT_TYPES.MAJOR_EXAM ? 'Major Exam' : 
                          eventType === EVENT_TYPES.SMALL_QUIZ ? 'Small Quiz' : 'Event';
    
    if (!window.confirm(`Delete this ${eventTypeLabel}? This will also remove all linked study suggestions and reviews.`)) {
      return;
    }
    
    try {
      await calendarService.deleteEvent(eventId, true); // true = cascade delete
      await loadCalendarData();
      setSelectedDate(null);
      console.log('‚úÖ Event deleted successfully');
    } catch (error) {
      console.error('‚ùå Error deleting event:', error);
      alert('Failed to delete event: ' + error.message);
    }
  }

  // Render day cell content
  function renderDayCell(day) {
    if (!day) return null;
    
    const dateStr = getDateString(day);
    const events = getDayEvents(day);
    const isSelectedDate = selectedDate === dateStr;
    const isHovered = hoveredDate === dateStr;
    const isTodayDate = isToday(day);
    const isPastDate = isPast(day);
    
    const hasExam = events?.exams?.length > 0;
    const hasQuiz = events?.quizzes?.length > 0;
    const hasSuggestions = events?.suggestions?.length > 0;
    const hasRepetitions = events?.repetitions?.length > 0;
    const hasCompletions = events?.completions?.length > 0;
    const hasAIRecommendations = events?.aiRecommendations?.length > 0;
    
    const totalEvents = (events?.exams?.length || 0) + 
                       (events?.quizzes?.length || 0) + 
                       (events?.suggestions?.length || 0) + 
                       (events?.repetitions?.length || 0) +
                       (events?.aiRecommendations?.length || 0);

    return (
      <div className="flex flex-col h-full p-1">
        {/* Day number */}
        <div className={`text-sm font-bold mb-1 ${
          isTodayDate ? 'text-blue-600' : isPastDate ? 'text-slate-400' : 'text-slate-700'
        }`}>
          {day}
        </div>
        
        {/* Event markers */}
        <div className="flex-1 flex flex-col gap-0.5 overflow-hidden">
          {/* Major Exam */}
          {hasExam && events.exams.map((exam, idx) => (
            <div
              key={`exam-${idx}`}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-red-100 text-red-700 font-semibold hover:bg-red-200 transition-colors cursor-pointer group relative"
              onClick={(e) => {
                e.stopPropagation();
                setSelectedDate(dateStr);
              }}
            >
              <Flag size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">{exam.title}</span>
              {!exam.completed && (
                <button
                  onClick={(e) => handleDeleteEvent(exam.id, EVENT_TYPES.MAJOR_EXAM, e)}
                  className="opacity-0 group-hover:opacity-100 transition-opacity"
                >
                  <X size={10} />
                </button>
              )}
            </div>
          ))}
          
          {/* Small Quiz */}
          {hasQuiz && events.quizzes.map((quiz, idx) => (
            <div
              key={`quiz-${idx}`}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-amber-100 text-amber-700 font-semibold hover:bg-amber-200 transition-colors cursor-pointer group relative"
              onClick={(e) => {
                e.stopPropagation();
                setSelectedDate(dateStr);
              }}
            >
              <BookOpen size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">{quiz.title}</span>
              {!quiz.completed && (
                <button
                  onClick={(e) => handleDeleteEvent(quiz.id, EVENT_TYPES.SMALL_QUIZ, e)}
                  className="opacity-0 group-hover:opacity-100 transition-opacity"
                >
                  <X size={10} />
                </button>
              )}
            </div>
          ))}
          
          {/* Study Suggestions */}
          {hasSuggestions && events.suggestions.slice(0, 2).map((suggestion, idx) => (
            <button
              key={`suggestion-${idx}`}
              onClick={(e) => {
                e.stopPropagation();
                handleSuggestionPreview(suggestion, e);
              }}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-blue-100 text-blue-700 font-semibold hover:bg-blue-200 transition-colors group"
            >
              <CalendarIcon size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">{suggestion.questionCount} MCQs</span>
              {suggestion.completed && <CheckCircle size={10} className="text-blue-600" />}
            </button>
          ))}
          
          {/* UPDATED: Spaced Repetition */}
          {hasRepetitions && events.repetitions.slice(0, 1).map((rep, idx) => (
            <button
              key={`rep-${idx}`}
              onClick={(e) => {
                e.stopPropagation();
                handleSpacedRepetitionClick(rep, e);
              }}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-purple-100 text-purple-700 font-semibold hover:bg-purple-200 transition-colors"
            >
              <Brain size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">Review</span>
              {rep.completed && <CheckCircle size={10} className="text-purple-600" />}
            </button>
          ))}

          {/* AI Recommendations */}
          {hasAIRecommendations && events.aiRecommendations.slice(0, 1).map((aiRec, idx) => (
            <button
              key={`ai-${idx}`}
              onClick={(e) => {
                e.stopPropagation();
                handleAIRecommendationClick(aiRec);
              }}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-gradient-to-r from-purple-100 to-pink-100 text-purple-700 font-semibold hover:from-purple-200 hover:to-pink-200 transition-colors border border-purple-300"
            >
              <Sparkles size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">AI: {aiRec.questionCount} MCQs</span>
              {aiRec.completed && <CheckCircle size={10} className="text-purple-600" />}
            </button>
          ))}
          
          {/* Overflow indicator */}
          {totalEvents > 3 && (
            <button
              onClick={(e) => {
                e.stopPropagation();
                setSelectedDate(dateStr);
              }}
              className="text-xs text-slate-500 hover:text-slate-700 font-semibold px-1"
            >
              +{totalEvents - 3} more
            </button>
          )}
          
          {/* Completion dots */}
          {hasCompletions && events.completions.length <= 3 && (
            <div className="flex gap-0.5 mt-auto">
              {events.completions.slice(0, 3).map((comp, idx) => (
                <div
                  key={`comp-${idx}`}
                  className="w-1.5 h-1.5 rounded-full bg-green-500"
                  title={`Completed: ${comp.questionCount} questions`}
                />
              ))}
            </div>
          )}
          {hasCompletions && events.completions.length > 3 && (
            <div className="text-xs text-green-600 font-bold px-1">
              ‚úì {events.completions.length}
            </div>
          )}
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-2xl shadow-lg border-2 border-slate-100 p-6">
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center gap-3">
          <div className="w-12 h-12 rounded-xl bg-blue-100 flex items-center justify-center">
            <CalendarIcon className="text-blue-600" size={28} />
          </div>
          <div>
            <h3 className="text-xl font-black text-slate-800">Smart Study Calendar</h3>
            <p className="text-xs text-slate-500 mt-1">{monthName}</p>
          </div>
        </div>
        
        <div className="flex items-center gap-2">
          <button
            onClick={prevMonth}
            className="p-2 hover:bg-slate-100 rounded-lg transition-all"
          >
            <ChevronLeft size={20} className="text-slate-600" />
          </button>
          <button
            onClick={nextMonth}
            className="p-2 hover:bg-slate-100 rounded-lg transition-all"
          >
            <ChevronRight size={20} className="text-slate-600" />
          </button>
          <button
            onClick={onAddEvent}
            className="ml-2 px-4 py-2 bg-indigo-600 text-white rounded-lg font-bold hover:bg-indigo-700 transition-all flex items-center gap-2"
          >
            <Plus size={16} />
            Add Event
          </button>
        </div>
      </div>

      {/* AI Recommendations Panel */}
      {aiRecommendations.length > 0 && (
        <div className="mb-6 p-4 rounded-xl bg-gradient-to-r from-purple-50 to-pink-50 border-2 border-purple-200">
          <div className="flex items-center gap-2 mb-3">
            <Sparkles className="text-purple-600" size={24} />
            <h4 className="text-lg font-black text-purple-900">AI Study Recommendations</h4>
            <span className="ml-auto text-xs font-bold text-purple-600 bg-white px-2 py-1 rounded-full">
              {aiRecommendations.length} suggestions
            </span>
          </div>
          
          <div className="space-y-2">
            {aiRecommendations.slice(0, 3).map((rec) => (
              <div
                key={rec.id}
                className="bg-white rounded-lg p-3 border border-purple-200"
              >
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <div className="flex items-center gap-2 mb-1">
                      <span className={`px-2 py-0.5 rounded text-xs font-bold ${
                        rec.priority === 'HIGH' ? 'bg-red-100 text-red-700' :
                        rec.priority === 'MEDIUM' ? 'bg-amber-100 text-amber-700' :
                        'bg-blue-100 text-blue-700'
                      }`}>
                        {rec.priority}
                      </span>
                      <span className="font-bold text-sm text-slate-800">
                        {rec.subtopic}
                      </span>
                    </div>
                    <p className="text-xs text-slate-600">{rec.reason}</p>
                    <div className="flex gap-2 mt-2 text-xs text-slate-500">
                      <span>üìÖ Suggested: {new Date(rec.suggestedDate).toLocaleDateString()}</span>
                      <span>‚Ä¢</span>
                      <span>üìä Current: {rec.currentAccuracy}%</span>
                    </div>
                  </div>
                  
                  <div className="flex gap-1 ml-3">
                    <button
                      onClick={(e) => handleAcceptRecommendation(rec, e)}
                      className="p-2 bg-purple-100 hover:bg-purple-200 rounded-lg transition-all"
                      title="Add to calendar"
                    >
                      <ThumbsUp size={16} className="text-purple-600" />
                    </button>
                    <button
                      onClick={(e) => handleDismissRecommendation(rec.id, e)}
                      className="p-2 bg-slate-100 hover:bg-slate-200 rounded-lg transition-all"
                      title="Dismiss"
                    >
                      <ThumbsDown size={16} className="text-slate-600" />
                    </button>
                  </div>
                </div>
              </div>
            ))}
          </div>
          
          {aiRecommendations.length > 3 && (
            <div className="text-center mt-3">
              <button
                className="text-sm font-bold text-purple-600 hover:text-purple-700"
                onClick={() => {/* Show all recommendations modal */}}
              >
                View all {aiRecommendations.length} recommendations ‚Üí
              </button>
            </div>
          )}
        </div>
      )}

      {/* Legend */}
      <div className="grid grid-cols-2 md:grid-cols-6 gap-2 mb-4 text-xs">
        <div className="flex items-center gap-1.5">
          <Flag size={12} className="text-red-600" />
          <span className="text-slate-600 font-semibold">Major Exam</span>
        </div>
        <div className="flex items-center gap-1.5">
          <BookOpen size={12} className="text-amber-600" />
          <span className="text-slate-600 font-semibold">Quiz</span>
        </div>
        <div className="flex items-center gap-1.5">
          <CalendarIcon size={12} className="text-blue-600" />
          <span className="text-slate-600 font-semibold">Study Plan</span>
        </div>
        <div className="flex items-center gap-1.5">
          <Brain size={12} className="text-purple-600" />
          <span className="text-slate-600 font-semibold">Review</span>
        </div>
        <div className="flex items-center gap-1.5">
          <Sparkles size={12} className="text-purple-600" />
          <span className="text-slate-600 font-semibold">AI Suggestion</span>
        </div>
        <div className="flex items-center gap-1.5">
          <div className="w-2 h-2 rounded-full bg-green-500" />
          <span className="text-slate-600 font-semibold">Completed</span>
        </div>
      </div>

      {/* Calendar Grid */}
      <div className="border-2 border-slate-200 rounded-lg overflow-hidden">
        {/* Day headers */}
        <div className="grid grid-cols-7 bg-slate-50 border-b-2 border-slate-200">
          {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day) => (
            <div
              key={day}
              className="p-2 text-center text-sm font-black text-slate-600 uppercase tracking-wider"
            >
              {day}
            </div>
          ))}
        </div>

        {/* Calendar body */}
        {calendarGrid.map((week, weekIdx) => (
          <div key={weekIdx} className="grid grid-cols-7 border-b border-slate-200 last:border-b-0">
            {week.map((day, dayIdx) => (
              <div
                key={dayIdx}
                onMouseEnter={() => day && setHoveredDate(getDateString(day))}
                onMouseLeave={() => setHoveredDate(null)}
                onClick={() => day && setSelectedDate(getDateString(day))}
                className={`min-h-[100px] border-r border-slate-200 last:border-r-0 transition-all cursor-pointer ${
                  day ? 'hover:bg-slate-50' : 'bg-slate-50/30'
                } ${
                  isToday(day) ? 'bg-blue-50 ring-2 ring-inset ring-blue-400' : ''
                } ${
                  isPast(day) ? 'opacity-60' : ''
                }`}
              >
                {renderDayCell(day)}
              </div>
            ))}
          </div>
        ))}
      </div>

      {/* Suggestion Preview Modal */}
      <AnimatePresence>
        {suggestionPreview && (
          <div 
            className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4"
            onClick={() => setSuggestionPreview(null)}
          >
            <motion.div
              initial={{ opacity: 0, scale: 0.95 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.95 }}
              onClick={(e) => e.stopPropagation()}
              className="bg-white rounded-2xl shadow-2xl max-w-lg w-full"
            >
              <div className="p-6 border-b flex justify-between items-center">
                <h3 className="text-lg font-black text-slate-800">Study Session Preview</h3>
                <button
                  onClick={() => setSuggestionPreview(null)}
                  className="p-2 hover:bg-slate-100 rounded-lg transition-all"
                >
                  <X size={20} />
                </button>
              </div>
              
              <div className="p-6 space-y-4">
                {/* Session Info */}
                <div className="p-4 rounded-lg bg-blue-50 border-2 border-blue-200">
                  <h4 className="font-bold text-blue-900 mb-2">{suggestionPreview.title}</h4>
                  <div className="space-y-1 text-sm text-blue-800">
                    <div className="flex items-center gap-2">
                      <CalendarIcon size={16} />
                      <span>Phase: <strong>{suggestionPreview.phase}</strong></span>
                    </div>
                    {suggestionPreview.topic && (
                      <div className="flex items-center gap-2">
                        <BookOpen size={16} />
                        <span>
                          <strong>{suggestionPreview.topic}</strong>
                          {suggestionPreview.subtopic && ` ‚Üí ${suggestionPreview.subtopic}`}
                        </span>
                      </div>
                    )}
                  </div>
                </div>

                {/* Questions Available */}
                <div className={`p-4 rounded-lg border-2 ${
                  suggestionPreview.questionInfo.count >= suggestionPreview.questionInfo.requested
                    ? 'bg-green-50 border-green-200'
                    : 'bg-amber-50 border-amber-200'
                }`}>
                  <div className="flex items-center gap-2 mb-2">
                    <Info size={18} className={
                      suggestionPreview.questionInfo.count >= suggestionPreview.questionInfo.requested
                        ? 'text-green-600'
                        : 'text-amber-600'
                    } />
                    <span className={`font-bold ${
                      suggestionPreview.questionInfo.count >= suggestionPreview.questionInfo.requested
                        ? 'text-green-900'
                        : 'text-amber-900'
                    }`}>
                      Questions Available
                    </span>
                  </div>
                  <p className={`text-sm ${
                    suggestionPreview.questionInfo.count >= suggestionPreview.questionInfo.requested
                      ? 'text-green-800'
                      : 'text-amber-800'
                  }`}>
                    <strong>{suggestionPreview.questionInfo.count}</strong> questions found
                    {suggestionPreview.questionInfo.count < suggestionPreview.questionInfo.requested && (
                      <span> (requested: {suggestionPreview.questionInfo.requested})</span>
                    )}
                  </p>
                  
                  {suggestionPreview.questionInfo.count === 0 && (
                    <p className="text-xs text-red-600 mt-2">
                      ‚ö†Ô∏è No questions available for this topic/subtopic combination.
                    </p>
                  )}
                </div>

                {/* Action Button */}
                <button
                  onClick={() => {
                    handleStudySuggestionClick(suggestionPreview);
                    setSuggestionPreview(null);
                  }}
                  disabled={suggestionPreview.questionInfo.count === 0}
                  className="w-full px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold transition-all flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <Play size={18} fill="currentColor" />
                  Start Practice ({Math.min(suggestionPreview.questionInfo.count, suggestionPreview.questionInfo.requested)} Questions)
                </button>
              </div>
            </motion.div>
          </div>
        )}
      </AnimatePresence>

      {/* Day Detail Modal */}
      <AnimatePresence>
        {selectedDate && (
          <div 
            className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4"
            onClick={() => setSelectedDate(null)}
          >
            <motion.div
              initial={{ opacity: 0, scale: 0.95 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.95 }}
              onClick={(e) => e.stopPropagation()}
              className="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] overflow-y-auto"
            >
              <div className="sticky top-0 bg-white border-b p-4 flex justify-between items-center">
                <h3 className="text-lg font-black text-slate-800">
                  {new Date(selectedDate).toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    month: 'long', 
                    day: 'numeric',
                    year: 'numeric'
                  })}
                </h3>
                <button
                  onClick={() => setSelectedDate(null)}
                  className="p-2 hover:bg-slate-100 rounded-lg transition-all"
                >
                  <X size={20} />
                </button>
              </div>
              
              <div className="p-6 space-y-4">
                {calendarData[selectedDate] ? (
                  <>
                    {/* UPDATED: Exams with event type delete */}
                    {calendarData[selectedDate].exams?.map((exam) => (
                      <div key={exam.id} className="p-4 rounded-lg bg-red-50 border-2 border-red-200">
                        <div className="flex items-center justify-between mb-2">
                          <div className="flex items-center gap-2">
                            <Flag className="text-red-600" size={20} />
                            <span className="font-bold text-red-900">{exam.title}</span>
                          </div>
                          {!exam.completed && (
                            <button
                              onClick={(e) => handleDeleteEvent(exam.id, EVENT_TYPES.MAJOR_EXAM, e)}
                              className="p-2 hover:bg-red-100 rounded-lg transition-all"
                              title="Delete exam and study plan"
                            >
                              <Trash2 size={16} className="text-red-600" />
                            </button>
                          )}
                        </div>
                        {exam.topic && (
                          <div className="text-sm text-red-700">
                            üìö Topic: {exam.topic}
                            {exam.subtopic && ` ‚Üí ${exam.subtopic}`}
                          </div>
                        )}
                      </div>
                    ))}
                    
                    {/* UPDATED: Quizzes with event type delete */}
                    {calendarData[selectedDate].quizzes?.map((quiz) => (
                      <div key={quiz.id} className="p-4 rounded-lg bg-amber-50 border-2 border-amber-200">
                        <div className="flex items-center justify-between mb-2">
                          <div className="flex items-center gap-2">
                            <BookOpen className="text-amber-600" size={20} />
                            <span className="font-bold text-amber-900">{quiz.title}</span>
                          </div>
                          {!quiz.completed && (
                            <button
                              onClick={(e) => handleDeleteEvent(quiz.id, EVENT_TYPES.SMALL_QUIZ, e)}
                              className="p-2 hover:bg-amber-100 rounded-lg transition-all"
                              title="Delete quiz and study plan"
                            >
                              <Trash2 size={16} className="text-amber-600" />
                            </button>
                          )}
                        </div>
                        {quiz.topic && (
                          <div className="text-sm text-amber-700">
                            üìö Topic: {quiz.topic}
                            {quiz.subtopic && ` ‚Üí ${quiz.subtopic}`}
                          </div>
                        )}
                      </div>
                    ))}
                    
                    {/* Study Suggestions */}
                    {calendarData[selectedDate].suggestions?.map((suggestion) => {
                      const questionInfo = getAvailableQuestions(suggestion);
                      return (
                        <div
                          key={suggestion.id}
                          className="p-4 rounded-lg bg-blue-50 border-2 border-blue-200"
                        >
                          <div className="flex items-center gap-2 mb-2">
                            <CalendarIcon className="text-blue-600" size={20} />
                            <span className="font-bold text-blue-900">{suggestion.title}</span>
                            {suggestion.completed && <CheckCircle size={16} className="text-blue-600 ml-auto" />}
                          </div>
                          <div className="text-sm text-blue-700 mb-3 space-y-1">
                            <div>üìù {suggestion.questionCount} questions ‚Ä¢ Phase: {suggestion.phase}</div>
                            {suggestion.topic && (
                              <div>üìö {suggestion.topic}{suggestion.subtopic && ` ‚Üí ${suggestion.subtopic}`}</div>
                            )}
                            <div className={questionInfo.count >= questionInfo.requested ? 'text-green-600' : 'text-amber-600'}>
                              ‚úì {questionInfo.count} questions available
                            </div>
                          </div>
                          {!suggestion.completed && (
                            <button
                              onClick={() => {
                                handleStudySuggestionClick(suggestion);
                                setSelectedDate(null);
                              }}
                              disabled={questionInfo.count === 0}
                              className="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-bold transition-all flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                              <Play size={16} fill="currentColor" />
                              Start Practice
                            </button>
                          )}
                        </div>
                      );
                    })}
                    
                    {/* UPDATED: Spaced Repetitions */}
                    {calendarData[selectedDate].repetitions?.map((rep) => (
                      <button
                        key={rep.id}
                        onClick={(e) => {
                          handleSpacedRepetitionClick(rep, e);
                          setSelectedDate(null);
                        }}
                        className="w-full p-4 rounded-lg bg-purple-50 border-2 border-purple-200 hover:bg-purple-100 transition-all text-left"
                      >
                        <div className="flex items-center gap-2 mb-2">
                          <Brain className="text-purple-600" size={20} />
                          <span className="font-bold text-purple-900">{rep.title}</span>
                          {rep.completed && <CheckCircle size={16} className="text-purple-600 ml-auto" />}
                        </div>
                        <div className="text-sm text-purple-700">
                          Review interval: {rep.interval} days ‚Ä¢ Attempt #{rep.attemptCount}
                        </div>
                      </button>
                    ))}

                    {/* AI Recommendations */}
                    {calendarData[selectedDate].aiRecommendations?.map((aiRec) => (
                      <div
                        key={aiRec.id}
                        className="p-4 rounded-lg bg-gradient-to-r from-purple-50 to-pink-50 border-2 border-purple-200"
                      >
                        <div className="flex items-center gap-2 mb-2">
                          <Sparkles className="text-purple-600" size={20} />
                          <span className="font-bold text-purple-900">{aiRec.title}</span>
                        </div>
                        <div className="text-sm text-purple-700 mb-3">
                          {aiRec.description}
                        </div>
                        <div className="flex gap-2">
                          <button
                            onClick={() => {
                              handleAIRecommendationClick(aiRec);
                              setSelectedDate(null);
                            }}
                            className="flex-1 px-3 py-2 bg-purple-600 text-white rounded-lg font-bold hover:bg-purple-700 transition-all flex items-center justify-center gap-2"
                          >
                            <Play size={16} fill="currentColor" />
                            Start Practice
                          </button>
                        </div>
                      </div>
                    ))}
                    
                    {/* Completions */}
                    {calendarData[selectedDate].completions?.length > 0 && (
                      <div className="p-4 rounded-lg bg-green-50 border-2 border-green-200">
                        <div className="flex items-center gap-2 mb-2">
                          <CheckCircle className="text-green-600" size={20} />
                          <span className="font-bold text-green-900">
                            {calendarData[selectedDate].completions.length} Session(s) Completed
                          </span>
                        </div>
                        <div className="space-y-1">
                          {calendarData[selectedDate].completions.map((comp, idx) => (
                            <div key={idx} className="text-sm text-green-700">
                              {comp.questionCount} questions ‚Ä¢ {Math.round(comp.accuracy * 100)}% accuracy
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </>
                ) : (
                  <div className="text-center py-8 text-slate-400">
                    No events scheduled for this day
                  </div>
                )}
              </div>
            </motion.div>
          </div>
        )}
      </AnimatePresence>

      {/* NEW: Spaced Repetition Review Modal */}
      {reviewModal && (
        <SpacedRepetitionModal
          repetition={reviewModal.repetition}
          allRepetitions={reviewModal.allRepetitions}
          questions={questions}
          onClose={() => setReviewModal(null)}
          onStartReview={handleStartReview}
        />
      )}
    </div>
  );
}

=== src/components/dashboard/SpacedRepetitionModal.jsx ===
import React, { useState } from 'react';
import { X, Play, Eye, CheckSquare, BookOpen } from 'lucide-react';
import { motion } from 'framer-motion';

export default function SpacedRepetitionModal({ 
  repetition, 
  allRepetitions = [], 
  questions = [],
  onClose, 
  onStartReview 
}) {
  const [reviewMode, setReviewMode] = useState('single');
  const [selectedQuestions, setSelectedQuestions] = useState(new Set([repetition.questionId]));
  
  const currentQuestion = questions.find(q => q.ID === repetition.questionId);
  const availableReviews = allRepetitions.filter(r => !r.completed);
  
  const toggleQuestion = (questionId) => {
    setSelectedQuestions(prev => {
      const next = new Set(prev);
      if (next.has(questionId)) {
        next.delete(questionId);
      } else {
        next.add(questionId);
      }
      return next;
    });
  };
  
  return (
    <div 
      className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4"
      onClick={onClose}
    >
      <motion.div
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        onClick={(e) => e.stopPropagation()}
        className="bg-white rounded-2xl shadow-2xl max-w-3xl w-full max-h-[90vh] overflow-y-auto"
      >
        <div className="border-b p-6 flex justify-between items-center sticky top-0 bg-white z-10">
          <div>
            <h2 className="text-2xl font-black text-slate-800">Spaced Repetition Review</h2>
            <p className="text-sm text-slate-500 mt-1">Choose your review mode</p>
          </div>
          <button onClick={onClose} className="p-2 hover:bg-slate-100 rounded-lg transition-all">
            <X size={24} />
          </button>
        </div>

        <div className="p-6 space-y-6">
          <div>
            <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-3">
              Review Mode
            </label>
            <div className="grid grid-cols-2 gap-3">
              <button
                onClick={() => setReviewMode('single')}
                className={`p-4 rounded-xl border-2 transition-all ${
                  reviewMode === 'single' ? 'border-purple-500 bg-purple-50' : 'border-slate-200'
                }`}
              >
                <div className="flex items-center gap-3 mb-2">
                  <Eye className={reviewMode === 'single' ? 'text-purple-600' : 'text-slate-400'} size={20} />
                  <span className="font-bold">Single Question</span>
                </div>
                <div className="text-xs text-slate-500 text-left">
                  Review just this specific mistake
                </div>
              </button>

              <button
                onClick={() => setReviewMode('batch')}
                className={`p-4 rounded-xl border-2 transition-all ${
                  reviewMode === 'batch' ? 'border-purple-500 bg-purple-50' : 'border-slate-200'
                }`}
              >
                <div className="flex items-center gap-3 mb-2">
                  <CheckSquare className={reviewMode === 'batch' ? 'text-purple-600' : 'text-slate-400'} size={20} />
                  <span className="font-bold">Batch Review</span>
                </div>
                <div className="text-xs text-slate-500 text-left">
                  Review multiple questions together
                </div>
              </button>
            </div>
          </div>

          {reviewMode === 'single' && currentQuestion && (
            <div className="p-4 rounded-xl bg-purple-50 border-2 border-purple-200">
              <h3 className="font-bold text-purple-900 mb-2">Question Preview</h3>
              <div className="text-sm text-purple-800 mb-2">
                <strong>Topic:</strong> {currentQuestion.Topic} ‚Üí {currentQuestion.Subtopic}
              </div>
              <div 
                className="text-sm text-slate-700 line-clamp-3"
                dangerouslySetInnerHTML={{ __html: currentQuestion.Question }}
              />
              <div className="mt-3 text-xs text-purple-600">
                üìÖ Interval: Day {repetition.interval}
              </div>
            </div>
          )}

          {reviewMode === 'batch' && (
            <div>
              <h3 className="font-bold text-slate-800 mb-3">
                Select Questions ({selectedQuestions.size} selected)
              </h3>
              <div className="space-y-2 max-h-96 overflow-y-auto">
                {availableReviews.map((rep) => {
                  const question = questions.find(q => q.ID === rep.questionId);
                  if (!question) return null;
                  
                  const isSelected = selectedQuestions.has(rep.questionId);
                  
                  return (
                    <button
                      key={rep.id}
                      onClick={() => toggleQuestion(rep.questionId)}
                      className={`w-full p-3 rounded-lg border-2 text-left transition-all ${
                        isSelected ? 'border-purple-500 bg-purple-50' : 'border-slate-200'
                      }`}
                    >
                      <div className="flex items-start gap-3">
                        <input type="checkbox" checked={isSelected} onChange={() => {}} className="mt-1" />
                        <div className="flex-1">
                          <div className="text-xs font-bold text-slate-600 mb-1">
                            {question.Topic} ‚Üí {question.Subtopic}
                          </div>
                          <div 
                            className="text-sm text-slate-800 line-clamp-2"
                            dangerouslySetInnerHTML={{ __html: question.Question }}
                          />
                        </div>
                      </div>
                    </button>
                  );
                })}
              </div>
            </div>
          )}

          <button
            onClick={() => onStartReview(reviewMode, Array.from(selectedQuestions))}
            disabled={reviewMode === 'batch' && selectedQuestions.size === 0}
            className="w-full px-6 py-4 bg-purple-600 hover:bg-purple-700 text-white rounded-xl font-bold transition-all flex items-center justify-center gap-2 disabled:opacity-50"
          >
            <Play size={20} fill="currentColor" />
            Start Review ({reviewMode === 'single' ? '1' : selectedQuestions.size} Question{selectedQuestions.size !== 1 ? 's' : ''})
          </button>
        </div>
      </motion.div>
    </div>
  );
}

=== src/components/dashboard/StudyPlannerCalendar.jsx ===
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { 
  Calendar as CalendarIcon, ChevronLeft, ChevronRight, Plus, X, 
  Clock, Target, Brain, Zap, CheckCircle, Edit2, Trash2, AlertCircle 
} from 'lucide-react';
import { useLanguage } from '../../contexts/LanguageContext';
import {
  EVENT_TYPES,
  EVENT_ICONS,
  getCalendarEvents,
  addCalendarEvent,
  deleteCalendarEvent,
  getEventsForDate,
  scheduleMistakeReview,
  batchScheduleMistakeReviews,
} from '../../utils/calendarEventManager';

/**
 * Enhanced Study Planner Calendar
 * - Monthly calendar view with interactive events
 * - Exam/quiz scheduling with automatic prep suggestions
 * - Mistake-driven spaced repetition
 * - Deep linking to quiz page with parameters
 * - Real-time updates
 */
export default function StudyPlannerCalendar({ mistakes = [] }) {
  const { t } = useLanguage();
  const navigate = useNavigate();
  
  // State management
  const [currentDate, setCurrentDate] = useState(new Date());
  const [events, setEvents] = useState([]);
  const [selectedDate, setSelectedDate] = useState(null);
  const [showAddEventModal, setShowAddEventModal] = useState(false);
  const [hoveredDate, setHoveredDate] = useState(null);
  
  // Load events from storage
  useEffect(() => {
    loadEvents();
    
    // Listen for storage updates from other components
    const handleStorageUpdate = () => loadEvents();
    window.addEventListener('calendar-update', handleStorageUpdate);
    window.addEventListener('storage', handleStorageUpdate);
    
    return () => {
      window.removeEventListener('calendar-update', handleStorageUpdate);
      window.removeEventListener('storage', handleStorageUpdate);
    };
  }, []);
  
  // Auto-schedule mistake reviews when mistakes change
  useEffect(() => {
    if (mistakes.length > 0) {
      // Schedule reviews for all active mistakes
      const activeMistakes = mistakes.filter(m => (m.improvementCount || 0) < 3);
      if (activeMistakes.length > 0) {
        batchScheduleMistakeReviews(activeMistakes);
        loadEvents();
      }
    }
  }, [mistakes]);
  
  const loadEvents = () => {
    setEvents(getCalendarEvents());
  };
  
  // Calendar calculations
  const { year, month } = useMemo(() => ({
    year: currentDate.getFullYear(),
    month: currentDate.getMonth(),
  }), [currentDate]);
  
  const monthName = useMemo(() => 
    currentDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })
  , [currentDate]);
  
  const daysInMonth = useMemo(() => 
    new Date(year, month + 1, 0).getDate()
  , [year, month]);
  
  const firstDayOfMonth = useMemo(() => 
    new Date(year, month, 1).getDay()
  , [year, month]);
  
  const calendarDays = useMemo(() => {
    const days = [];
    const prevMonthDays = new Date(year, month, 0).getDate();
    
    // Previous month days
    for (let i = firstDayOfMonth - 1; i >= 0; i--) {
      days.push({
        day: prevMonthDays - i,
        isCurrentMonth: false,
        date: new Date(year, month - 1, prevMonthDays - i),
      });
    }
    
    // Current month days
    for (let day = 1; day <= daysInMonth; day++) {
      days.push({
        day,
        isCurrentMonth: true,
        date: new Date(year, month, day),
      });
    }
    
    // Next month days
    const remainingDays = 42 - days.length; // 6 rows √ó 7 days
    for (let day = 1; day <= remainingDays; day++) {
      days.push({
        day,
        isCurrentMonth: false,
        date: new Date(year, month + 1, day),
      });
    }
    
    return days;
  }, [year, month, daysInMonth, firstDayOfMonth]);
  
  // Get events for each day
  const eventsMap = useMemo(() => {
    const map = {};
    events.forEach(event => {
      if (!map[event.date]) map[event.date] = [];
      map[event.date].push(event);
    });
    return map;
  }, [events]);
  
  // Navigation
  const goToPreviousMonth = () => {
    setCurrentDate(new Date(year, month - 1, 1));
  };
  
  const goToNextMonth = () => {
    setCurrentDate(new Date(year, month + 1, 1));
  };
  
  const goToToday = () => {
    setCurrentDate(new Date());
  };
  
  // Event handling
  const handleDateClick = (dateObj) => {
    const dateStr = dateObj.date.toISOString().split('T')[0];
    const dayEvents = eventsMap[dateStr] || [];
    
    if (dayEvents.length > 0) {
      setSelectedDate({ dateStr, events: dayEvents });
    } else {
      setSelectedDate({ dateStr, events: [] });
      setShowAddEventModal(true);
    }
  };
  
  const handleEventClick = (event) => {
    // Route to quiz page with appropriate parameters
    if (event.type === EVENT_TYPES.STUDY_SUGGESTION || event.type === EVENT_TYPES.MISTAKE_REVIEW) {
      // Prepare quiz based on event type
      if (event.mistakeId) {
        // Navigate to mistake review
        navigate('/mistakes');
      } else {
        // Navigate to topic practice
        navigate(`/quiz?topic=${encodeURIComponent(event.topic)}&subtopic=${encodeURIComponent(event.subtopic || '')}&count=${event.mcqCount || 10}&mode=practice`);
      }
    }
  };
  
  const isToday = (dateObj) => {
    const today = new Date();
    return dateObj.date.toDateString() === today.toDateString();
  };
  
  const getTodayDateStr = () => new Date().toISOString().split('T')[0];
  
  return (
    <div className="bg-white rounded-2xl shadow-lg border-2 border-indigo-100 overflow-hidden">
      {/* Header */}
      <div className="bg-gradient-to-r from-indigo-600 to-purple-600 p-6">
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-3">
            <div className="w-12 h-12 rounded-xl bg-white/20 backdrop-blur flex items-center justify-center">
              <CalendarIcon className="text-white" size={28} />
            </div>
            <div>
              <h3 className="text-2xl font-black text-white">Study Planner</h3>
              <p className="text-sm text-indigo-100">Smart scheduling with spaced repetition</p>
            </div>
          </div>
          <button
            onClick={() => setShowAddEventModal(true)}
            className="px-4 py-2 bg-white text-indigo-600 rounded-lg font-bold text-sm hover:bg-indigo-50 transition-all flex items-center gap-2"
          >
            <Plus size={18} />
            Add Exam/Quiz
          </button>
        </div>
        
        {/* Month Navigation */}
        <div className="flex items-center justify-between">
          <button
            onClick={goToPreviousMonth}
            className="p-2 hover:bg-white/20 rounded-lg transition-all text-white"
          >
            <ChevronLeft size={24} />
          </button>
          
          <div className="flex items-center gap-3">
            <h4 className="text-2xl font-black text-white">{monthName}</h4>
            <button
              onClick={goToToday}
              className="px-3 py-1 bg-white/20 hover:bg-white/30 rounded-lg text-sm font-bold text-white transition-all"
            >
              Today
            </button>
          </div>
          
          <button
            onClick={goToNextMonth}
            className="p-2 hover:bg-white/20 rounded-lg transition-all text-white"
          >
            <ChevronRight size={24} />
          </button>
        </div>
      </div>
      
      {/* Calendar Grid */}
      <div className="p-6">
        {/* Day Headers */}
        <div className="grid grid-cols-7 gap-2 mb-2">
          {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day) => (
            <div key={day} className="text-center text-xs font-black text-slate-500 py-2">
              {day}
            </div>
          ))}
        </div>
        
        {/* Calendar Days */}
        <div className="grid grid-cols-7 gap-2">
          {calendarDays.map((dateObj, idx) => {
            const dateStr = dateObj.date.toISOString().split('T')[0];
            const dayEvents = eventsMap[dateStr] || [];
            const hasEvents = dayEvents.length > 0;
            const isTodayDate = isToday(dateObj);
            
            return (
              <button
                key={idx}
                onClick={() => dateObj.isCurrentMonth && handleDateClick(dateObj)}
                onMouseEnter={() => setHoveredDate(dateStr)}
                onMouseLeave={() => setHoveredDate(null)}
                disabled={!dateObj.isCurrentMonth}
                className={`
                  relative aspect-square rounded-xl p-2 transition-all
                  ${dateObj.isCurrentMonth ? 'bg-slate-50 hover:bg-indigo-50 cursor-pointer' : 'bg-slate-50/30'}
                  ${isTodayDate ? 'ring-2 ring-indigo-500 bg-indigo-100' : ''}
                  ${hasEvents ? 'border-2 border-purple-300' : 'border-2 border-transparent'}
                `}
              >
                {/* Day Number */}
                <div className={`text-sm font-bold mb-1 ${
                  dateObj.isCurrentMonth 
                    ? isTodayDate ? 'text-indigo-700' : 'text-slate-700'
                    : 'text-slate-300'
                }`}>
                  {dateObj.day}
                </div>
                
                {/* Event Indicators */}
                {hasEvents && dateObj.isCurrentMonth && (
                  <div className="flex flex-wrap gap-1 items-center justify-center">
                    {dayEvents.slice(0, 3).map((event, i) => (
                      <span key={i} className="text-lg leading-none">
                        {EVENT_ICONS[event.type]}
                      </span>
                    ))}
                    {dayEvents.length > 3 && (
                      <span className="text-xs font-black text-purple-600">
                        +{dayEvents.length - 3}
                      </span>
                    )}
                  </div>
                )}
                
                {/* Hover Tooltip */}
                {hoveredDate === dateStr && dayEvents.length > 0 && (
                  <div className="absolute left-0 top-full mt-2 z-50 bg-slate-900 text-white text-xs rounded-lg p-2 shadow-2xl min-w-[200px]">
                    <div className="font-bold mb-1">{dayEvents.length} event{dayEvents.length > 1 ? 's' : ''}</div>
                    {dayEvents.slice(0, 3).map((e, i) => (
                      <div key={i} className="truncate opacity-90">
                        {EVENT_ICONS[e.type]} {e.title}
                      </div>
                    ))}
                  </div>
                )}
              </button>
            );
          })}
        </div>
        
        {/* Legend */}
        <div className="mt-6 pt-6 border-t border-slate-200">
          <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-3">
            Event Types
          </div>
          <div className="grid grid-cols-2 md:grid-cols-5 gap-3">
            {Object.entries(EVENT_TYPES).map(([key, type]) => (
              <div key={key} className="flex items-center gap-2 text-sm">
                <span className="text-xl">{EVENT_ICONS[type]}</span>
                <span className="text-slate-600 font-semibold">
                  {key.split('_').map(w => w[0] + w.slice(1).toLowerCase()).join(' ')}
                </span>
              </div>
            ))}
          </div>
        </div>
      </div>
      
      {/* Date Detail Modal */}
      {selectedDate && !showAddEventModal && (
        <DateDetailModal
          dateStr={selectedDate.dateStr}
          events={selectedDate.events}
          onClose={() => setSelectedDate(null)}
          onEventClick={handleEventClick}
          onAddEvent={() => setShowAddEventModal(true)}
          onDeleteEvent={(eventId) => {
            deleteCalendarEvent(eventId);
            loadEvents();
          }}
        />
      )}
      
      {/* Add Event Modal */}
      {showAddEventModal && (
        <AddEventModal
          initialDate={selectedDate?.dateStr}
          onClose={() => {
            setShowAddEventModal(false);
            setSelectedDate(null);
          }}
          onSave={() => {
            loadEvents();
            setShowAddEventModal(false);
            setSelectedDate(null);
          }}
        />
      )}
    </div>
  );
}

/**
 * Date Detail Modal - Shows events for a selected date
 */
function DateDetailModal({ dateStr, events, onClose, onEventClick, onAddEvent, onDeleteEvent }) {
  const { t } = useLanguage();
  
  const formattedDate = useMemo(() => {
    const date = new Date(dateStr);
    return date.toLocaleDateString('en-US', { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    });
  }, [dateStr]);
  
  return (
    <div
      className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4"
      onClick={onClose}
    >
      <div
        className="bg-white rounded-2xl shadow-2xl w-full max-w-2xl max-h-[80vh] overflow-hidden"
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="bg-gradient-to-r from-indigo-600 to-purple-600 p-6 text-white">
          <div className="flex items-center justify-between mb-2">
            <h3 className="text-2xl font-black">{formattedDate}</h3>
            <button
              onClick={onClose}
              className="p-2 hover:bg-white/20 rounded-lg transition-all"
            >
              <X size={24} />
            </button>
          </div>
          <p className="text-indigo-100 text-sm">
            {events.length} scheduled event{events.length !== 1 ? 's' : ''}
          </p>
        </div>
        
        {/* Events List */}
        <div className="p-6 overflow-y-auto max-h-[60vh]">
          {events.length === 0 ? (
            <div className="text-center py-12">
              <CalendarIcon size={48} className="text-slate-300 mx-auto mb-4" />
              <p className="text-slate-400 font-semibold mb-4">No events scheduled</p>
              <button
                onClick={onAddEvent}
                className="px-6 py-3 bg-indigo-600 text-white rounded-lg font-bold hover:bg-indigo-700 transition-all"
              >
                <Plus size={18} className="inline mr-2" />
                Add Event
              </button>
            </div>
          ) : (
            <div className="space-y-3">
              {events.map((event) => (
                <EventCard
                  key={event.id}
                  event={event}
                  onClick={() => onEventClick(event)}
                  onDelete={() => onDeleteEvent(event.id)}
                />
              ))}
              
              <button
                onClick={onAddEvent}
                className="w-full py-3 border-2 border-dashed border-slate-300 rounded-lg text-slate-600 font-bold hover:border-indigo-400 hover:text-indigo-600 transition-all flex items-center justify-center gap-2"
              >
                <Plus size={18} />
                Add Another Event
              </button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

/**
 * Event Card Component
 */
function EventCard({ event, onClick, onDelete }) {
  const getEventStyle = () => {
    switch (event.type) {
      case EVENT_TYPES.MAJOR_EXAM:
        return 'bg-gradient-to-r from-red-50 to-orange-50 border-red-300';
      case EVENT_TYPES.SMALL_QUIZ:
        return 'bg-gradient-to-r from-blue-50 to-indigo-50 border-blue-300';
      case EVENT_TYPES.STUDY_SUGGESTION:
        return 'bg-gradient-to-r from-yellow-50 to-amber-50 border-yellow-300';
      case EVENT_TYPES.MISTAKE_REVIEW:
        return 'bg-gradient-to-r from-purple-50 to-pink-50 border-purple-300';
      case EVENT_TYPES.COMPLETED_ACTIVITY:
        return 'bg-gradient-to-r from-green-50 to-emerald-50 border-green-300';
      default:
        return 'bg-slate-50 border-slate-300';
    }
  };
  
  const isClickable = event.type === EVENT_TYPES.STUDY_SUGGESTION || 
                      event.type === EVENT_TYPES.MISTAKE_REVIEW;
  
  return (
    <div
      className={`p-4 rounded-xl border-2 ${getEventStyle()} ${isClickable ? 'cursor-pointer' : ''}`}
      onClick={isClickable ? onClick : undefined}
    >
      <div className="flex items-start justify-between mb-2">
        <div className="flex items-center gap-2">
          <span className="text-2xl">{EVENT_ICONS[event.type]}</span>
          <div>
            <h4 className="font-black text-slate-800">{event.title}</h4>
            <p className="text-sm text-slate-600">{event.description}</p>
          </div>
        </div>
        
        {(event.type === EVENT_TYPES.MAJOR_EXAM || event.type === EVENT_TYPES.SMALL_QUIZ) && (
          <button
            onClick={(e) => {
              e.stopPropagation();
              onDelete();
            }}
            className="p-2 hover:bg-red-100 rounded-lg transition-all text-red-600"
          >
            <Trash2 size={16} />
          </button>
        )}
      </div>
      
      {event.mcqCount && (
        <div className="flex items-center gap-2 text-sm font-bold text-slate-700">
          <Target size={14} />
          {event.mcqCount} MCQs
        </div>
      )}
      
      {isClickable && (
        <div className="mt-2 text-xs font-bold text-indigo-600">
          Click to start practice ‚Üí
        </div>
      )}
    </div>
  );
}

/**
 * Add Event Modal
 */
function AddEventModal({ initialDate, onClose, onSave }) {
  const [eventType, setEventType] = useState(EVENT_TYPES.MAJOR_EXAM);
  const [title, setTitle] = useState('');
  const [date, setDate] = useState(initialDate || new Date().toISOString().split('T')[0]);
  const [topic, setTopic] = useState('');
  const [subtopic, setSubtopic] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    if (!title || !date || !topic) {
      alert('Please fill in all required fields');
      return;
    }
    
    const newEvent = {
      type: eventType,
      title,
      date,
      topic,
      subtopic,
      description: `${topic}${subtopic ? ` ‚Üí ${subtopic}` : ''}`,
    };
    
    addCalendarEvent(newEvent);
    onSave();
  };
  
  return (
    <div
      className="fixed inset-0 bg-black/60 flex items-center justify-center z-[60] p-4"
      onClick={onClose}
    >
      <div
        className="bg-white rounded-2xl shadow-2xl w-full max-w-lg"
        onClick={(e) => e.stopPropagation()}
      >
        <form onSubmit={handleSubmit}>
          {/* Header */}
          <div className="bg-gradient-to-r from-indigo-600 to-purple-600 p-6 text-white rounded-t-2xl">
            <div className="flex items-center justify-between mb-2">
              <h3 className="text-2xl font-black">Add Exam/Quiz</h3>
              <button
                type="button"
                onClick={onClose}
                className="p-2 hover:bg-white/20 rounded-lg transition-all"
              >
                <X size={24} />
              </button>
            </div>
            <p className="text-indigo-100 text-sm">
              Automatic prep suggestions will be generated
            </p>
          </div>
          
          {/* Form */}
          <div className="p-6 space-y-4">
            {/* Event Type */}
            <div>
              <label className="block text-sm font-black text-slate-700 mb-2">
                Event Type *
              </label>
              <div className="grid grid-cols-2 gap-2">
                <button
                  type="button"
                  onClick={() => setEventType(EVENT_TYPES.MAJOR_EXAM)}
                  className={`p-3 rounded-lg border-2 font-bold text-sm transition-all ${
                    eventType === EVENT_TYPES.MAJOR_EXAM
                      ? 'border-red-500 bg-red-50 text-red-700'
                      : 'border-slate-200 text-slate-600 hover:border-slate-300'
                  }`}
                >
                  üö© Major Exam
                </button>
                <button
                  type="button"
                  onClick={() => setEventType(EVENT_TYPES.SMALL_QUIZ)}
                  className={`p-3 rounded-lg border-2 font-bold text-sm transition-all ${
                    eventType === EVENT_TYPES.SMALL_QUIZ
                      ? 'border-blue-500 bg-blue-50 text-blue-700'
                      : 'border-slate-200 text-slate-600 hover:border-slate-300'
                  }`}
                >
                  ‚úèÔ∏è Small Quiz
                </button>
              </div>
            </div>
            
            {/* Title */}
            <div>
              <label className="block text-sm font-black text-slate-700 mb-2">
                Title *
              </label>
              <input
                type="text"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                placeholder="e.g., Chemistry Midterm Exam"
                required
                className="w-full px-4 py-3 border-2 border-slate-200 rounded-lg focus:border-indigo-500 focus:outline-none font-semibold"
              />
            </div>
            
            {/* Date */}
            <div>
              <label className="block text-sm font-black text-slate-700 mb-2">
                Date *
              </label>
              <input
                type="date"
                value={date}
                onChange={(e) => setDate(e.target.value)}
                required
                className="w-full px-4 py-3 border-2 border-slate-200 rounded-lg focus:border-indigo-500 focus:outline-none font-semibold"
              />
            </div>
            
            {/* Topic */}
            <div>
              <label className="block text-sm font-black text-slate-700 mb-2">
                Topic *
              </label>
              <input
                type="text"
                value={topic}
                onChange={(e) => setTopic(e.target.value)}
                placeholder="e.g., Organic Chemistry"
                required
                className="w-full px-4 py-3 border-2 border-slate-200 rounded-lg focus:border-indigo-500 focus:outline-none font-semibold"
              />
            </div>
            
            {/* Subtopic */}
            <div>
              <label className="block text-sm font-black text-slate-700 mb-2">
                Subtopic (Optional)
              </label>
              <input
                type="text"
                value={subtopic}
                onChange={(e) => setSubtopic(e.target.value)}
                placeholder="e.g., Reaction Mechanisms"
                className="w-full px-4 py-3 border-2 border-slate-200 rounded-lg focus:border-indigo-500 focus:outline-none font-semibold"
              />
            </div>
            
            {/* Info Box */}
            <div className="bg-indigo-50 border-2 border-indigo-200 rounded-lg p-4">
              <div className="flex items-start gap-2">
                <Zap size={16} className="text-indigo-600 flex-shrink-0 mt-0.5" />
                <div className="text-xs text-indigo-800">
                  <strong className="font-black">Automatic Suggestions:</strong>
                  {eventType === EVENT_TYPES.MAJOR_EXAM ? (
                    <> Study plan with 10/20/40 MCQs (10-7, 6-4, 3-1 days before)</>
                  ) : (
                    <> Quick review with 5-15 MCQs (3-1 days before)</>
                  )}
                </div>
              </div>
            </div>
          </div>
          
          {/* Footer */}
          <div className="p-6 border-t border-slate-200 flex gap-3">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 px-4 py-3 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg font-bold transition-all"
            >
              Cancel
            </button>
            <button
              type="submit"
              className="flex-1 px-4 py-3 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-700 hover:to-purple-700 text-white rounded-lg font-bold transition-all flex items-center justify-center gap-2"
            >
              <CheckCircle size={18} />
              Create Event
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}

=== src/pages/DashboardPage_Fixed.jsx ===
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { useLanguage } from '../contexts/LanguageContext';
import { quizService } from '../services/quizService';
import { quizStorage } from '../utils/quizStorage';
import { loadMistakesFromStorage } from '../utils/masteryHelper';
import AttemptDetailModal from '../components/AttemptDetailModal';
import MasteryProgressHub from '../components/dashboard/MasteryProgressHub';
import CurrentGoalWidget from '../components/dashboard/CurrentGoalWidget';
import PriorityReviewSection from '../components/dashboard/PriorityReviewSection';
import DailyMissionCard from '../components/dashboard/DailyMissionCard';
import SmartMonthlyCalendar from '../components/dashboard/SmartMonthlyCalendar';
import EventCreationModal from '../components/dashboard/EventCreationModal';
import CompactAttemptsList from '../components/dashboard/CompactAttemptsList';
import { LogOut, AlertCircle, RefreshCw, Sparkles } from 'lucide-react';
import { performanceService } from '../services/performanceService';
import { quizCompletionService } from '../services/quizCompletionService';

const MASTERY_THRESHOLD = 3;

// Helper function for AI Daily Mission
function calculateMasteryPriority(mistake, recentTopics = []) {
  const now = Date.now();
  const lastAttemptTime = new Date(mistake.lastAttempted).getTime();
  const daysSinceLastAttempt = Math.max(0, (now - lastAttemptTime) / (1000 * 60 * 60 * 24));
  const U = Math.pow(2, daysSinceLastAttempt / 7);
  const D = Math.min(1.0, (mistake.attemptCount || 1) / 3);
  let R = 0.5;
  if (recentTopics.length > 0 && recentTopics.includes(mistake.Topic)) {
    R = 1.5;
  }
  return (U * 0.4) + (D * 0.4) + (R * 0.2);
}

function selectAIDailyMission(mistakes, recentTopics = []) {
  const prioritized = mistakes
    .map(m => ({
      ...m,
      masteryPriority: calculateMasteryPriority(m, recentTopics)
    }))
    .sort((a, b) => b.masteryPriority - a.masteryPriority);
  
  const byTopic = {};
  prioritized.forEach(m => {
    if (!byTopic[m.Topic]) byTopic[m.Topic] = [];
    byTopic[m.Topic].push(m);
  });
  
  const selected = [];
  const topicList = Object.keys(byTopic);
  const indices = Object.fromEntries(topicList.map(t => [t, 0]));
  
  while (selected.length < 10 && topicList.some(t => indices[t] < byTopic[t].length)) {
    for (const topic of topicList) {
      if (selected.length >= 10) break;
      if (indices[topic] < byTopic[topic].length) {
        selected.push(byTopic[topic][indices[topic]++]);
      }
    }
  }
  
  return selected.slice(0, 10);
}

// ‚úÖ FIXED: Now receives questions as prop
export default function DashboardPage({ questions = [] }) {
  const { currentUser, userProfile, logout } = useAuth();
  const { t } = useLanguage();
  const navigate = useNavigate();
  
  const [attempts, setAttempts] = useState([]);
  const [mistakes, setMistakes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [selectedAttempt, setSelectedAttempt] = useState(null);
  const [showLogoutConfirm, setShowLogoutConfirm] = useState(false);
  const [loadingAIMission, setLoadingAIMission] = useState(false);
  const [showEventModal, setShowEventModal] = useState(false);
  const [calendarKey, setCalendarKey] = useState(0);
  const [debugLoading, setDebugLoading] = useState(false);

  // ‚úÖ REMOVED: No longer loading questions here - using prop instead
  // const { questions: allQuestions, loading: questionsLoading } = useQuizData(...)

  useEffect(() => {
    loadAttempts();
    loadMistakes();
  }, [currentUser]);

  async function loadAttempts() {
    if (!currentUser) { setLoading(false); return; }
    try {
      setError(null);
      setLoading(true);
      const userAttempts = await quizService.getUserAttempts(currentUser.uid, 10);
      setAttempts(userAttempts);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }

  function loadMistakes() {
    try {
      const loadedMistakes = loadMistakesFromStorage();
      setMistakes(loadedMistakes);
    } catch (err) {
      console.error('Error loading mistakes:', err);
      setMistakes([]);
    }
  }

  async function handleAIDailyMission() {
    setLoadingAIMission(true);
    try {
      const userAttempts = await quizService.getUserAttempts(currentUser.uid, 100);
      const incorrectMap = new Map();
      const improvementData = JSON.parse(
        localStorage.getItem('mistake_improvements') || '{}'
      );
      const recentTopics = JSON.parse(localStorage.getItem('recent_quiz_topics') || '[]');
      
      userAttempts.forEach((attempt) => {
        if (!attempt.answers || !attempt.questions) return;
        attempt.questions.forEach((question) => {
          const userAnswer = attempt.answers[question.ID];
          const isCorrect = userAnswer && userAnswer === question.CorrectOption;
          
          if (isCorrect && improvementData[question.ID]) {
            improvementData[question.ID].correctCount =
              (improvementData[question.ID].correctCount || 0) + 1;
            improvementData[question.ID].lastCorrect = attempt.timestamp;
          }
          
          if (userAnswer && userAnswer !== question.CorrectOption) {
            const improveCount = improvementData[question.ID]?.correctCount || 0;
            if (improveCount >= MASTERY_THRESHOLD) return;
            
            if (!incorrectMap.has(question.ID)) {
              incorrectMap.set(question.ID, {
                ...question,
                attemptCount: 1,
                lastAttempted: attempt.timestamp,
                userAnswer,
                improvementCount: improveCount,
              });
            } else {
              const existing = incorrectMap.get(question.ID);
              existing.attemptCount += 1;
              existing.improvementCount = improveCount;
              if (new Date(attempt.timestamp) > new Date(existing.lastAttempted)) {
                existing.lastAttempted = attempt.timestamp;
                existing.userAnswer = userAnswer;
              }
            }
          }
        });
      });

      const mistakesList = Array.from(incorrectMap.values());
      
      if (mistakesList.length < 10) {
        alert(`You need at least 10 mistakes to start AI Daily Mission. You currently have ${mistakesList.length}.`);
        setLoadingAIMission(false);
        return;
      }

      const selected = selectAIDailyMission(mistakesList, recentTopics);
      
      quizStorage.clearQuizData();
      quizStorage.saveSelectedQuestions(selected);
      localStorage.setItem('quiz_mode', 'ai-daily');
      localStorage.setItem('quiz_timer_enabled', 'true');
      localStorage.setItem('quiz_is_timed_mode', 'true');
      navigate('/quiz');
    } catch (error) {
      console.error('Error loading AI Daily Mission:', error);
      alert('Failed to load AI Daily Mission. Please try again.');
      setLoadingAIMission(false);
    }
  }

  /**
   * Debug function to check performance data and generate AI recommendations
   */
  async function handleDebugPerformance() {
    if (!currentUser?.uid) {
      alert('‚ùå No user logged in');
      return;
    }

    setDebugLoading(true);
    try {
      console.log('üîç Checking performance data...');
      
      const performance = await performanceService.getAllPerformance(currentUser.uid);
      console.log('Performance records:', performance);
      
      if (performance.length === 0) {
        alert('‚ùå No performance data found. Take a quiz with 5+ questions in the same subtopic first!');
        return;
      }
      
      const recommendations = await performanceService.getRecommendations(currentUser.uid);
      console.log('AI Recommendations:', recommendations);
      
      if (recommendations.length === 0) {
        await quizCompletionService.refreshAIRecommendations(currentUser.uid);
        alert('‚úÖ Generated new recommendations! Refresh the page.');
      } else {
        alert(`Found ${recommendations.length} recommendations! Check console for details.`);
      }
      
      setCalendarKey(prev => prev + 1);
    } catch (error) {
      console.error('Error:', error);
      alert('Error: ' + error.message);
    } finally {
      setDebugLoading(false);
    }
  }

  async function handleLogout() {
    try { 
      await logout(); 
      navigate('/login'); 
    } catch (e) { 
      console.error(e); 
    }
  }

  function handleEventCreated() {
    setCalendarKey(prev => prev + 1); // Force calendar reload
    setShowEventModal(false);
  }

  // ‚úÖ FIXED: Check if questions are still loading
  if (loading || questions.length === 0) {
    return (
      <div className="flex items-center justify-center h-screen bg-gray-50">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-500 mx-auto mb-4"></div>
          <p className="text-slate-700 font-semibold">
            {questions.length === 0 ? 'Loading questions...' : 'Personalizing your learning experience...'}
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6 p-4 bg-gradient-to-br from-slate-50 via-white to-slate-50 min-h-screen">
      <div className="max-w-7xl mx-auto space-y-6">
        {/* HEADER */}
        <div className="bg-white rounded-2xl shadow-lg p-8 border-2 border-indigo-100">
          <div className="flex justify-between items-start">
            <div>
              <h1 className="text-4xl font-black text-slate-800 mb-2 leading-tight">
                Welcome back, {currentUser?.displayName}! üéì
              </h1>
              <p className="text-lg text-slate-600 font-medium">{currentUser?.email}</p>
            </div>
            <div className="flex gap-3">
              {/* üîç Debug AI Recommendations Button */}
              <button
                onClick={handleDebugPerformance}
                disabled={debugLoading}
                className="px-4 py-2 bg-blue-600 text-white rounded-lg font-bold hover:bg-blue-700 flex items-center gap-2 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {debugLoading ? (
                  <>
                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white" />
                    Checking...
                  </>
                ) : (
                  <>
                    üîç Debug AI Recommendations
                  </>
                )}
              </button>
              <button
                onClick={() => setShowLogoutConfirm(true)}
                className="flex items-center gap-2 px-4 py-2 bg-rose-500 hover:bg-rose-600 text-white rounded-xl font-bold transition-all shadow-md"
              >
                <LogOut size={18} />
                Logout
              </button>
            </div>
          </div>
        </div>

        {/* ERROR DISPLAY */}
        {error && (
          <div className="bg-red-50 border-2 border-red-200 rounded-xl p-5">
            <div className="flex items-start gap-3">
              <AlertCircle className="text-red-600 flex-shrink-0 mt-1" size={20} />
              <div className="flex-1">
                <h3 className="font-bold text-red-900 mb-1">
                  Error Loading Data
                </h3>
                <p className="text-sm text-red-800 mb-3">{error}</p>
                <button
                  onClick={loadAttempts}
                  className="flex items-center gap-2 px-4 py-2 bg-red-600 text-white rounded-lg font-bold hover:bg-red-700 transition-all"
                >
                  <RefreshCw size={16} />
                  Retry
                </button>
              </div>
            </div>
          </div>
        )}

        {/* AI DAILY MISSION HERO SECTION */}
        <div className="bg-gradient-to-r from-purple-600 via-indigo-600 to-blue-600 rounded-2xl shadow-xl p-8 text-white">
          <div className="flex items-center justify-between">
            <div className="flex-1">
              <div className="flex items-center gap-3 mb-3">
                <Sparkles size={32} strokeWidth={3} />
                <h2 className="text-3xl font-black">AI Daily Mission</h2>
                <div className="bg-white/20 rounded-full px-3 py-1 text-sm font-bold">
                  10 Questions
                </div>
              </div>
              <p className="text-purple-100 mb-4 max-w-2xl">
                AI-optimized mistake review using spaced repetition and topic interleaving for maximum retention
              </p>
              <button
                onClick={handleAIDailyMission}
                disabled={loadingAIMission}
                className="px-8 py-4 bg-white text-purple-700 rounded-xl font-black text-lg shadow-lg hover:shadow-xl disabled:opacity-50 disabled:cursor-not-allowed transition-all flex items-center gap-2 hover:scale-105 active:scale-95"
              >
                {loadingAIMission ? (
                  <>
                    <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-purple-700" />
                    Loading...
                  </>
                ) : (
                  <>
                    <Sparkles size={20} />
                    Start Mission
                  </>
                )}
              </button>
            </div>
            <div className="hidden lg:block">
              <div className="w-48 h-48 bg-white/10 rounded-2xl flex items-center justify-center backdrop-blur">
                <Sparkles size={96} className="text-white/40" />
              </div>
            </div>
          </div>
        </div>

        {/* ‚úÖ FIXED: Using questions prop instead of allQuestions */}
        <SmartMonthlyCalendar
          key={calendarKey}
          userId={currentUser?.uid}
          questions={questions}
          onAddEvent={() => setShowEventModal(true)}
        />

        {/* TWO-COLUMN LAYOUT */}
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* LEFT COLUMN: 2/3 width - Learning Progress */}
          <div className="lg:col-span-2 space-y-6">
            {/* Mastery Health Bar */}
            <MasteryProgressHub userProfile={userProfile} mistakes={mistakes} />

            {/* Current Goal Widget */}
            <CurrentGoalWidget mistakes={mistakes} />
          </div>

          {/* RIGHT COLUMN: 1/3 width - Quick Actions & Review */}
          <div className="space-y-6">
            {/* Priority Review Section */}
            <PriorityReviewSection 
              mistakes={mistakes} 
              recentTopics={attempts.length > 0 ? attempts[0].topics || [] : []}
            />

            {/* Quick Stats Cards */}
            <div className="bg-white rounded-2xl shadow-lg border-2 border-slate-100 p-6">
              <h3 className="text-lg font-black text-slate-800 mb-4">Quick Stats</h3>
              <div className="space-y-3">
                <div className="flex justify-between items-center p-3 bg-indigo-50 rounded-lg">
                  <span className="text-sm font-bold text-slate-700">Study Streak</span>
                  <span className="text-2xl font-black text-indigo-600">üî•</span>
                </div>
                <div className="flex justify-between items-center p-3 bg-green-50 rounded-lg">
                  <span className="text-sm font-bold text-slate-700">Topics Mastered</span>
                  <span className="text-2xl font-black text-green-600">‚úì</span>
                </div>
                <div className="flex justify-between items-center p-3 bg-amber-50 rounded-lg">
                  <span className="text-sm font-bold text-slate-700">In Progress</span>
                  <span className="text-2xl font-black text-amber-600">‚Üí</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* RECENT ATTEMPTS SECTION */}
        <CompactAttemptsList 
          attempts={attempts} 
          onSelectAttempt={setSelectedAttempt}
          loading={loading}
        />

        {/* Attempt Detail Modal */}
        {selectedAttempt && (
          <AttemptDetailModal
            attempt={selectedAttempt}
            onClose={() => setSelectedAttempt(null)}
          />
        )}

        {/* ‚úÖ FIXED: Using questions prop */}
        {showEventModal && (
          <EventCreationModal
            userId={currentUser?.uid}
            questions={questions}
            onClose={() => setShowEventModal(false)}
            onEventCreated={handleEventCreated}
          />
        )}

        {/* Logout Confirmation Modal */}
        {showLogoutConfirm && (
          <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full animate-in fade-in slide-in-from-bottom duration-200">
              <div className="p-6 border-b border-slate-200">
                <div className="flex items-center gap-3">
                  <div className="w-12 h-12 rounded-full bg-rose-100 flex items-center justify-center">
                    <LogOut className="text-rose-600" size={24} />
                  </div>
                  <div>
                    <h3 className="text-xl font-black text-slate-800">
                      Confirm Logout
                    </h3>
                    <p className="text-sm text-slate-500">
                      Are you sure you want to leave?
                    </p>
                  </div>
                </div>
              </div>
              <div className="p-6">
                <p className="text-slate-600 mb-6">
                  You'll need to sign in again to access your dashboard.
                </p>
                <div className="flex gap-3">
                  <button
                    onClick={() => setShowLogoutConfirm(false)}
                    className="flex-1 px-4 py-3 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-xl font-bold transition-all"
                  >
                    Cancel
                  </button>
                  <button
                    onClick={handleLogout}
                    className="flex-1 px-4 py-3 bg-rose-500 hover:bg-rose-600 text-white rounded-xl font-bold transition-all flex items-center justify-center gap-2"
                  >
                    <LogOut size={18} />
                    Logout
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

=== src/pages/MistakeNotebookPage.jsx ===
// MistakeNotebookPage.jsx - Spaced Repetition Integration
import React, {
  useState, useEffect, useMemo, useCallback,
} from 'react';
import { createPortal } from 'react-dom';
import { useNavigate } from 'react-router-dom';
import { motion, AnimatePresence } from 'framer-motion';
import { useAuth } from '../contexts/AuthContext';
import { useLanguage } from '../contexts/LanguageContext';
import { quizService } from '../services/quizService';
import { quizStorage } from '../utils/quizStorage';
import { useFloating, offset, flip, shift, autoUpdate } from '@floating-ui/react';
import { AreaChart, Area, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import {
  BookOpen, ArrowLeft, Play, AlertCircle, Target,
  CheckCircle, Filter, ChevronDown, Calendar, Hash, Tag,
  Clock, Zap, TrendingUp, Brain, BarChart2, Layers, X,
  AlertTriangle, Flame, Star, PlusCircle, Wand2, Eye, EyeOff, 
  Grid3x3, List as ListIcon, Command, Archive, Sparkles,
  ChevronRight, Maximize2, Check, Activity, LineChart,
} from 'lucide-react';

// ADD THIS IMPORT:
import { calendarService } from '../services/calendarService';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CONSTANTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const MASTERY_THRESHOLD = 3;
const ERROR_TYPES = [
  { value: 'misread', label: 'Misread Question', color: 'blue' },
  { value: 'calculation', label: 'Calculation Error', color: 'red' },
  { value: 'conceptual', label: 'Conceptual Gap', color: 'orange' },
  { value: 'careless', label: 'Careless Mistake', color: 'yellow' },
  { value: 'vocab', label: 'Vocabulary Gap', color: 'purple' },
  { value: 'diagram', label: 'Diagram Misread', color: 'pink' },
];
const MASTERY_LEVELS = {
  new:        { label: 'New',         min: 0, max: 0, color: 'red' },
  progressing:{ label: 'Developing', min: 1, max: 1, color: 'amber' },
  near:       { label: 'Near-Mastery', min: 2, max: 2, color: 'green' },
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// HELPER FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function calculateMasteryPriority(mistake, recentTopics = []) {
  const now = Date.now();
  const lastAttemptTime = new Date(mistake.lastAttempted).getTime();
  const daysSinceLastAttempt = Math.max(0, (now - lastAttemptTime) / (1000 * 60 * 60 * 24));
  const U = Math.pow(2, daysSinceLastAttempt / 7);
  const D = Math.min(1.0, (mistake.attemptCount || 1) / 3);
  let R = 0.5;
  if (recentTopics.length > 0 && recentTopics.includes(mistake.Topic)) {
    R = 1.5;
  }
  return (U * 0.4) + (D * 0.4) + (R * 0.2);
}

function getMasteryState(improvementCount = 0) {
  if (improvementCount === 0) return { state: 0, label: 'Unprocessed', color: 'red' };
  if (improvementCount === 1) return { state: 1, label: 'Acquiring', color: 'amber' };
  if (improvementCount === 2) return { state: 2, label: 'Consolidating', color: 'yellow' };
  return { state: 3, label: 'Mastered', color: 'green' };
}

function calcPriority(mistake) {
  const days = (Date.now() - new Date(mistake.lastAttempted).getTime()) / (1000 * 60 * 60 * 24);
  return days * 1.2 - (mistake.improvementCount ?? 0) * 2;
}

function masteryStyle(improvementCount) {
  if (improvementCount >= 2)
    return {
      border: 'border-green-300',
      bg: 'bg-green-50/60',
      badge: 'bg-green-100 text-green-700',
      dot: 'bg-green-500',
    };
  if (improvementCount === 1)
    return {
      border: 'border-amber-300',
      bg: 'bg-amber-50/60',
      badge: 'bg-amber-100 text-amber-700',
      dot: 'bg-amber-400',
    };
  return {
    border: 'border-red-200',
    bg: 'bg-white',
    badge: 'bg-red-100 text-red-700',
    dot: 'bg-red-500',
  };
}

function applyRuleOfThree(improvements) {
  const archived = JSON.parse(localStorage.getItem('mistake_archive') || '{}');
  const activeImprovements = { ...improvements };
  
  Object.entries(improvements).forEach(([questionId, data]) => {
    if ((data.correctCount || 0) >= 3) {
      archived[questionId] = { ...data, archivedAt: new Date().toISOString() };
      delete activeImprovements[questionId];
    }
  });
  
  if (Object.keys(archived).length > Object.keys(JSON.parse(localStorage.getItem('mistake_archive') || '{}')).length) {
    localStorage.setItem('mistake_archive', JSON.stringify(archived));
  }
  
  return activeImprovements;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SPACED REPETITION INTEGRATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * Schedule spaced repetition events for new mistakes
 */
async function scheduleSpacedRepetitionForMistakes(mistakesList, currentUser, improvements) {
  if (!currentUser?.uid) return;

  try {
    // Only schedule for mistakes that are new or need review
    const mistakesToSchedule = mistakesList.filter(m => {
      const improvementCount = improvements[m.ID]?.correctCount || 0;
      return improvementCount < MASTERY_THRESHOLD && m.attemptCount >= 1;
    });

    // Schedule in batches to avoid overwhelming Firebase
    for (const mistake of mistakesToSchedule) {
      try {
        await calendarService.scheduleSpacedRepetition(currentUser.uid, {
          questionId: mistake.ID,
          topic: mistake.Topic,
          subtopic: mistake.Subtopic,
          attemptCount: mistake.attemptCount
        });
      } catch (error) {
        console.error('Error scheduling repetition for', mistake.ID, error);
        // Continue with other mistakes even if one fails
      }
    }
  } catch (error) {
    console.error('Error scheduling spaced repetitions:', error);
  }
}

/**
 * Call this function when processing quiz results for real-time scheduling
 */
async function handleMistakeCommitted(currentUser, question, attemptCount) {
  if (!currentUser?.uid) return;
  
  try {
    await calendarService.scheduleSpacedRepetition(currentUser.uid, {
      questionId: question.ID,
      topic: question.Topic,
      subtopic: question.Subtopic,
      attemptCount
    });
  } catch (error) {
    console.error('Error scheduling spaced repetition:', error);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UI COMPONENTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * FullQuestionModal: Pop-up to show complete question details
 */
function FullQuestionModal({ mistake, errorTag, onTag, onClose }) {
  const { t } = useLanguage();
  const [selectedTag, setSelectedTag] = useState(errorTag || '');

  const handleTagSelect = (tag) => {
    setSelectedTag(tag);
    onTag(mistake.ID, tag);
  };

  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-[100] p-4 overflow-y-auto">
      <motion.div 
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        className="bg-white rounded-2xl shadow-2xl w-full max-w-4xl my-6"
      >
        {/* Header */}
        <div className="bg-gradient-to-r from-slate-700 to-slate-900 p-6 rounded-t-2xl flex justify-between items-center">
          <div>
            <h2 className="text-2xl font-black text-white mb-1">{t('notebook.questionDetail')}</h2>
            <p className="text-slate-300 text-sm">{mistake.Topic} ‚Üí {mistake.Subtopic}</p>
          </div>
          <button
            onClick={onClose}
            className="p-2 hover:bg-white/20 rounded-lg transition-all text-white"
          >
            <X size={24} />
          </button>
        </div>

        <div className="p-8 space-y-6 max-h-[70vh] overflow-y-auto">
          {/* Question */}
          <div>
            <h3 className="text-sm font-black text-slate-500 uppercase tracking-widest mb-3">
              {t('notebook.question')}
            </h3>
            <div
              className="prose prose-slate max-w-none text-base bg-slate-50 p-4 rounded-xl border-2 border-slate-200"
              dangerouslySetInnerHTML={{ __html: mistake.Question }}
            />
          </div>

          {/* Image if exists */}
          {mistake.Pictureurl && (
            <div className="flex justify-center">
              <img 
                src={mistake.Pictureurl} 
                alt="Question diagram" 
                className="max-h-96 object-contain rounded-lg border-2 border-slate-200 shadow-md" 
              />
            </div>
          )}

          {/* Options Grid */}
          <div>
            <h3 className="text-sm font-black text-slate-500 uppercase tracking-widest mb-3">
              {t('notebook.options')}
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
              {['A', 'B', 'C', 'D'].map((opt) => {
                const isUserAnswer = mistake.userAnswer === opt;
                const isCorrect = mistake.CorrectOption === opt;
                
                return (
                  <div
                    key={opt}
                    className={`p-4 rounded-xl border-2 ${
                      isCorrect
                        ? 'border-green-500 bg-green-50'
                        : isUserAnswer
                        ? 'border-red-500 bg-red-50'
                        : 'border-slate-200 bg-white'
                    }`}
                  >
                    <div className="flex items-start gap-3">
                      <div className={`w-8 h-8 rounded-full flex items-center justify-center font-black text-sm flex-shrink-0 ${
                        isCorrect
                          ? 'bg-green-500 text-white'
                          : isUserAnswer
                          ? 'bg-red-500 text-white'
                          : 'bg-slate-200 text-slate-600'
                      }`}>
                        {opt}
                      </div>
                      <div className="flex-1">
                        {isCorrect && (
                          <div className="text-xs font-bold text-green-700 mb-1 flex items-center gap-1">
                            <CheckCircle size={12} /> {t('notebook.correctAnswer')}
                          </div>
                        )}
                        {isUserAnswer && !isCorrect && (
                          <div className="text-xs font-bold text-red-700 mb-1">
                            {t('notebook.yourAnswer')}
                          </div>
                        )}
                        <div className={`text-sm ${
                          isCorrect ? 'text-green-900 font-semibold' : isUserAnswer ? 'text-red-900' : 'text-slate-700'
                        }`}>
                          {mistake[`Option${opt}`] || opt}
                        </div>
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>

          {/* Explanation */}
          {mistake.Explanation && (
            <div>
              <h3 className="text-sm font-black text-slate-500 uppercase tracking-widest mb-3 flex items-center gap-2">
                <BookOpen size={16} className="text-blue-600" />
                {t('notebook.explanation')}
              </h3>
              <div
                className="prose prose-slate max-w-none text-sm bg-blue-50 p-4 rounded-xl border-2 border-blue-200"
                dangerouslySetInnerHTML={{ __html: mistake.Explanation }}
              />
            </div>
          )}

          {/* Error Type Tagging */}
          <div>
            <h3 className="text-sm font-black text-slate-500 uppercase tracking-widest mb-3">
              {t('notebook.tagErrorType')}
            </h3>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
              {ERROR_TYPES.map((type) => (
                <button
                  key={type.value}
                  onClick={() => handleTagSelect(type.value)}
                  className={`p-3 rounded-lg text-sm font-bold border-2 transition-all ${
                    selectedTag === type.value
                      ? `border-${type.color}-500 bg-${type.color}-50 text-${type.color}-700`
                      : 'border-slate-200 bg-white text-slate-600 hover:border-slate-300'
                  }`}
                >
                  <div className="flex items-center gap-2">
                    <div className={`w-3 h-3 rounded-full bg-${type.color}-500`} />
                    <span>{type.label}</span>
                  </div>
                </button>
              ))}
            </div>
          </div>

          {/* Stats */}
          <div className="grid grid-cols-3 gap-4 pt-4 border-t border-slate-200">
            <div className="text-center">
              <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                {t('notebook.attempts')}
              </div>
              <div className="text-2xl font-black text-slate-700">{mistake.attemptCount || 1}</div>
            </div>
            <div className="text-center">
              <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                {t('notebook.masteryLevel')}
              </div>
              <div className="text-2xl font-black text-amber-600">{mistake.improvementCount || 0}/3</div>
            </div>
            <div className="text-center">
              <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                {t('notebook.lastAttempted')}
              </div>
              <div className="text-sm font-bold text-slate-700">
                {new Date(mistake.lastAttempted).toLocaleDateString('en-GB', {
                  day: '2-digit',
                  month: 'short'
                })}
              </div>
            </div>
          </div>
        </div>
      </motion.div>
    </div>
  );
}

/**
 * ProgressSegments: 3-segment progress bar
 */
function ProgressSegments({ current, target = 3, size = 'sm' }) {
  const sizeClasses = {
    sm: 'h-2',
    md: 'h-3',
    lg: 'h-4',
  };
  
  return (
    <div className={`flex gap-1 ${sizeClasses[size]}`}>
      {Array.from({ length: target }).map((_, i) => (
        <div
          key={i}
          className={`flex-1 rounded-full transition-all duration-300 ${
            i < current
              ? 'bg-green-500 shadow-lg'
              : i === current
              ? 'bg-amber-400'
              : 'bg-slate-200'
          }`}
        />
      ))}
    </div>
  );
}

/**
 * TooltipWithPortal: Floating tooltip
 */
function TooltipWithPortal({ trigger, content, placement = 'top' }) {
  const [open, setOpen] = useState(false);
  
  const { refs, floatingStyles } = useFloating({
    placement,
    open,
    onOpenChange: setOpen,
    middleware: [offset(10), flip(), shift({ padding: 8 })],
    whileElementsMounted: autoUpdate
  });
  
  return (
    <>
      <div
        ref={refs.setReference}
        onMouseEnter={() => setOpen(true)}
        onMouseLeave={() => setOpen(false)}
        className="cursor-help"
      >
        {trigger}
      </div>
      
      {open && createPortal(
        <div
          ref={refs.setFloating}
          style={floatingStyles}
          className="z-[9999] bg-slate-900 text-white text-xs rounded-xl p-3 shadow-2xl ring-1 ring-white/10 max-w-xs pointer-events-none"
        >
          {content}
        </div>,
        document.body
      )}
    </>
  );
}

/**
 * InteractiveTopicHeatmap: Clickable topic density chart with multi-select
 */
function InteractiveTopicHeatmap({ mistakes, selectedTopics, onTopicToggle }) {
  const { t } = useLanguage();
  
  const errorDensity = useMemo(() => {
    const topicMap = {};
    mistakes.forEach(m => {
      if (!topicMap[m.Topic]) {
        topicMap[m.Topic] = { attempted: 0, wrong: 0 };
      }
      topicMap[m.Topic].wrong++;
      topicMap[m.Topic].attempted += Math.max(m.attemptCount, 1);
    });
    
    return Object.entries(topicMap).map(([topic, data]) => ({
      topic,
      errorDensity: Math.min(1.0, data.wrong / Math.max(data.attempted, 1)),
      wrongCount: data.wrong,
      attemptedCount: data.attempted
    })).sort((a, b) => b.errorDensity - a.errorDensity);
  }, [mistakes]);
  
  const getColor = (density, isSelected) => {
    const base = density < 0.2 ? 'yellow' 
      : density < 0.4 ? 'orange' 
      : density < 0.6 ? 'orange' 
      : density < 0.8 ? 'red'
      : 'red';
    
    if (isSelected) {
      return `from-${base}-600 to-${base}-700 text-white ring-2 ring-${base}-400 ring-offset-2`;
    }
    
    if (density < 0.2) return 'from-yellow-100 to-yellow-200 text-yellow-900 hover:from-yellow-200 hover:to-yellow-300';
    if (density < 0.4) return 'from-orange-200 to-orange-300 text-orange-900 hover:from-orange-300 hover:to-orange-400';
    if (density < 0.6) return 'from-orange-400 to-orange-500 text-white hover:from-orange-500 hover:to-orange-600';
    if (density < 0.8) return 'from-red-500 to-red-600 text-white hover:from-red-600 hover:to-red-700';
    return 'from-red-700 to-red-800 text-white hover:from-red-800 hover:to-red-900';
  };
  
  return (
    <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-6">
      <h3 className="font-bold text-lg text-slate-800 mb-2 flex items-center gap-2">
        <BarChart2 size={20} className="text-orange-600" />
        {t('notebook.errorDensityByTopic')}
      </h3>
      <p className="text-xs text-slate-500 mb-4">
        {t('notebook.clickTopicsToFilter')} ‚Ä¢ {selectedTopics.length > 0 && `${selectedTopics.length} selected`}
      </p>
      
      <div className="space-y-3">
        {errorDensity.map(({ topic, errorDensity: density, wrongCount, attemptedCount }) => {
          const isSelected = selectedTopics.includes(topic);
          return (
            <button
              key={topic}
              onClick={() => onTopicToggle(topic)}
              className={`w-full flex items-center gap-4 p-4 rounded-lg bg-gradient-to-r transition-all transform hover:scale-105 active:scale-95 cursor-pointer ${getColor(density, isSelected)}`}
            >
              <div className="w-32 font-semibold text-sm text-left truncate flex items-center gap-2">
                {isSelected && <Check size={14} />}
                {topic}
              </div>
              <div className="flex-1 text-right font-bold text-sm">
                {(density * 100).toFixed(0)}% ({wrongCount}/{attemptedCount})
              </div>
              <ChevronRight size={16} />
            </button>
          );
        })}
      </div>
      
      {selectedTopics.length > 0 && (
        <button
          onClick={() => selectedTopics.forEach(onTopicToggle)}
          className="mt-4 w-full py-2 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg text-sm font-bold transition-all"
        >
          {t('notebook.clearSelection')}
        </button>
      )}
    </div>
  );
}

/**
 * CalendarHeatmap: 30-day activity visualization
 */
function CalendarHeatmap({ improvements }) {
  const { t } = useLanguage();
  
  const activityMap = useMemo(() => {
    const map = {};
    const now = new Date();
    
    for (let i = 0; i < 30; i++) {
      const d = new Date(now);
      d.setDate(d.getDate() - i);
      const dateStr = d.toISOString().split('T')[0];
      map[dateStr] = 0;
    }
    
    Object.values(improvements).forEach(data => {
      if (data.lastCorrect) {
        const dateStr = new Date(data.lastCorrect).toISOString().split('T')[0];
        if (map[dateStr] !== undefined) map[dateStr]++;
      }
    });
    
    return map;
  }, [improvements]);
  
  const days = Object.entries(activityMap).reverse();
  const maxActivity = Math.max(...Object.values(activityMap), 1);
  
  const getColor = (count) => {
    const intensity = count / maxActivity;
    if (intensity === 0) return 'bg-slate-100';
    if (intensity < 0.33) return 'bg-blue-200';
    if (intensity < 0.67) return 'bg-blue-400';
    return 'bg-blue-600';
  };
  
  return (
    <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-6">
      <h3 className="font-bold text-lg text-slate-800 mb-4 flex items-center gap-2">
        <Calendar size={20} className="text-blue-600" />
        {t('notebook.mistakeClearingActivity')}
      </h3>
      
      <div className="grid grid-cols-7 gap-1">
        {['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((day, idx) => (
          <div key={`header-${idx}`} className="text-center text-xs font-bold text-slate-400 h-6">
            {day}
          </div>
        ))}
        
        {days.map(([dateStr, count]) => (
          <TooltipWithPortal
            key={dateStr}
            trigger={
              <div
                className={`w-8 h-8 rounded ${getColor(count)} flex items-center justify-center text-xs font-bold text-slate-700 hover:ring-2 ring-blue-400 transition-all cursor-pointer`}
              >
                {count > 0 && count}
              </div>
            }
            content={`${dateStr}: ${count} cleared`}
          />
        ))}
      </div>
      
      <div className="flex items-center gap-2 mt-4 text-xs text-slate-500">
        <span>{t('notebook.less')}</span>
        <div className="flex gap-1">
          {[0, 0.33, 0.67, 1.0].map((i, idx) => (
            <div key={idx} className={`w-3 h-3 rounded ${getColor(i * maxActivity)}`} />
          ))}
        </div>
        <span>{t('notebook.more')}</span>
      </div>
    </div>
  );
}

/**
 * ImprovementTrendChart: 14-day mastery progression
 */
function ImprovementTrendChart({ improvements }) {
  const { t } = useLanguage();
  
  const trendData = useMemo(() => {
    const stateHistory = {};
    
    Object.values(improvements).forEach(data => {
      const state = getMasteryState(data.correctCount || 0);
      const dateStr = data.lastCorrect
        ? new Date(data.lastCorrect).toISOString().split('T')[0]
        : new Date().toISOString().split('T')[0];
      
      if (!stateHistory[dateStr]) {
        stateHistory[dateStr] = { Unprocessed: 0, Acquiring: 0, Consolidating: 0, Mastered: 0 };
      }
      stateHistory[dateStr][state.label]++;
    });
    
    return Object.entries(stateHistory)
      .sort((a, b) => new Date(a[0]) - new Date(b[0]))
      .map(([date, states]) => ({ date, ...states }))
      .slice(-14);
  }, [improvements]);
  
  return (
    <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-6">
      <h3 className="font-bold text-lg text-slate-800 mb-4 flex items-center gap-2">
        <TrendingUp size={20} className="text-purple-600" />
        {t('notebook.improvementTrend')}
      </h3>
      
      <ResponsiveContainer width="100%" height={300}>
        <AreaChart data={trendData}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="date" />
          <YAxis />
          <Tooltip />
          <Legend />
          <Area type="monotone" dataKey="Unprocessed" stackId="1" stroke="#ef4444" fill="#fecaca" />
          <Area type="monotone" dataKey="Acquiring" stackId="1" stroke="#f59e0b" fill="#fed7aa" />
          <Area type="monotone" dataKey="Consolidating" stackId="1" stroke="#eab308" fill="#fef08a" />
          <Area type="monotone" dataKey="Mastered" stackId="1" stroke="#22c55e" fill="#bbf7d0" />
        </AreaChart>
      </ResponsiveContainer>
    </div>
  );
}

/**
 * RetentionDashboard: Learning metrics overview
 */
function RetentionDashboard({ mistakes, improvements }) {
  const { t, tf } = useLanguage();
  const [open, setOpen] = useState(true);
  
  const stats = useMemo(() => {
    const weekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
    const addedThisWeek = mistakes.filter(
      (m) => new Date(m.lastAttempted).getTime() >= weekAgo
    ).length;
    const masteredThisWeek = Object.values(improvements).filter(
      (d) => (d.correctCount || 0) >= MASTERY_THRESHOLD &&
             d.lastCorrect &&
             new Date(d.lastCorrect).getTime() >= weekAgo
    ).length;
    
    const subtopicMap = {};
    mistakes.forEach((m) => {
      const key = m.Subtopic || 'Unknown';
      if (!subtopicMap[key]) subtopicMap[key] = { count: 0, repeats: 0 };
      subtopicMap[key].count++;
      if (m.attemptCount > 1) subtopicMap[key].repeats++;
    });
    
    const weakest = Object.entries(subtopicMap)
      .sort((a, b) => b[1].count + b[1].repeats * 2 - (a[1].count + a[1].repeats * 2))
      .slice(0, 6);
    
    return { addedThisWeek, masteredThisWeek, weakest };
  }, [mistakes, improvements]);
  
  const decayLabel =
    stats.addedThisWeek === 0 && stats.masteredThisWeek === 0
      ? '‚Äî'
      : stats.masteredThisWeek > stats.addedThisWeek
      ? t('notebook.decayImproving')
      : stats.masteredThisWeek === stats.addedThisWeek
      ? t('notebook.decayStable')
      : t('notebook.decayGrowing');
  
  return (
    <div className="bg-white rounded-2xl shadow-sm border border-slate-200 overflow-hidden">
      <button
        onClick={() => setOpen((o) => !o)}
        className="w-full flex items-center justify-between p-5 hover:bg-slate-50 transition-all"
      >
        <div className="flex items-center gap-2">
          <Activity className="text-purple-600" size={20} />
          <span className="font-bold text-slate-800 text-lg">{t('notebook.retentionDashboard')}</span>
        </div>
        <ChevronDown
          size={20}
          className={`text-slate-400 transition-transform ${open ? 'rotate-180' : ''}`}
        />
      </button>
      
      <AnimatePresence>
        {open && (
          <motion.div
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: 'auto', opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            transition={{ duration: 0.3 }}
            className="border-t border-slate-200 overflow-hidden"
          >
            <div className="p-6 space-y-6 bg-slate-50">
              <div className="grid grid-cols-3 gap-4">
                <div className="bg-white rounded-xl p-4 border-2 border-slate-200 text-center">
                  <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                    {t('notebook.addedThisWeek')}
                  </div>
                  <div className="text-3xl font-black text-red-500">{stats.addedThisWeek}</div>
                </div>
                <div className="bg-white rounded-xl p-4 border-2 border-slate-200 text-center">
                  <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                    {t('notebook.masteredThisWeek')}
                  </div>
                  <div className="text-3xl font-black text-green-600">{stats.masteredThisWeek}</div>
                </div>
                <div className="bg-white rounded-xl p-4 border-2 border-purple-200 text-center">
                  <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                    {t('notebook.decayRate')}
                  </div>
                  <div className="text-lg font-black text-purple-700 mt-1">{decayLabel}</div>
                </div>
              </div>
              
              <div>
                <h3 className="text-sm font-black text-slate-600 uppercase tracking-widest mb-3 flex items-center gap-2">
                  <Flame size={14} className="text-red-500" />
                  {t('notebook.weakestSubtopics')}
                </h3>
                <div className="space-y-2">
                  {stats.weakest.map(([subtopic, data]) => {
                    const max = stats.weakest[0][1].count + stats.weakest[0][1].repeats * 2;
                    const score = data.count + data.repeats * 2;
                    const pct = max > 0 ? (score / max) * 100 : 0;
                    return (
                      <div key={subtopic} className="flex items-center gap-3">
                        <div className="w-32 text-xs text-slate-600 font-semibold truncate shrink-0">
                          {subtopic}
                        </div>
                        <div className="flex-1 bg-slate-200 rounded-full h-2">
                          <div
                            className="bg-gradient-to-r from-red-400 to-orange-400 h-2 rounded-full transition-all"
                            style={{ width: `${pct}%` }}
                          />
                        </div>
                        <div className="text-xs text-slate-500 shrink-0 w-8 text-right">
                          {data.count}
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

/**
 * LIST VIEW: Compact expandable rows
 */
function ListViewDeck({ mistakes, errorTags, onTag, selectedIds, onToggleSelect, onToggleSelectAll, allSelected, onViewFull }) {
  const { t } = useLanguage();
  const [expandedId, setExpandedId] = useState(null);
  
  return (
    <div className="space-y-2">
      {/* Select All */}
      <div className="flex items-center gap-2 p-3 bg-slate-50 rounded-lg border border-slate-200">
        <input
          type="checkbox"
          checked={allSelected}
          onChange={onToggleSelectAll}
          className="w-4 h-4 rounded cursor-pointer"
        />
        <span className="text-sm font-bold text-slate-700">
          {t('notebook.selectAll')} ({selectedIds.size}/{mistakes.length})
        </span>
      </div>
      
      {/* Mistake Rows */}
      <AnimatePresence>
        {mistakes.map((mistake) => {
          const style = masteryStyle(mistake.improvementCount ?? 0);
          const priority = calcPriority(mistake);
          const isExpanded = expandedId === mistake.ID;
          const isSelected = selectedIds.has(mistake.ID);
          const isUrgent = priority > 15;
          
          return (
            <motion.div
              key={mistake.ID}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -20 }}
              className={`rounded-lg border-2 transition-all ${style.border} ${style.bg} ${
                isUrgent ? 'ring-2 ring-red-400' : ''
              }`}
            >
              {/* Row Header */}
              <div className="flex items-center gap-3 p-4">
                <input
                  type="checkbox"
                  checked={isSelected}
                  onChange={() => onToggleSelect(mistake.ID)}
                  className="w-4 h-4 rounded cursor-pointer"
                />
                <button
                  onClick={() => setExpandedId(isExpanded ? null : mistake.ID)}
                  className="flex-1 flex items-center justify-between hover:bg-white/50 p-2 rounded-lg transition-all"
                >
                  <div className="flex items-center gap-3 flex-1">
                    <div className="w-10 h-10 rounded bg-slate-200 flex items-center justify-center text-xs font-bold text-slate-600">
                      {mistake.Topic.slice(0, 2)}
                    </div>
                    <div className="text-left min-w-0 flex-1">
                      <div className="text-xs font-bold text-slate-600">
                        {mistake.Topic} ‚Üí {mistake.Subtopic}
                      </div>
                      <div className="text-sm text-slate-800 font-semibold truncate">
                        {mistake.Question?.replace(/<[^>]*>/g, '').substring(0, 60)}...
                      </div>
                    </div>
                  </div>
                  <div className="flex items-center gap-2 shrink-0">
                    <div className="w-24">
                      <ProgressSegments current={mistake.improvementCount ?? 0} target={3} size="sm" />
                    </div>
                    <span className={`text-xs font-black px-2 py-1 rounded-full ${
                      isUrgent ? 'bg-red-100 text-red-700' : 'bg-slate-100 text-slate-600'
                    }`}>
                      {priority.toFixed(1)}
                    </span>
                    <ChevronRight size={16} className={`transition-transform ${isExpanded ? 'rotate-90' : ''}`} />
                  </div>
                </button>
                <button
                  onClick={() => onViewFull(mistake)}
                  className="p-2 bg-indigo-100 text-indigo-700 rounded-lg hover:bg-indigo-200 transition-all"
                  title={t('notebook.viewFullQuestion')}
                >
                  <Maximize2 size={18} />
                </button>
              </div>
              
              {/* Expanded Content */}
              <AnimatePresence>
                {isExpanded && (
                  <motion.div
                    initial={{ height: 0, opacity: 0 }}
                    animate={{ height: 'auto', opacity: 1 }}
                    exit={{ height: 0, opacity: 0 }}
                    transition={{ duration: 0.2 }}
                    className="overflow-hidden"
                  >
                    <div className="p-4 border-t border-slate-300 space-y-3">
                      <div className="grid grid-cols-2 gap-3">
                        <div className="p-3 rounded-lg bg-red-50 border border-red-200">
                          <div className="text-xs font-bold text-red-700 mb-1">{t('notebook.yourAnswer')}</div>
                          <div className="text-sm font-semibold text-red-900">{mistake.userAnswer}</div>
                        </div>
                        <div className="p-3 rounded-lg bg-green-50 border border-green-200">
                          <div className="text-xs font-bold text-green-700 mb-1">{t('notebook.correctAnswer')}</div>
                          <div className="text-sm font-semibold text-green-900">{mistake.CorrectOption}</div>
                        </div>
                      </div>
                    </div>
                  </motion.div>
                )}
              </AnimatePresence>
            </motion.div>
          );
        })}
      </AnimatePresence>
    </div>
  );
}

/**
 * KANBAN VIEW: 3-column layout (New, Developing, Near-Mastery)
 */
function KanbanViewDeck({ columns, errorTags, onTag, onViewFull }) {
  const { t } = useLanguage();
  const [expandedId, setExpandedId] = useState(null);
  
  const columnConfig = {
    new: { label: t('notebook.masteryNew'), color: 'red', icon: AlertTriangle, gradient: 'from-red-50 to-red-100', border: 'border-red-300' },
    progressing: { label: t('notebook.masteryDeveloping'), color: 'amber', icon: Flame, gradient: 'from-amber-50 to-amber-100', border: 'border-amber-300' },
    near: { label: t('notebook.masteryNear'), color: 'green', icon: Star, gradient: 'from-green-50 to-green-100', border: 'border-green-300' },
  };
  
  return (
    <div className="grid grid-cols-1 lg:grid-cols-3 gap-4 h-full">
      {Object.entries(columns).map(([key, mistakes]) => {
        const config = columnConfig[key];
        
        return (
          <motion.div
            key={key}
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ duration: 0.3 }}
            className={`rounded-2xl border-2 ${config.border} bg-gradient-to-b ${config.gradient} p-4 flex flex-col`}
          >
            {/* Column Header */}
            <div className="mb-4 pb-3 border-b-2 border-slate-300">
              <h3 className="font-black text-lg text-slate-800 flex items-center gap-2">
                <config.icon size={20} className={`text-${config.color}-600`} />
                {config.label} ({mistakes.length})
              </h3>
            </div>
            
            {/* Column Cards */}
            <div className="flex-1 overflow-y-auto space-y-3 pr-2">
              {mistakes.length === 0 ? (
                <div className="text-center py-8">
                  <CheckCircle size={32} className={`text-${config.color}-300 mx-auto mb-2`} />
                  <p className={`text-xs font-bold text-${config.color}-700`}>
                    {t('notebook.allCaughtUp')}
                  </p>
                </div>
              ) : (
                <AnimatePresence>
                  {mistakes.map((mistake) => {
                    const priority = calcPriority(mistake);
                    const isUrgent = priority > 15;
                    
                    return (
                      <motion.div
                        key={mistake.ID}
                        initial={{ opacity: 0, scale: 0.9 }}
                        animate={{ opacity: 1, scale: 1 }}
                        exit={{ opacity: 0, scale: 0.9 }}
                        className={`bg-white rounded-xl p-4 shadow-md border-2 border-slate-200 hover:shadow-lg transition-all ${
                          isUrgent ? 'ring-2 ring-red-400' : ''
                        }`}
                      >
                        {/* Card Header */}
                        <div className="mb-3">
                          <div className="text-xs font-bold text-slate-500 uppercase tracking-widest mb-1">
                            {mistake.Topic}
                          </div>
                          <div className="text-sm font-bold text-slate-800 line-clamp-2">
                            {mistake.Question?.replace(/<[^>]*>/g, '').substring(0, 80)}...
                          </div>
                        </div>
                        
                        {/* Progress Bar */}
                        <div className="mb-3">
                          <ProgressSegments current={mistake.improvementCount ?? 0} target={3} size="md" />
                        </div>
                        
                        {/* Priority Badge */}
                        <div className={`inline-block text-xs font-black px-2 py-1 rounded-full mb-3 ${
                          isUrgent
                            ? 'bg-red-100 text-red-700'
                            : priority > 7
                            ? 'bg-amber-100 text-amber-700'
                            : 'bg-slate-100 text-slate-600'
                        }`}>
                          {t('notebook.priority')}: {priority.toFixed(1)}
                        </div>
                        
                        {/* View Full Button */}
                        <button
                          onClick={() => onViewFull(mistake)}
                          className="w-full py-2 bg-indigo-600 text-white rounded-lg font-bold text-sm hover:bg-indigo-700 transition-all flex items-center justify-center gap-2"
                        >
                          <Maximize2 size={14} />
                          {t('notebook.viewFull')}
                        </button>
                      </motion.div>
                    );
                  })}
                </AnimatePresence>
              )}
            </div>
          </motion.div>
        );
      })}
    </div>
  );
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
export default function MistakeNotebookPage() {
  const { currentUser } = useAuth();
  const { t, tf } = useLanguage();
  const navigate = useNavigate();
  
  // Core state
  const [mistakes, setMistakes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [improvements, setImprovements] = useState({});
  const [errorTags, setErrorTags] = useState(() =>
    JSON.parse(localStorage.getItem('mistake_error_tags') || '{}')
  );
  const [recentQuizTopics, setRecentQuizTopics] = useState(() =>
    JSON.parse(localStorage.getItem('recent_quiz_topics') || '[]')
  );
  const [archivedMistakes, setArchivedMistakes] = useState(() =>
    JSON.parse(localStorage.getItem('mistake_archive') || '{}')
  );
  
  // Filter state
  const [questionCount, setQuestionCount] = useState('10');
  const [datePeriod, setDatePeriod] = useState('all');
  const [selectedTopics, setSelectedTopics] = useState([]);
  const [selectedSubtopics, setSelectedSubtopics] = useState([]);
  const [selectedMasteryLevels, setSelectedMasteryLevels] = useState([]);
  
  // Timer settings
  const [timerEnabled, setTimerEnabled] = useState(true);
  const [isTimedMode, setIsTimedMode] = useState(false);
  
  // UI state
  const [activeTab, setActiveTab] = useState('deck');
  const [viewMode, setViewMode] = useState('list');
  const [selectedMistakeIds, setSelectedMistakeIds] = useState(new Set());
  const [fullViewMistake, setFullViewMistake] = useState(null);
  
  // Load data
  useEffect(() => { loadMistakes(); }, [currentUser]);
  
  async function loadMistakes() {
    if (!currentUser) { setLoading(false); return; }
    try {
      setLoading(true);
      const attempts = await quizService.getUserAttempts(currentUser.uid, 100);
      const incorrectMap = new Map();
      const improvementData = JSON.parse(
        localStorage.getItem('mistake_improvements') || '{}'
      );
      
      attempts.forEach((attempt) => {
        if (!attempt.answers || !attempt.questions) return;
        attempt.questions.forEach((question) => {
          const userAnswer = attempt.answers[question.ID];
          const isCorrect = userAnswer && userAnswer === question.CorrectOption;
          
          if (isCorrect && improvementData[question.ID]) {
            improvementData[question.ID].correctCount =
              (improvementData[question.ID].correctCount || 0) + 1;
            improvementData[question.ID].lastCorrect = attempt.timestamp;
          }
          
          if (userAnswer && userAnswer !== question.CorrectOption) {
            const improveCount = improvementData[question.ID]?.correctCount || 0;
            if (improveCount >= MASTERY_THRESHOLD) return;
            
            if (!incorrectMap.has(question.ID)) {
              incorrectMap.set(question.ID, {
                ...question,
                attemptCount: 1,
                lastAttempted: attempt.timestamp,
                userAnswer,
                improvementCount: improveCount,
              });
            } else {
              const existing = incorrectMap.get(question.ID);
              existing.attemptCount += 1;
              existing.improvementCount = improveCount;
              if (new Date(attempt.timestamp) > new Date(existing.lastAttempted)) {
                existing.lastAttempted = attempt.timestamp;
                existing.userAnswer = userAnswer;
              }
            }
          }
        });
      });
      
      localStorage.setItem('mistake_improvements', JSON.stringify(improvementData));
      setImprovements(improvementData);
      
      const arr = Array.from(incorrectMap.values()).sort(
        (a, b) => calcPriority(b) - calcPriority(a)
      );
      setMistakes(arr);
      
      // *** NEW: Schedule spaced repetition events ***
      scheduleSpacedRepetitionForMistakes(arr, currentUser, improvementData)
        .catch((e) => console.error('Error scheduling spaced repetition (async):', e));
      
    } catch (err) {
      console.error('Error loading mistakes:', err);
    } finally {
      setLoading(false);
    }
  }
  
  // Persistence effects
  useEffect(() => {
    localStorage.setItem('mistake_error_tags', JSON.stringify(errorTags));
  }, [errorTags]);
  
  useEffect(() => {
    const updated = applyRuleOfThree(improvements);
    setArchivedMistakes(JSON.parse(localStorage.getItem('mistake_archive') || '{}'));
  }, [improvements]);
  
  // Computed values
  const allTopics = useMemo(
    () => [...new Set(mistakes.map((m) => m.Topic).filter(Boolean))].sort(),
    [mistakes]
  );
  
  const availableSubtopics = useMemo(() => {
    const base = selectedTopics.length > 0
      ? mistakes.filter((m) => selectedTopics.includes(m.Topic))
      : mistakes;
    return [...new Set(base.map((m) => m.Subtopic).filter(Boolean))].sort();
  }, [mistakes, selectedTopics]);
  
  useEffect(() => {
    setSelectedSubtopics((prev) =>
      prev.filter((s) => availableSubtopics.includes(s))
    );
  }, [availableSubtopics]);
  
  const filteredMistakes = useMemo(() => {
    let result = [...mistakes];
    
    if (datePeriod === 'week') {
      const weekAgo = new Date(); 
      weekAgo.setDate(weekAgo.getDate() - 7);
      result = result.filter((m) => new Date(m.lastAttempted) >= weekAgo);
    } else if (datePeriod === 'month') {
      const monthAgo = new Date(); 
      monthAgo.setMonth(monthAgo.getMonth() - 1);
      result = result.filter((m) => new Date(m.lastAttempted) >= monthAgo);
    }
    
    if (selectedTopics.length > 0)
      result = result.filter((m) => selectedTopics.includes(m.Topic));
    
    if (selectedSubtopics.length > 0)
      result = result.filter((m) => selectedSubtopics.includes(m.Subtopic));
    
    if (selectedMasteryLevels.length > 0) {
      result = result.filter((m) => {
        const ic = m.improvementCount ?? 0;
        return selectedMasteryLevels.some((lvl) => {
          const { min, max } = MASTERY_LEVELS[lvl];
          return ic >= min && ic <= max;
        });
      });
    }
    
    return result;
  }, [mistakes, datePeriod, selectedTopics, selectedSubtopics, selectedMasteryLevels]);
  
  const practiceCount =
    questionCount === 'All'
      ? filteredMistakes.length
      : Math.min(parseInt(questionCount), filteredMistakes.length);
  
  // Kanban columns
  const kanbanColumns = useMemo(() => ({
    new: filteredMistakes.filter(m => (m.improvementCount ?? 0) === 0),
    progressing: filteredMistakes.filter(m => (m.improvementCount ?? 0) === 1),
    near: filteredMistakes.filter(m => (m.improvementCount ?? 0) === 2),
  }), [filteredMistakes]);
  
  // Handlers
  const handleTag = useCallback((questionId, tag) => {
    setErrorTags((prev) => {
      const next = { ...prev };
      if (tag === null) delete next[questionId];
      else next[questionId] = tag;
      return next;
    });
  }, []);
  
  const toggleTopic = useCallback((topic) => {
    setSelectedTopics((prev) =>
      prev.includes(topic) ? prev.filter((t) => t !== topic) : [...prev, topic]
    );
  }, []);
  
  const toggleSubtopic = useCallback((sub) => {
    setSelectedSubtopics((prev) =>
      prev.includes(sub) ? prev.filter((s) => s !== sub) : [...prev, sub]
    );
  }, []);
  
  const toggleMasteryLevel = useCallback((lvl) => {
    setSelectedMasteryLevels((prev) =>
      prev.includes(lvl) ? prev.filter((l) => l !== lvl) : [...prev, lvl]
    );
  }, []);
  
  const handlePracticeMistakes = () => {
    if (filteredMistakes.length === 0) return;
    
    const selected = selectedMistakeIds.size > 0
      ? filteredMistakes.filter(m => selectedMistakeIds.has(m.ID))
      : [...filteredMistakes]
          .sort((a, b) => calcPriority(b) - calcPriority(a))
          .slice(0, practiceCount);
    
    quizStorage.clearQuizData();
    quizStorage.saveSelectedQuestions(selected);
    localStorage.setItem('quiz_mode', 'mistakes');
    localStorage.setItem('quiz_timer_enabled', timerEnabled.toString());
    localStorage.setItem('quiz_is_timed_mode', isTimedMode.toString());
    navigate('/quiz');
  };
  
  const toggleMistakeSelection = (questionId) => {
    setSelectedMistakeIds(prev => {
      const next = new Set(prev);
      if (next.has(questionId)) next.delete(questionId);
      else next.add(questionId);
      return next;
    });
  };
  
  const toggleSelectAll = () => {
    if (selectedMistakeIds.size === filteredMistakes.length) {
      setSelectedMistakeIds(new Set());
    } else {
      setSelectedMistakeIds(new Set(filteredMistakes.map(m => m.ID)));
    }
  };
  
  const formatDate = (iso) =>
    new Date(iso).toLocaleDateString('en-GB', {
      day: '2-digit', month: 'short', year: 'numeric',
    });
  
  // Loading state
  if (loading) {
    return (
      <div className="flex items-center justify-center h-screen bg-slate-50">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto mb-4" />
          <p className="text-slate-600 font-semibold">{t('notebook.loadingMistakes')}</p>
        </div>
      </div>
    );
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // RENDER
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  return (
    <div className="flex h-screen bg-slate-50 overflow-hidden">
      {/* Full Question Modal */}
      <AnimatePresence>
        {fullViewMistake && (
          <FullQuestionModal
            mistake={fullViewMistake}
            errorTag={errorTags[fullViewMistake.ID]}
            onTag={handleTag}
            onClose={() => setFullViewMistake(null)}
          />
        )}
      </AnimatePresence>

      {/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          SIDEBAR: Practice Configurator
          ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */}
      
      <div className="w-80 bg-white border-r border-slate-200 flex flex-col overflow-y-auto">
        {/* Header */}
        <div className="p-4 border-b border-slate-200 flex items-center gap-2">
          <button
            onClick={() => navigate('/dashboard')}
            className="p-2 hover:bg-slate-100 rounded-lg transition-all"
            title="Back to Dashboard"
          >
            <ArrowLeft size={20} className="text-slate-700" />
          </button>
          <h1 className="font-black text-lg text-slate-800 flex items-center gap-2">
            <Command size={20} className="text-indigo-600"/>
            {t('notebook.commandCenter')}
          </h1>
        </div>
        
        {/* Configurator */}
        <div className="flex-1 p-4 space-y-4 overflow-y-auto">
          {/* Question Count */}
          <div>
            <label className="text-xs font-black text-slate-600 uppercase tracking-widest mb-2 flex items-center gap-1">
              <Hash size={12} />
              {t('notebook.numberOfQuestions')}
            </label>
            <div className="grid grid-cols-3 gap-1">
              {['5', '10', '15', '20', '30', 'All'].map((num) => (
                <button
                  key={num}
                  onClick={() => setQuestionCount(num)}
                  disabled={num !== 'All' && parseInt(num) > filteredMistakes.length}
                  className={`py-2 rounded-lg border text-xs font-bold transition-all ${
                    questionCount === num
                      ? 'border-indigo-500 bg-indigo-50 text-indigo-600'
                      : 'border-slate-200 text-slate-500 hover:border-slate-300 disabled:opacity-30'
                  }`}
                >
                  {num}
                </button>
              ))}
            </div>
          </div>
          
          {/* Date Range */}
          <div>
            <label className="text-xs font-black text-slate-600 uppercase tracking-widest mb-2 flex items-center gap-1">
              <Calendar size={12} />
              {t('notebook.timeRange')}
            </label>
            <div className="space-y-1">
              {[
                { value: 'all',   label: t('notebook.allTime') },
                { value: 'month', label: t('notebook.lastMonth') },
                { value: 'week',  label: t('notebook.lastWeek') },
              ].map((o) => (
                <button
                  key={o.value}
                  onClick={() => setDatePeriod(o.value)}
                  className={`w-full px-3 py-2 rounded-lg border text-xs font-bold text-left transition-all ${
                    datePeriod === o.value
                      ? 'border-indigo-500 bg-indigo-50 text-indigo-700'
                      : 'border-slate-200 text-slate-600 hover:border-slate-300'
                  }`}
                >
                  {o.label}
                </button>
              ))}
            </div>
          </div>
          
          {/* Mastery Level */}
          <div>
            <label className="text-xs font-black text-slate-600 uppercase tracking-widest mb-2">
              {t('notebook.masteryLevel')}
            </label>
            <div className="space-y-1">
              {Object.entries(MASTERY_LEVELS).map(([key, lvl]) => {
                const count = mistakes.filter((m) => {
                  const ic = m.improvementCount ?? 0;
                  return ic >= lvl.min && ic <= lvl.max;
                }).length;
                
                return (
                  <button
                    key={key}
                    onClick={() => toggleMasteryLevel(key)}
                    className={`w-full px-3 py-2 rounded-lg text-xs font-bold border text-left transition-all ${
                      selectedMasteryLevels.includes(key)
                        ? `bg-${lvl.color}-500 border-${lvl.color}-500 text-white`
                        : `bg-white border-${lvl.color}-200 text-${lvl.color}-700`
                    }`}
                  >
                    {lvl.label}
                    <span className="ml-1 opacity-70">({count})</span>
                  </button>
                );
              })}
            </div>
          </div>
          
          {/* Topics */}
          {allTopics.length > 1 && (
            <div>
              <label className="text-xs font-black text-slate-600 uppercase tracking-widest mb-2">
                {t('notebook.topics')}
              </label>
              <div className="space-y-1 max-h-48 overflow-y-auto">
                {allTopics.map((topic) => (
                  <button
                    key={topic}
                    onClick={() => toggleTopic(topic)}
                    className={`w-full px-3 py-2 rounded-lg text-xs font-bold text-left border transition-all ${
                      selectedTopics.includes(topic)
                        ? 'bg-indigo-500 border-indigo-500 text-white'
                        : 'bg-white border-slate-200 text-slate-600 hover:border-indigo-300'
                    }`}
                  >
                    {topic}
                    <span className="ml-1 opacity-70">
                      ({mistakes.filter((m) => m.Topic === topic).length})
                    </span>
                  </button>
                ))}
              </div>
            </div>
          )}
          
          {/* Subtopics */}
          {availableSubtopics.length > 1 && (
            <div>
              <label className="text-xs font-black text-slate-600 uppercase tracking-widest mb-2">
                {t('notebook.subtopics')}
              </label>
              <div className="space-y-1 max-h-48 overflow-y-auto">
                {availableSubtopics.slice(0, 12).map((sub) => (
                  <button
                    key={sub}
                    onClick={() => toggleSubtopic(sub)}
                    className={`w-full px-3 py-2 rounded-lg text-xs font-bold text-left border transition-all ${
                      selectedSubtopics.includes(sub)
                        ? 'bg-indigo-400 border-indigo-400 text-white'
                        : 'bg-white border-slate-200 text-slate-600 hover:border-indigo-200'
                    }`}
                  >
                    {sub}
                  </button>
                ))}
              </div>
            </div>
          )}
          
          {/* Timer Settings */}
          <div className="space-y-2 pt-2 border-t border-slate-200">
            <button
              onClick={() => setTimerEnabled(!timerEnabled)}
              className={`w-full px-3 py-2 rounded-lg text-xs font-bold border transition-all text-left flex items-center justify-between ${
                timerEnabled
                  ? 'bg-green-600 border-green-600 text-white'
                  : 'bg-white border-slate-200 text-slate-600'
              }`}
            >
              <span className="flex items-center gap-1">
                <Clock size={12} />
                {t('notebook.timerEnabled')}
              </span>
              {timerEnabled && <Check size={14} />}
            </button>
            {timerEnabled && (
              <button
                onClick={() => setIsTimedMode(!isTimedMode)}
                className={`w-full px-3 py-2 rounded-lg text-xs font-bold border transition-all text-left flex items-center justify-between ${
                  isTimedMode
                    ? 'bg-amber-600 border-amber-600 text-white'
                    : 'bg-white border-slate-200 text-slate-600'
                }`}
              >
                <span className="flex items-center gap-1">
                  <Zap size={12} />
                  {t('notebook.timedMode')}
                </span>
                {isTimedMode && <Check size={14} />}
              </button>
            )}
          </div>
        </div>
        
        {/* Practice Button */}
        <div className="p-4 border-t border-slate-200">
          <button
            onClick={handlePracticeMistakes}
            disabled={filteredMistakes.length === 0}
            className="w-full py-3 bg-orange-600 text-white rounded-xl font-black text-sm shadow-lg hover:bg-orange-700 disabled:bg-slate-300 transition-all flex items-center justify-center gap-2 active:scale-95"
          >
            <Play fill="currentColor" size={16} />
            {selectedMistakeIds.size > 0 
              ? tf('notebook.practiceSelected', { count: selectedMistakeIds.size })
              : tf('notebook.practiceMistakesCount', { 
                  count: practiceCount,
                  plural: practiceCount !== 1 ? 's' : ''
                })}
          </button>
          <p className="text-xs text-slate-500 mt-2 text-center">
            {filteredMistakes.length} {t('notebook.questionsAvailable')}
          </p>
        </div>
      </div>
      
      {/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          MAIN WORKSPACE: Tabbed Interface
          ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */}
      
      <div className="flex-1 flex flex-col overflow-hidden">
        {/* Tab Navigation */}
        <div className="bg-white border-b border-slate-200 p-4">
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-1">
              <button
                onClick={() => setActiveTab('analytics')}
                className={`px-4 py-2 rounded-lg font-bold text-sm transition-all ${
                  activeTab === 'analytics'
                    ? 'bg-indigo-100 text-indigo-700 border-2 border-indigo-500'
                    : 'bg-slate-100 text-slate-600 border-2 border-slate-200 hover:border-slate-300'
                }`}
              >
                <Brain size={16} className="inline mr-2" />
                {t('notebook.learningInsights')}
              </button>
              <button
                onClick={() => setActiveTab('deck')}
                className={`px-4 py-2 rounded-lg font-bold text-sm transition-all ${
                  activeTab === 'deck'
                    ? 'bg-indigo-100 text-indigo-700 border-2 border-indigo-500'
                    : 'bg-slate-100 text-slate-600 border-2 border-slate-200 hover:border-slate-300'
                }`}
              >
                <Grid3x3 size={16} className="inline mr-2" />
                {t('notebook.mistakeDeck')} ({filteredMistakes.length})
              </button>
              <button
                onClick={() => setActiveTab('archive')}
                className={`px-4 py-2 rounded-lg font-bold text-sm transition-all ${
                  activeTab === 'archive'
                    ? 'bg-indigo-100 text-indigo-700 border-2 border-indigo-500'
                    : 'bg-slate-100 text-slate-600 border-2 border-slate-200 hover:border-slate-300'
                }`}
              >
                <Archive size={16} className="inline mr-2" />
                {t('notebook.masteryArchive')} ({Object.keys(archivedMistakes).length})
              </button>
            </div>
            
            {activeTab === 'deck' && (
              <div className="flex items-center gap-2">
                <button
                  onClick={() => setViewMode('list')}
                  className={`p-2 rounded-lg transition-all ${
                    viewMode === 'list'
                      ? 'bg-indigo-500 text-white'
                      : 'bg-slate-100 text-slate-600 hover:bg-slate-200'
                  }`}
                  title={t('notebook.listView')}
                >
                  <ListIcon size={18} />
                </button>
                <button
                  onClick={() => setViewMode('kanban')}
                  className={`p-2 rounded-lg transition-all ${
                    viewMode === 'kanban'
                      ? 'bg-indigo-500 text-white'
                      : 'bg-slate-100 text-slate-600 hover:bg-slate-200'
                  }`}
                  title={t('notebook.kanbanView')}
                >
                  <Grid3x3 size={18} />
                </button>
              </div>
            )}
          </div>
          
          {/* Filter Summary */}
          {(selectedTopics.length > 0 || selectedMasteryLevels.length > 0 || datePeriod !== 'all') && (
            <div className="flex flex-wrap gap-2 text-xs">
              {selectedTopics.map(t => (
                <span key={t} className="bg-indigo-100 text-indigo-700 px-2 py-1 rounded-full font-semibold">
                  {tf('notebook.topicFilter', { topic: t })}
                  <button onClick={() => toggleTopic(t)} className="ml-1">‚úï</button>
                </span>
              ))}
              {selectedMasteryLevels.map(l => (
                <span key={l} className="bg-indigo-100 text-indigo-700 px-2 py-1 rounded-full font-semibold">
                  {MASTERY_LEVELS[l].label}
                  <button onClick={() => toggleMasteryLevel(l)} className="ml-1">‚úï</button>
                </span>
              ))}
              {datePeriod !== 'all' && (
                <span className="bg-indigo-100 text-indigo-700 px-2 py-1 rounded-full font-semibold">
                  {datePeriod === 'week' ? t('notebook.lastWeek') : t('notebook.lastMonth')}
                  <button onClick={() => setDatePeriod('all')} className="ml-1">‚úï</button>
                </span>
              )}
            </div>
          )}
        </div>
        
        {/* Tab Content */}
        <div className="flex-1 overflow-y-auto p-6">
          <AnimatePresence mode="wait">
            {/* Tab 1: Learning Insights */}
            {activeTab === 'analytics' && mistakes.length > 0 && (
              <motion.div
                key="analytics"
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: 20 }}
                className="space-y-6"
              >
                {/* Quick Stats */}
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  <div className="bg-white rounded-xl p-4 border border-slate-200 shadow-sm">
                    <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-2">
                      {t('notebook.totalMistakes')}
                    </div>
                    <div className="text-3xl font-black text-red-600">{mistakes.length}</div>
                  </div>
                  <div className="bg-white rounded-xl p-4 border border-slate-200 shadow-sm">
                    <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-2">
                      {t('notebook.topicsToFocus')}
                    </div>
                    <div className="text-3xl font-black text-amber-600">
                      {new Set(mistakes.map((m) => m.Topic)).size}
                    </div>
                  </div>
                  <div className="bg-white rounded-xl p-4 border border-slate-200 shadow-sm">
                    <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-2">
                      {t('notebook.repeatedMistakes')}
                    </div>
                    <div className="text-3xl font-black text-green-600">
                      {mistakes.filter((m) => m.attemptCount > 1).length}
                    </div>
                  </div>
                </div>
                
                {/* Interactive Heatmap */}
                <InteractiveTopicHeatmap 
                  mistakes={mistakes} 
                  selectedTopics={selectedTopics}
                  onTopicToggle={toggleTopic}
                />
                
                {/* Retention Dashboard */}
                <RetentionDashboard mistakes={mistakes} improvements={improvements} />
                
                {/* Charts */}
                <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                  <CalendarHeatmap improvements={improvements} />
                </div>
                
                <ImprovementTrendChart improvements={improvements} />
              </motion.div>
            )}
            
            {/* Tab 2: Mistake Deck */}
            {activeTab === 'deck' && (
              <motion.div
                key="deck"
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: 20 }}
              >
                {mistakes.length === 0 ? (
                  <div className="text-center py-12">
                    <CheckCircle className="w-16 h-16 text-green-300 mx-auto mb-4" />
                    <p className="text-slate-400 text-lg mb-2 font-semibold">
                      {t('notebook.noMistakesYet')}
                    </p>
                    <p className="text-slate-500 text-sm mb-4">
                      {t('notebook.keepPracticing')}
                    </p>
                    <button
                      onClick={() => navigate('/')}
                      className="px-6 py-3 bg-indigo-600 text-white rounded-lg font-bold hover:bg-indigo-700 transition-all"
                    >
                      {t('notebook.startPracticing')}
                    </button>
                  </div>
                ) : filteredMistakes.length === 0 ? (
                  <div className="text-center py-12">
                    <AlertCircle className="w-16 h-16 text-amber-300 mx-auto mb-4" />
                    <p className="text-slate-400 text-lg mb-2 font-semibold">
                      {t('notebook.noQuestionsFound')}
                    </p>
                    <p className="text-slate-500 text-sm">
                      {t('notebook.tryAdjustFilters')}
                    </p>
                  </div>
                ) : viewMode === 'list' ? (
                  <ListViewDeck
                    mistakes={filteredMistakes}
                    errorTags={errorTags}
                    onTag={handleTag}
                    selectedIds={selectedMistakeIds}
                    onToggleSelect={toggleMistakeSelection}
                    onToggleSelectAll={toggleSelectAll}
                    allSelected={selectedMistakeIds.size === filteredMistakes.length}
                    onViewFull={setFullViewMistake}
                  />
                ) : (
                  <KanbanViewDeck
                    columns={kanbanColumns}
                    errorTags={errorTags}
                    onTag={handleTag}
                    onViewFull={setFullViewMistake}
                  />
                )}
              </motion.div>
            )}
            
            {/* Tab 3: Mastery Archive */}
            {activeTab === 'archive' && (
              <motion.div
                key="archive"
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: 20 }}
              >
                {Object.keys(archivedMistakes).length === 0 ? (
                  <div className="text-center py-12">
                    <Archive className="w-16 h-16 text-slate-300 mx-auto mb-4" />
                    <p className="text-slate-400 text-lg mb-2 font-semibold">
                      {t('notebook.noArchivedYet')}
                    </p>
                    <p className="text-slate-500 text-sm">
                      {t('notebook.archiveInstructions')}
                    </p>
                  </div>
                ) : (
                  <div className="space-y-3">
                    {Object.values(archivedMistakes).map((question) => (
                      <motion.div
                        key={question.ID}
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        className="p-4 rounded-lg bg-gradient-to-r from-green-50 to-emerald-50 border-2 border-green-300"
                      >
                        <div className="flex items-start justify-between mb-2">
                          <div>
                            <div className="text-xs font-bold text-green-700 uppercase">
                              {question.Topic}
                            </div>
                            <div className="text-xs text-green-600">{question.Subtopic}</div>
                          </div>
                          <div className="text-xs text-green-600 font-bold flex items-center gap-1">
                            <CheckCircle size={14} />
                            {tf('notebook.masteredOn', { date: formatDate(question.archivedAt) })}
                          </div>
                        </div>
                        <div className="text-sm text-green-900 font-medium">
                          {question.Question?.replace(/<[^>]*>/g, '').substring(0, 100)}...
                        </div>
                      </motion.div>
                    ))}
                  </div>
                )}
              </motion.div>
            )}
          </AnimatePresence>
        </div>
      </div>
    </div>
  );
}

=== src/utils/calendarEventManager.js ===
/**
 * Calendar Event Manager (Merged)
 * Combines user-specific storage with spaced repetition and event management
 */

import { auth } from '../firebase/config';

// Event Types
export const EVENT_TYPES = {
  MAJOR_EXAM: 'major_exam',
  SMALL_QUIZ: 'small_quiz',
  STUDY_SUGGESTION: 'study_suggestion',
  MISTAKE_REVIEW: 'mistake_review',
  COMPLETED_ACTIVITY: 'completed_activity',
};

// Event Icons
export const EVENT_ICONS = {
  [EVENT_TYPES.MAJOR_EXAM]: 'üö©',
  [EVENT_TYPES.SMALL_QUIZ]: '‚úèÔ∏è',
  [EVENT_TYPES.STUDY_SUGGESTION]: 'üí°',
  [EVENT_TYPES.MISTAKE_REVIEW]: 'üß†',
  [EVENT_TYPES.COMPLETED_ACTIVITY]: '‚úÖ',
};

/**
 * Get user-specific storage key (Firebase auth aware)
 */
function getUserStorageKey(suffix) {
  const user = auth.currentUser;
  if (!user) return `studyCalendar_guest_${suffix}`;
  return `studyCalendar_${user.uid}_${suffix}`;
}

/**
 * Load calendar data from localStorage (user-specific)
 */
export function loadCalendarData() {
  try {
    const data = localStorage.getItem(getUserStorageKey('data'));
    return data ? JSON.parse(data) : { events: [], completedSessions: {} };
  } catch (error) {
    console.error('Error loading calendar data:', error);
    return { events: [], completedSessions: {} };
  }
}

/**
 * Save calendar data to localStorage (user-specific)
 */
export function saveCalendarData(data) {
  try {
    localStorage.setItem(getUserStorageKey('data'), JSON.stringify(data));
    // Trigger storage event for cross-component updates
    window.dispatchEvent(new Event('calendar-update'));
  } catch (error) {
    console.error('Error saving calendar data:', error);
  }
}

/**
 * Get all calendar events
 */
export function getCalendarEvents() {
  const data = loadCalendarData();
  return data.events || [];
}

/**
 * Save calendar events
 */
export function saveCalendarEvents(events) {
  const data = loadCalendarData();
  data.events = events;
  saveCalendarData(data);
}

/**
 * Calculate spaced repetition interval based on mistake improvement count
 * Uses SM-2 inspired algorithm with mistake-specific adjustments
 */
export function calculateSpacedRepetitionDate(mistake) {
  const now = new Date();
  const improvementCount = mistake.improvementCount || 0;
  
  // Spaced repetition intervals (in days)
  const intervals = {
    0: 1,   // First review: next day
    1: 3,   // Second review: 3 days later
    2: 7,   // Third review: 1 week later
    3: 14,  // Mastered but reinforce: 2 weeks
  };
  
  const daysToAdd = intervals[improvementCount] || 14;
  const reviewDate = new Date(now);
  reviewDate.setDate(reviewDate.getDate() + daysToAdd);
  
  return reviewDate.toISOString().split('T')[0];
}

/**
 * Generate study suggestions based on exam date and topic
 * Returns array of suggestion events with scaled MCQ counts
 */
export function generateExamPrepSuggestions(examDate, topic, subtopic = null) {
  const exam = new Date(examDate);
  const suggestions = [];
  
  // Major Exam Scaling Algorithm
  const prepSchedule = [
    { daysBeforeStart: 10, daysBeforeEnd: 7, mcqCount: 10, phase: 'Warm-up' },
    { daysBeforeStart: 6, daysBeforeEnd: 4, mcqCount: 20, phase: 'Consolidation' },
    { daysBeforeStart: 3, daysBeforeEnd: 1, mcqCount: 40, phase: 'Sprint' },
  ];
  
  prepSchedule.forEach(({ daysBeforeStart, daysBeforeEnd, mcqCount, phase }) => {
    for (let day = daysBeforeStart; day >= daysBeforeEnd; day--) {
      const suggestionDate = new Date(exam);
      suggestionDate.setDate(suggestionDate.getDate() - day);
      
      suggestions.push({
        id: `prep_${topic}_${day}`,
        type: EVENT_TYPES.STUDY_SUGGESTION,
        date: suggestionDate.toISOString().split('T')[0],
        title: `${phase} - ${mcqCount} MCQs`,
        description: `Practice ${mcqCount} questions on ${topic}`,
        topic,
        subtopic,
        mcqCount,
        phase,
        linkedExamId: examDate,
      });
    }
  });
  
  return suggestions;
}

/**
 * Generate quiz prep suggestions (smaller scale)
 */
export function generateQuizPrepSuggestions(quizDate, topic, subtopic) {
  const quiz = new Date(quizDate);
  const suggestions = [];
  
  // Small Quiz: 3-1 days before with 5-15 MCQs on subtopic
  for (let day = 3; day >= 1; day--) {
    const suggestionDate = new Date(quiz);
    suggestionDate.setDate(suggestionDate.getDate() - day);
    
    const mcqCount = day === 1 ? 15 : (day === 2 ? 10 : 5);
    
    suggestions.push({
      id: `quiz_prep_${subtopic}_${day}`,
      type: EVENT_TYPES.STUDY_SUGGESTION,
      date: suggestionDate.toISOString().split('T')[0],
      title: `Quiz Prep - ${mcqCount} MCQs`,
      description: `Review ${mcqCount} questions on ${subtopic}`,
      topic,
      subtopic,
      mcqCount,
      linkedQuizId: quizDate,
    });
  }
  
  return suggestions;
}

/**
 * Add a new event (exam or quiz)
 */
export function addCalendarEvent(event) {
  const events = getCalendarEvents();
  
  // Add the main event
  events.push({
    ...event,
    id: event.id || `${event.type}_${Date.now()}`,
    createdAt: new Date().toISOString(),
  });
  
  // Generate prep suggestions if it's an exam or quiz
  if (event.type === EVENT_TYPES.MAJOR_EXAM) {
    const suggestions = generateExamPrepSuggestions(event.date, event.topic, event.subtopic);
    events.push(...suggestions);
  } else if (event.type === EVENT_TYPES.SMALL_QUIZ) {
    const suggestions = generateQuizPrepSuggestions(event.date, event.topic, event.subtopic);
    events.push(...suggestions);
  }
  
  saveCalendarEvents(events);
  return events;
}

/**
 * Delete an event and its associated suggestions
 */
export function deleteCalendarEvent(eventId) {
  const events = getCalendarEvents();
  const filtered = events.filter(e => 
    e.id !== eventId && 
    e.linkedExamId !== eventId && 
    e.linkedQuizId !== eventId
  );
  saveCalendarEvents(filtered);
  return filtered;
}

/**
 * Mark event as completed
 */
export function completeCalendarEvent(eventId, completedData = {}) {
  const events = getCalendarEvents();
  const event = events.find(e => e.id === eventId);
  
  if (event) {
    // Mark original as completed
    event.completed = true;
    event.completedAt = new Date().toISOString();
    event.completedData = completedData;
    
    // Add completion badge
    events.push({
      id: `completed_${eventId}`,
      type: EVENT_TYPES.COMPLETED_ACTIVITY,
      date: event.date,
      title: `‚úÖ ${event.title}`,
      description: `Completed: ${event.description}`,
      parentEventId: eventId,
    });
  }
  
  saveCalendarEvents(events);
  return events;
}

/**
 * Schedule mistake review based on spaced repetition
 */
export function scheduleMistakeReview(mistake) {
  const events = getCalendarEvents();
  const reviewDate = calculateSpacedRepetitionDate(mistake);
  
  // Remove old review for this mistake
  const filtered = events.filter(e => 
    !(e.type === EVENT_TYPES.MISTAKE_REVIEW && e.mistakeId === mistake.ID)
  );
  
  // Add new review
  filtered.push({
    id: `review_${mistake.ID}_${Date.now()}`,
    type: EVENT_TYPES.MISTAKE_REVIEW,
    date: reviewDate,
    title: `Review Mistake`,
    description: `${mistake.Topic} ‚Üí ${mistake.Subtopic}`,
    topic: mistake.Topic,
    subtopic: mistake.Subtopic,
    mistakeId: mistake.ID,
    improvementCount: mistake.improvementCount || 0,
  });
  
  saveCalendarEvents(filtered);
  return filtered;
}

/**
 * Batch schedule mistake reviews for all active mistakes
 */
export function batchScheduleMistakeReviews(mistakes) {
  const events = getCalendarEvents();
  
  // Remove all existing mistake reviews
  const filtered = events.filter(e => e.type !== EVENT_TYPES.MISTAKE_REVIEW);
  
  // Add new reviews for all mistakes
  mistakes.forEach(mistake => {
    const reviewDate = calculateSpacedRepetitionDate(mistake);
    
    filtered.push({
      id: `review_${mistake.ID}_${Date.now()}`,
      type: EVENT_TYPES.MISTAKE_REVIEW,
      date: reviewDate,
      title: `Review Mistake`,
      description: `${mistake.Topic}${mistake.Subtopic ? ` ‚Üí ${mistake.Subtopic}` : ''}`,
      topic: mistake.Topic,
      subtopic: mistake.Subtopic,
      mistakeId: mistake.ID,
      improvementCount: mistake.improvementCount || 0,
    });
  });
  
  saveCalendarEvents(filtered);
  return filtered;
}

/**
 * Get events for a specific date
 */
export function getEventsForDate(dateStr) {
  const events = getCalendarEvents();
  return events.filter(e => e.date === dateStr && !e.completed);
}

/**
 * Get events for a date range
 */
export function getEventsForDateRange(startDate, endDate) {
  const events = getCalendarEvents();
  const start = new Date(startDate);
  const end = new Date(endDate);
  
  return events.filter(e => {
    const eventDate = new Date(e.date);
    return eventDate >= start && eventDate <= end && !e.completed;
  });
}

/**
 * Get events in range (alias for compatibility)
 */
export function getEventsInRange(startDate, endDate) {
  return getEventsForDateRange(startDate, endDate);
}

/**
 * Get upcoming events (next 7 days)
 */
export function getUpcomingEvents(days = 7) {
  const today = new Date();
  const future = new Date();
  future.setDate(future.getDate() + days);
  
  return getEventsForDateRange(
    today.toISOString().split('T')[0],
    future.toISOString().split('T')[0]
  ).sort((a, b) => new Date(a.date) - new Date(b.date));
}

/**
 * Add completed session to calendar
 */
export function addCompletedSession(date, sessionType, details = {}) {
  const calendarData = loadCalendarData();
  const dateStr = date.toISOString().split('T')[0];
  
  if (!calendarData.completedSessions[dateStr]) {
    calendarData.completedSessions[dateStr] = [];
  }
  
  calendarData.completedSessions[dateStr].push({
    type: sessionType,
    timestamp: new Date().toISOString(),
    ...details
  });
  
  saveCalendarData(calendarData);
}

/**
 * Get completed sessions for a specific date
 */
export function getCompletedSessions(date) {
  const calendarData = loadCalendarData();
  const dateStr = date.toISOString().split('T')[0];
  return calendarData.completedSessions[dateStr] || [];
}

/**
 * Remove event from calendar (alias for compatibility)
 */
export function removeCalendarEvent(eventId) {
  return deleteCalendarEvent(eventId);
}

/**
 * Clear old data (older than 6 months)
 */
export function clearOldCalendarData() {
  const calendarData = loadCalendarData();
  const sixMonthsAgo = new Date();
  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
  
  // Filter old events
  calendarData.events = calendarData.events.filter(event => 
    new Date(event.date) >= sixMonthsAgo
  );
  
  // Filter old completed sessions
  Object.keys(calendarData.completedSessions).forEach(dateStr => {
    if (new Date(dateStr) < sixMonthsAgo) {
      delete calendarData.completedSessions[dateStr];
    }
  });
  
  saveCalendarData(calendarData);
}

=== src/utils/masteryHelper.js ===
/**
 * Mastery Helper Utilities
 * Includes ISRS priority algorithm and Rule of 3 mastery calculations
 */

/**
 * Calculate multi-weighted ISRS (Integrated Spaced Repetition System) priority score
 * Score = (U √ó 0.4) + (D √ó 0.4) + (R √ó 0.2)
 * where U = Urgency (Ebbinghaus curve), D = Difficulty, R = Recency/Context boost
 */
export function calculateMasteryPriority(mistake, recentTopics = []) {
  // 1. URGENCY: Ebbinghaus Forgetting Curve
  const now = Date.now();
  const lastAttemptTime = new Date(mistake.lastAttempted).getTime();
  const daysSinceLastAttempt = Math.max(0, (now - lastAttemptTime) / (1000 * 60 * 60 * 24));

  // U = 2^(days/7) exponential curve
  const U = Math.pow(2, daysSinceLastAttempt / 7);

  // 2. DIFFICULTY: Based on attempt count (max 1.0 at 3+ attempts)
  const D = Math.min(1.0, (mistake.attemptCount || 1) / 3);

  // 3. RECENCY/CONTEXT: Boost if matches recent quiz topics
  let R = 0.5; // Baseline
  if (recentTopics.length > 0 && recentTopics.includes(mistake.Topic)) {
    R = 1.5; // 1.5x boost for contextual relevance
  }

  return (U * 0.4) + (D * 0.4) + (R * 0.2);
}

/**
 * Get mastery state based on Rule of 3 (3 correct answers)
 */
export function getMasteryState(correctCount = 0) {
  if (correctCount >= 3) {
    return { state: 3, label: 'Mastered', color: 'green', bgClass: 'bg-green-50/60', borderClass: 'border-green-300', badgeClass: 'bg-green-100 text-green-700', dotClass: 'bg-green-500' };
  }
  if (correctCount === 2) {
    return { state: 2, label: 'Consolidating', color: 'amber', bgClass: 'bg-amber-50/60', borderClass: 'border-amber-300', badgeClass: 'bg-amber-100 text-amber-700', dotClass: 'bg-amber-400' };
  }
  if (correctCount === 1) {
    return { state: 1, label: 'Improving', color: 'amber', bgClass: 'bg-amber-50/60', borderClass: 'border-amber-300', badgeClass: 'bg-amber-100 text-amber-700', dotClass: 'bg-amber-400' };
  }
  return { state: 0, label: 'New', color: 'red', bgClass: 'bg-white', borderClass: 'border-red-200', badgeClass: 'bg-red-100 text-red-700', dotClass: 'bg-red-500' };
}

/**
 * Load mistakes from localStorage (from MistakeNotebookPage format)
 */
export function loadMistakesFromStorage() {
  try {
    const improvements = JSON.parse(localStorage.getItem('mistake_improvements') || '{}');
    const mistakes = [];

    Object.entries(improvements).forEach(([questionId, data]) => {
      mistakes.push({
        questionId,
        Topic: data.Topic || 'Unknown',
        Question: data.Question || '',
        lastAttempted: data.lastAttempted || new Date().toISOString(),
        attemptCount: data.attemptCount || 0,
        correctCount: data.correctCount || 0,
        lastCorrect: data.lastCorrect || null,
        errorType: data.errorType || 'conceptual', ...data
      });
    });

    return mistakes;
  } catch (error) {
    console.error('Error loading mistakes:', error);
    return [];
  }
}

/**
 * Calculate mastery statistics across all topics
 */
export function calculateMasteryStats(userProfile, mistakes = []) {
  const stats = {
    unseenCount: 0,
    inProgressCount: 0,
    masteredCount: 0,
    totalTopicsMastered: 0,
    topicStats: {},
  };

  // Collect all mistakes by topic
  mistakes.forEach((mistake) => {
    const topic = mistake.Topic || 'Unknown';
    if (!stats.topicStats[topic]) {
      stats.topicStats[topic] = { unseen: 0, inProgress: 0, mastered: 0 };
    }

    const state = getMasteryState(mistake.correctCount);
    if (state.state === 3) {
      stats.masteredCount++;
      stats.topicStats[topic].mastered++;
    } else if (state.state > 0) {
      stats.inProgressCount++;
      stats.topicStats[topic].inProgress++;
    } else {
      stats.unseenCount++;
      stats.topicStats[topic].unseen++;
    }
  });

  // Count topics with mastery
  stats.totalTopicsMastered = Object.values(stats.topicStats).filter(
    (topic) => topic.mastered > 0 && topic.inProgress === 0 && topic.unseen === 0
  ).length;

  return stats;
}

/**
 * Get top N mistakes by ISRS priority score
 */
export function getTopMistakesByPriority(mistakes, recentTopics = [], limit = 3) {
  return mistakes
    .map((m) => ({
      ...m,
      masteryPriority: calculateMasteryPriority(m, recentTopics),
    }))
    .sort((a, b) => b.masteryPriority - a.masteryPriority)
    .slice(0, limit);
}

/**
 * Find the closest topic to mastery
 */
export function findClosestToMastery(mistakes) {
  const topicProgress = {};

  mistakes.forEach((m) => {
    const topic = m.Topic || 'Unknown';
    if (!topicProgress[topic]) {
      topicProgress[topic] = { mastered: 0, total: 0 };
    }
    topicProgress[topic].total++;
    if (getMasteryState(m.correctCount).state === 3) {
      topicProgress[topic].mastered++;
    }
  });

  let closest = null;
  let maxProgress = -1;

  Object.entries(topicProgress).forEach(([topic, data]) => {
    if (data.total > 0) {
      const progress = data.mastered / data.total;
      const questionsUntilMastery = Math.max(0, Math.ceil((data.total - data.mastered) * 3));
      if (progress > maxProgress && progress < 1.0) {
        maxProgress = progress;
        closest = { topic, ...data, questionsUntilMastery };
      }
    }
  });

  return closest;
}


=== src/utils/quizCompletionHandler.js ===
/**
 * Quiz Completion Handler: Handles logging completed quiz sessions to calendar
 */

import { addCompletedSession } from './calendarHelper';

// Session types
export const SESSION_TYPES = {
  TOPICAL: 'Topical',
  MISTAKE_BOOK: 'Mistake Book',
  AI_DAILY_MISSION: 'AI Daily Mission',
  PRACTICE_MODE: 'Practice Mode',
  REVIEW_SESSION: 'Review Session'
};

// Log completed quiz session to calendar
export function logQuizCompletion(quizData) {
  const {
    sessionType = SESSION_TYPES.PRACTICE_MODE,
    questionCount = 0,
    correctAnswers = 0,
    timeSpent = 0,
    topics = [],
    date = new Date(),
    includeMistakeReview = false
  } = quizData;

  // Add main session
  addCompletedSession(date, sessionType, {
    questionCount,
    correctAnswers,
    accuracy: questionCount > 0 ? Math.round((correctAnswers / questionCount) * 100) : 0,
    timeSpent,
    topics
  });

  // Add mistake review session if included
  if (includeMistakeReview) {
    addCompletedSession(date, SESSION_TYPES.MISTAKE_BOOK, {
      reviewed: true,
      timeSpent: Math.floor(timeSpent * 0.3) // Assume 30% of time was mistake review
    });
  }

  // Add AI Daily Mission session if it was an AI mission
  if (sessionType === SESSION_TYPES.AI_DAILY_MISSION) {
    addCompletedSession(date, SESSION_TYPES.AI_DAILY_MISSION, {
      questionCount: 10, // AI missions are always 10 questions
      completed: true,
      timeSpent
    });
  }

  return true;
}

// Get session type from quiz parameters
export function getSessionTypeFromParams(params) {
  if (params.get('includeMistakeReview') === 'true') {
    return SESSION_TYPES.MISTAKE_BOOK;
  }
  
  if (params.get('type') === 'ai-mission') {
    return SESSION_TYPES.AI_DAILY_MISSION;
  }
  
  if (params.get('topicId')) {
    return SESSION_TYPES.TOPICAL;
  }
  
  return SESSION_TYPES.PRACTICE_MODE;
}

// Auto-log quiz completion (call this when quiz is finished)
export function autoLogQuizCompletion(quizResults, queryParams = {}) {
  const sessionType = getSessionTypeFromParams(new URLSearchParams(queryParams));
  
  return logQuizCompletion({
    sessionType,
    questionCount: quizResults.totalQuestions || 0,
    correctAnswers: quizResults.correctAnswers || 0,
    timeSpent: quizResults.timeSpent || 0,
    topics: quizResults.topics || [],
    date: new Date(),
    includeMistakeReview: queryParams.get('includeMistakeReview') === 'true'
  });
}


