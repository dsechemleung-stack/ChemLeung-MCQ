
========== src/components/dashboard/SmartMonthlyCalendar.jsx ==========
import React, { useState, useEffect, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { ChevronLeft, ChevronRight, Plus, Flag, Calendar as CalendarIcon, BookOpen, Brain, CheckCircle, Trash2, X, Sparkles, ThumbsUp, ThumbsDown, Play, Info } from 'lucide-react';
import { calendarService, EVENT_TYPES } from '../../services/calendarService';
import { performanceService } from '../../services/performanceService';
import { quizStorage } from '../../utils/quizStorage';
import { motion, AnimatePresence } from 'framer-motion';
import SpacedRepetitionModal from './SpacedRepetitionModal';

/**
 * SmartMonthlyCalendar - COMPLETE FIX VERSION
 * 
 * FIXES:
 * 1. ‚úÖ Batch review now properly loads ALL repetitions for the selected date
 *    - Fixed line 291: Use repetition.date directly instead of parsing
 * 2. ‚úÖ Better error handling for event deletion with detailed messages
 * 3. ‚úÖ Enhanced console logging for debugging
 */
export default function SmartMonthlyCalendar({ userId, questions = [], onAddEvent }) {
  const navigate = useNavigate();
  const [currentDate, setCurrentDate] = useState(new Date());
  const [calendarData, setCalendarData] = useState({});
  const [loading, setLoading] = useState(true);
  const [selectedDate, setSelectedDate] = useState(null);
  const [hoveredDate, setHoveredDate] = useState(null);
  const [aiRecommendations, setAIRecommendations] = useState([]);
  const [suggestionPreview, setSuggestionPreview] = useState(null);
  const [reviewModal, setReviewModal] = useState(null);
  
  const year = currentDate.getFullYear();
  const month = currentDate.getMonth();
  
  // Load calendar data and AI recommendations
  useEffect(() => {
    loadCalendarData();
    loadAIRecommendations();
  }, [userId, year, month]);

  async function loadCalendarData() {
    if (!userId) return;
    
    try {
      setLoading(true);
      const data = await calendarService.getCalendarData(userId, year, month);
      console.log('üìÖ Calendar data loaded:', data);
      setCalendarData(data);
    } catch (error) {
      console.error('Error loading calendar data:', error);
    } finally {
      setLoading(false);
    }
  }

  async function loadAIRecommendations() {
    if (!userId) return;
    
    try {
      const recommendations = await performanceService.getRecommendations(userId);
      console.log('ü§ñ AI Recommendations loaded:', recommendations);
      setAIRecommendations(recommendations);
    } catch (error) {
      console.error('Error loading AI recommendations:', error);
    }
  }

  // Generate calendar grid
  const calendarGrid = useMemo(() => {
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startingDayOfWeek = firstDay.getDay();
    const daysInMonth = lastDay.getDate();
    
    const grid = [];
    let week = [];
    
    // Add empty cells for days before month starts
    for (let i = 0; i < startingDayOfWeek; i++) {
      week.push(null);
    }
    
    // Add all days in month
    for (let day = 1; day <= daysInMonth; day++) {
      week.push(day);
      
      if (week.length === 7) {
        grid.push(week);
        week = [];
      }
    }
    
    // Add remaining days to complete the last week
    if (week.length > 0) {
      while (week.length < 7) {
        week.push(null);
      }
      grid.push(week);
    }
    
    return grid;
  }, [year, month]);

  const monthName = new Date(year, month, 1).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
  const today = new Date().toISOString().split('T')[0];

  function prevMonth() {
    setCurrentDate(new Date(year, month - 1, 1));
  }

  function nextMonth() {
    setCurrentDate(new Date(year, month + 1, 1));
  }

  function getDateString(day) {
    if (!day) return null;
    return new Date(year, month, day).toISOString().split('T')[0];
  }

  function getDayEvents(day) {
    const dateStr = getDateString(day);
    if (!dateStr) return null;
    return calendarData[dateStr] || null;
  }

  function isToday(day) {
    return getDateString(day) === today;
  }

  function isPast(day) {
    if (!day) return false;
    return getDateString(day) < today;
  }

  // Get available questions for a suggestion
  function getAvailableQuestions(suggestion) {
    if (!questions || questions.length === 0) {
      return { filtered: [], count: 0 };
    }

    let filtered = [...questions];
    
    if (suggestion.topic) {
      filtered = filtered.filter(q => q.Topic === suggestion.topic);
    }
    
    if (suggestion.subtopic) {
      filtered = filtered.filter(q => q.Subtopic === suggestion.subtopic);
    }
    
    return {
      filtered: filtered.slice(0, suggestion.questionCount),
      count: filtered.length,
      requested: suggestion.questionCount
    };
  }

  // Preview suggestion details
  function handleSuggestionPreview(suggestion, event) {
    event?.stopPropagation();
    const questionInfo = getAvailableQuestions(suggestion);
    setSuggestionPreview({ ...suggestion, questionInfo });
  }

  /**
   * Accept an AI recommendation and add it to the calendar
   * @param {Object} recommendation - The AI recommendation to accept
   * @param {Event} event - The click event
   */
  async function handleAcceptRecommendation(recommendation, event) {
    event?.stopPropagation();
    
    try {
      console.log('‚úÖ Accepting AI recommendation:', recommendation);
      
      // Use the service method to create calendar event
      await calendarService.createAIRecommendationEvent(userId, recommendation);
      
      // Reload calendar and recommendations
      await loadCalendarData();
      await loadAIRecommendations();
      
      alert('‚úÖ AI recommendation added to your calendar!');
    } catch (error) {
      console.error('‚ùå Error accepting recommendation:', error);
      alert('Failed to add recommendation to calendar:\n\n' + error.message);
    }
  }

  async function handleDismissRecommendation(recommendationId, event) {
    event?.stopPropagation();
    
    try {
      await performanceService.dismissRecommendation(userId, recommendationId);
      await loadAIRecommendations();
    } catch (error) {
      console.error('Error dismissing recommendation:', error);
    }
  }

  async function handleAIRecommendationClick(aiRec) {
    try {
      let filteredQuestions = questions;
      
      if (aiRec.topic) {
        filteredQuestions = filteredQuestions.filter(q => q.Topic === aiRec.topic);
      }
      
      if (aiRec.subtopic) {
        filteredQuestions = filteredQuestions.filter(q => q.Subtopic === aiRec.subtopic);
      }

      const selectedQuestions = filteredQuestions
        .sort(() => Math.random() - 0.5)
        .slice(0, Math.min(aiRec.questionCount, filteredQuestions.length));

      if (selectedQuestions.length === 0) {
        alert(`No questions available for ${aiRec.topic || 'this topic'}${aiRec.subtopic ? ' - ' + aiRec.subtopic : ''}.`);
        return;
      }

      quizStorage.clearQuizData();
      quizStorage.saveSelectedQuestions(selectedQuestions);
      localStorage.setItem('quiz_mode', 'ai-recommendation');
      localStorage.setItem('quiz_event_id', aiRec.id);
      localStorage.setItem('quiz_timer_enabled', 'true');
      navigate('/quiz');
    } catch (error) {
      console.error('Error starting AI recommendation session:', error);
      alert('Failed to start study session. Please try again.');
    }
  }

  async function handleStudySuggestionClick(suggestion) {
    try {
      // Check if questions are loaded
      if (!questions || questions.length === 0) {
        alert('Questions are still loading. Please wait a moment and try again.');
        return;
      }

      // Filter questions by topic/subtopic if specified
      let filteredQuestions = [...questions];
      
      if (suggestion.topic) {
        filteredQuestions = filteredQuestions.filter(q => q.Topic === suggestion.topic);
      }
      
      if (suggestion.subtopic) {
        filteredQuestions = filteredQuestions.filter(q => q.Subtopic === suggestion.subtopic);
      }

      if (filteredQuestions.length === 0) {
        alert(
          `No questions available for ${suggestion.topic || 'all topics'}${
            suggestion.subtopic ? ' - ' + suggestion.subtopic : ''
          }.\n\nPlease check that your question database includes this topic.`
        );
        return;
      }

      // Select random questions up to the suggested count
      const selectedQuestions = filteredQuestions
        .sort(() => Math.random() - 0.5)
        .slice(0, Math.min(suggestion.questionCount, filteredQuestions.length));

      // Save to quiz storage and navigate
      quizStorage.clearQuizData();
      quizStorage.saveSelectedQuestions(selectedQuestions);
      localStorage.setItem('quiz_mode', 'study-plan');
      localStorage.setItem('quiz_event_id', suggestion.id);
      localStorage.setItem('quiz_event_phase', suggestion.phase || '');
      localStorage.setItem('quiz_timer_enabled', 'true');
      navigate('/quiz');
    } catch (error) {
      console.error('Error starting study session:', error);
      alert('Failed to start study session. Please try again.');
    }
  }

  /**
   * üîß KEY FIX: Spaced repetition click handler
   * 
   * OLD (BROKEN) LINE 291:
   * const dateStr = getDateString(parseInt(repetition.date?.split('-')[2]) || new Date().getDate());
   * ‚ùå This was trying to parse just the day (e.g., "14") and then reconstruct the date
   * ‚ùå This caused it to look at the wrong date in calendarData
   * 
   * NEW (FIXED):
   * const dateStr = repetition.date;
   * ‚úÖ Use the full date string directly from the repetition (e.g., "2026-02-14")
   * ‚úÖ This matches the keys in calendarData correctly
   */
  function handleSpacedRepetitionClick(repetition, event) {
    event?.stopPropagation();
    
    // üéØ FIX: Use the date directly from repetition
    const dateStr = repetition.date; // e.g., "2026-02-14"
    
    // Get ALL repetitions for this date
    const allRepsForDay = calendarData[dateStr]?.repetitions || [];
    
    console.log('üîç Opening review modal:', {
      clickedRep: repetition,
      dateStr,
      totalRepsForDay: allRepsForDay.length,
      allReps: allRepsForDay.map(r => ({ 
        id: r.id, 
        questionId: r.questionId, 
        completed: r.completed,
        topic: r.topic,
        subtopic: r.subtopic
      }))
    });
    
    // Ensure we have the questions array
    if (!questions || questions.length === 0) {
      alert('Questions are still loading. Please wait a moment and try again.');
      return;
    }
    
    // Verify we have repetitions to show
    if (allRepsForDay.length === 0) {
      console.warn('‚ö†Ô∏è No repetitions found for date:', dateStr);
      alert('No review sessions found for this day. This might be a data issue.');
      return;
    }
    
    console.log(`‚úÖ Found ${allRepsForDay.length} repetition(s) for ${dateStr}`);
    
    setReviewModal({
      repetition,
      allRepetitions: allRepsForDay,  // üéØ Pass ALL repetitions
      dateStr
    });
  }

  /**
   * Handle starting review from modal
   */
  async function handleStartReview(reviewMode, questionIds) {
    try {
      console.log('üéØ Starting review:', { reviewMode, questionIds });
      
      const reviewQuestions = questions.filter(q => questionIds.includes(q.ID));
      
      if (reviewQuestions.length === 0) {
        alert('Questions not found in database.');
        return;
      }

      console.log(`‚úÖ Found ${reviewQuestions.length} questions for review`);

      quizStorage.clearQuizData();
      quizStorage.saveSelectedQuestions(reviewQuestions);
      localStorage.setItem('quiz_mode', 'spaced-repetition');
      localStorage.setItem('quiz_review_mode', reviewMode);
      localStorage.setItem('quiz_event_ids', JSON.stringify(
        reviewModal.allRepetitions
          .filter(r => questionIds.includes(r.questionId))
          .map(r => r.id)
      ));
      localStorage.setItem('quiz_timer_enabled', 'true');
      setReviewModal(null);
      navigate('/quiz');
    } catch (error) {
      console.error('Error starting review:', error);
      alert('Failed to start review. Please try again.');
    }
  }

  /**
   * üîß IMPROVED: Delete event with better error handling
   */
  async function handleDeleteEvent(eventId, eventType, event) {
    event.stopPropagation();
    
    const eventTypeLabel = eventType === EVENT_TYPES.MAJOR_EXAM ? 'Major Exam' : 
                          eventType === EVENT_TYPES.SMALL_QUIZ ? 'Small Quiz' : 'Event';
    
    if (!window.confirm(`Delete this ${eventTypeLabel}? This will also remove all linked study suggestions and reviews.`)) {
      return;
    }
    
    try {
      console.log('üóëÔ∏è Deleting event:', eventId);
      await calendarService.deleteEvent(eventId, true); // true = cascade delete
      console.log('‚úÖ Event deleted successfully');
      await loadCalendarData();
      setSelectedDate(null);
      alert('Event deleted successfully!');
    } catch (error) {
      console.error('‚ùå Error deleting event:', error);
      
      // More detailed error message
      let errorMsg = 'Failed to delete event. ';
      if (error.message.includes('permission')) {
        errorMsg += 'Please check that you have permission to delete this event.';
      } else if (error.message.includes('not found')) {
        errorMsg += 'Event not found. It may have already been deleted.';
      } else {
        errorMsg += error.message;
      }
      
      alert(errorMsg);
    }
  }

  // Render day cell content
  function renderDayCell(day) {
    if (!day) return null;
    
    const dateStr = getDateString(day);
    const events = getDayEvents(day);
    const isSelectedDate = selectedDate === dateStr;
    const isHovered = hoveredDate === dateStr;
    const isTodayDate = isToday(day);
    const isPastDate = isPast(day);
    
    const hasExam = events?.exams?.length > 0;
    const hasQuiz = events?.quizzes?.length > 0;
    const hasSuggestions = events?.suggestions?.length > 0;
    const hasRepetitions = events?.repetitions?.length > 0;
    const hasCompletions = events?.completions?.length > 0;
    const hasAIRecommendations = events?.aiRecommendations?.length > 0;
    
    const totalEvents = (events?.exams?.length || 0) + 
                       (events?.quizzes?.length || 0) + 
                       (events?.suggestions?.length || 0) + 
                       (events?.repetitions?.length || 0) +
                       (events?.aiRecommendations?.length || 0);

    return (
      <div className="flex flex-col h-full p-1">
        {/* Day number */}
        <div className={`text-sm font-bold mb-1 ${
          isTodayDate ? 'text-blue-600' : isPastDate ? 'text-slate-400' : 'text-slate-700'
        }`}>
          {day}
        </div>
        
        {/* Event markers */}
        <div className="flex-1 flex flex-col gap-0.5 overflow-hidden">
          {/* Major Exam */}
          {hasExam && events.exams.map((exam, idx) => (
            <div
              key={`exam-${idx}`}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-red-100 text-red-700 font-semibold hover:bg-red-200 transition-colors cursor-pointer group relative"
              onClick={(e) => {
                e.stopPropagation();
                setSelectedDate(dateStr);
              }}
            >
              <Flag size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">{exam.title}</span>
              {!exam.completed && (
                <button
                  onClick={(e) => handleDeleteEvent(exam.id, EVENT_TYPES.MAJOR_EXAM, e)}
                  className="opacity-0 group-hover:opacity-100 transition-opacity"
                >
                  <X size={10} />
                </button>
              )}
            </div>
          ))}
          
          {/* Small Quiz */}
          {hasQuiz && events.quizzes.map((quiz, idx) => (
            <div
              key={`quiz-${idx}`}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-amber-100 text-amber-700 font-semibold hover:bg-amber-200 transition-colors cursor-pointer group relative"
              onClick={(e) => {
                e.stopPropagation();
                setSelectedDate(dateStr);
              }}
            >
              <BookOpen size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">{quiz.title}</span>
              {!quiz.completed && (
                <button
                  onClick={(e) => handleDeleteEvent(quiz.id, EVENT_TYPES.SMALL_QUIZ, e)}
                  className="opacity-0 group-hover:opacity-100 transition-opacity"
                >
                  <X size={10} />
                </button>
              )}
            </div>
          ))}
          
          {/* Study Suggestions */}
          {hasSuggestions && events.suggestions.slice(0, 2).map((suggestion, idx) => (
            <button
              key={`suggestion-${idx}`}
              onClick={(e) => {
                e.stopPropagation();
                handleSuggestionPreview(suggestion, e);
              }}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-blue-100 text-blue-700 font-semibold hover:bg-blue-200 transition-colors group"
            >
              <CalendarIcon size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">{suggestion.questionCount} MCQs</span>
              {suggestion.completed && <CheckCircle size={10} className="text-blue-600" />}
            </button>
          ))}
          
          {/* UPDATED: Spaced Repetition */}
          {hasRepetitions && events.repetitions.slice(0, 1).map((rep, idx) => (
            <button
              key={`rep-${idx}`}
              onClick={(e) => {
                e.stopPropagation();
                handleSpacedRepetitionClick(rep, e);
              }}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-purple-100 text-purple-700 font-semibold hover:bg-purple-200 transition-colors"
            >
              <Brain size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">Review</span>
              {rep.completed && <CheckCircle size={10} className="text-purple-600" />}
            </button>
          ))}

          {/* AI Recommendations */}
          {hasAIRecommendations && events.aiRecommendations.slice(0, 1).map((aiRec, idx) => (
            <button
              key={`ai-${idx}`}
              onClick={(e) => {
                e.stopPropagation();
                handleAIRecommendationClick(aiRec);
              }}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-gradient-to-r from-purple-100 to-pink-100 text-purple-700 font-semibold hover:from-purple-200 hover:to-pink-200 transition-colors border border-purple-300"
            >
              <Sparkles size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">AI: {aiRec.questionCount} MCQs</span>
              {aiRec.completed && <CheckCircle size={10} className="text-purple-600" />}
            </button>
          ))}
          
          {/* Overflow indicator */}
          {totalEvents > 3 && (
            <button
              onClick={(e) => {
                e.stopPropagation();
                setSelectedDate(dateStr);
              }}
              className="text-xs text-slate-500 hover:text-slate-700 font-semibold px-1"
            >
              +{totalEvents - 3} more
            </button>
          )}
          
          {/* Completion dots */}
          {hasCompletions && events.completions.length <= 3 && (
            <div className="flex gap-0.5 mt-auto">
              {events.completions.slice(0, 3).map((comp, idx) => (
                <div
                  key={`comp-${idx}`}
                  className="w-1.5 h-1.5 rounded-full bg-green-500"
                  title={`Completed: ${comp.questionCount} questions`}
                />
              ))}
            </div>
          )}
          {hasCompletions && events.completions.length > 3 && (
            <div className="text-xs text-green-600 font-bold px-1">
              ‚úì {events.completions.length}
            </div>
          )}
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-2xl shadow-lg border-2 border-slate-100 p-6">
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center gap-3">
          <div className="w-12 h-12 rounded-xl bg-blue-100 flex items-center justify-center">
            <CalendarIcon className="text-blue-600" size={28} />
          </div>
          <div>
            <h3 className="text-xl font-black text-slate-800">Smart Study Calendar</h3>
            <p className="text-xs text-slate-500 mt-1">{monthName}</p>
          </div>
        </div>
        
        <div className="flex items-center gap-2">
          <button
            onClick={prevMonth}
            className="p-2 hover:bg-slate-100 rounded-lg transition-all"
          >
            <ChevronLeft size={20} className="text-slate-600" />
          </button>
          <button
            onClick={nextMonth}
            className="p-2 hover:bg-slate-100 rounded-lg transition-all"
          >
            <ChevronRight size={20} className="text-slate-600" />
          </button>
          <button
            onClick={onAddEvent}
            className="ml-2 px-4 py-2 bg-indigo-600 text-white rounded-lg font-bold hover:bg-indigo-700 transition-all flex items-center gap-2"
          >
            <Plus size={16} />
            Add Event
          </button>
        </div>
      </div>

      {/* AI Recommendations Panel */}
      {aiRecommendations.length > 0 && (
        <div className="mb-6 p-4 rounded-xl bg-gradient-to-r from-purple-50 to-pink-50 border-2 border-purple-200">
          <div className="flex items-center gap-2 mb-3">
            <Sparkles className="text-purple-600" size={24} />
            <h4 className="text-lg font-black text-purple-900">AI Study Recommendations</h4>
            <span className="ml-auto text-xs font-bold text-purple-600 bg-white px-2 py-1 rounded-full">
              {aiRecommendations.length} suggestions
            </span>
          </div>
          
          <div className="space-y-2">
            {aiRecommendations.slice(0, 3).map((rec) => (
              <div
                key={rec.id}
                className="bg-white rounded-lg p-3 border border-purple-200"
              >
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <div className="flex items-center gap-2 mb-1">
                      <span className={`px-2 py-0.5 rounded text-xs font-bold ${
                        rec.priority === 'HIGH' ? 'bg-red-100 text-red-700' :
                        rec.priority === 'MEDIUM' ? 'bg-amber-100 text-amber-700' :
                        'bg-blue-100 text-blue-700'
                      }`}>
                        {rec.priority}
                      </span>
                      <span className="font-bold text-sm text-slate-800">
                        {rec.subtopic}
                      </span>
                    </div>
                    <p className="text-xs text-slate-600">{rec.reason}</p>
                    <div className="flex gap-2 mt-2 text-xs text-slate-500">
                      <span>üìÖ Suggested: {new Date(rec.suggestedDate).toLocaleDateString()}</span>
                      <span>‚Ä¢</span>
                      <span>üìä Current: {rec.currentAccuracy}%</span>
                    </div>
                  </div>
                  
                  <div className="flex gap-1 ml-3">
                    <button
                      onClick={(e) => handleAcceptRecommendation(rec, e)}
                      className="p-2 bg-purple-100 hover:bg-purple-200 rounded-lg transition-all"
                      title="Add to calendar"
                    >
                      <ThumbsUp size={16} className="text-purple-600" />
                    </button>
                    <button
                      onClick={(e) => handleDismissRecommendation(rec.id, e)}
                      className="p-2 bg-slate-100 hover:bg-slate-200 rounded-lg transition-all"
                      title="Dismiss"
                    >
                      <ThumbsDown size={16} className="text-slate-600" />
                    </button>
                  </div>
                </div>
              </div>
            ))}
          </div>
          
          {aiRecommendations.length > 3 && (
            <div className="text-center mt-3">
              <button
                className="text-sm font-bold text-purple-600 hover:text-purple-700"
                onClick={() => {/* Show all recommendations modal */}}
              >
                View all {aiRecommendations.length} recommendations ‚Üí
              </button>
            </div>
          )}
        </div>
      )}

      {/* Legend */}
      <div className="grid grid-cols-2 md:grid-cols-6 gap-2 mb-4 text-xs">
        <div className="flex items-center gap-1.5">
          <Flag size={12} className="text-red-600" />
          <span className="text-slate-600 font-semibold">Major Exam</span>
        </div>
        <div className="flex items-center gap-1.5">
          <BookOpen size={12} className="text-amber-600" />
          <span className="text-slate-600 font-semibold">Quiz</span>
        </div>
        <div className="flex items-center gap-1.5">
          <CalendarIcon size={12} className="text-blue-600" />
          <span className="text-slate-600 font-semibold">Study Plan</span>
        </div>
        <div className="flex items-center gap-1.5">
          <Brain size={12} className="text-purple-600" />
          <span className="text-slate-600 font-semibold">Review</span>
        </div>
        <div className="flex items-center gap-1.5">
          <Sparkles size={12} className="text-purple-600" />
          <span className="text-slate-600 font-semibold">AI Suggestion</span>
        </div>
        <div className="flex items-center gap-1.5">
          <div className="w-2 h-2 rounded-full bg-green-500" />
          <span className="text-slate-600 font-semibold">Completed</span>
        </div>
      </div>

      {/* Calendar Grid */}
      <div className="border-2 border-slate-200 rounded-lg overflow-hidden">
        {/* Day headers */}
        <div className="grid grid-cols-7 bg-slate-50 border-b-2 border-slate-200">
          {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day) => (
            <div
              key={day}
              className="p-2 text-center text-sm font-black text-slate-600 uppercase tracking-wider"
            >
              {day}
            </div>
          ))}
        </div>

        {/* Calendar body */}
        {calendarGrid.map((week, weekIdx) => (
          <div key={weekIdx} className="grid grid-cols-7 border-b border-slate-200 last:border-b-0">
            {week.map((day, dayIdx) => (
              <div
                key={dayIdx}
                onMouseEnter={() => day && setHoveredDate(getDateString(day))}
                onMouseLeave={() => setHoveredDate(null)}
                onClick={() => day && setSelectedDate(getDateString(day))}
                className={`min-h-[100px] border-r border-slate-200 last:border-r-0 transition-all cursor-pointer ${
                  day ? 'hover:bg-slate-50' : 'bg-slate-50/30'
                } ${
                  isToday(day) ? 'bg-blue-50 ring-2 ring-inset ring-blue-400' : ''
                } ${
                  isPast(day) ? 'opacity-60' : ''
                }`}
              >
                {renderDayCell(day)}
              </div>
            ))}
          </div>
        ))}
      </div>

      {/* Suggestion Preview Modal */}
      <AnimatePresence>
        {suggestionPreview && (
          <div 
            className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4"
            onClick={() => setSuggestionPreview(null)}
          >
            <motion.div
              initial={{ opacity: 0, scale: 0.95 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.95 }}
              onClick={(e) => e.stopPropagation()}
              className="bg-white rounded-2xl shadow-2xl max-w-lg w-full"
            >
              <div className="p-6 border-b flex justify-between items-center">
                <h3 className="text-lg font-black text-slate-800">Study Session Preview</h3>
                <button
                  onClick={() => setSuggestionPreview(null)}
                  className="p-2 hover:bg-slate-100 rounded-lg transition-all"
                >
                  <X size={20} />
                </button>
              </div>
              
              <div className="p-6 space-y-4">
                {/* Session Info */}
                <div className="p-4 rounded-lg bg-blue-50 border-2 border-blue-200">
                  <h4 className="font-bold text-blue-900 mb-2">{suggestionPreview.title}</h4>
                  <div className="space-y-1 text-sm text-blue-800">
                    <div className="flex items-center gap-2">
                      <CalendarIcon size={16} />
                      <span>Phase: <strong>{suggestionPreview.phase}</strong></span>
                    </div>
                    {suggestionPreview.topic && (
                      <div className="flex items-center gap-2">
                        <BookOpen size={16} />
                        <span>
                          <strong>{suggestionPreview.topic}</strong>
                          {suggestionPreview.subtopic && ` ‚Üí ${suggestionPreview.subtopic}`}
                        </span>
                      </div>
                    )}
                  </div>
                </div>

                {/* Questions Available */}
                <div className={`p-4 rounded-lg border-2 ${
                  suggestionPreview.questionInfo.count >= suggestionPreview.questionInfo.requested
                    ? 'bg-green-50 border-green-200'
                    : 'bg-amber-50 border-amber-200'
                }`}>
                  <div className="flex items-center gap-2 mb-2">
                    <Info size={18} className={
                      suggestionPreview.questionInfo.count >= suggestionPreview.questionInfo.requested
                        ? 'text-green-600'
                        : 'text-amber-600'
                    } />
                    <span className={`font-bold ${
                      suggestionPreview.questionInfo.count >= suggestionPreview.questionInfo.requested
                        ? 'text-green-900'
                        : 'text-amber-900'
                    }`}>
                      Questions Available
                    </span>
                  </div>
                  <p className={`text-sm ${
                    suggestionPreview.questionInfo.count >= suggestionPreview.questionInfo.requested
                      ? 'text-green-800'
                      : 'text-amber-800'
                  }`}>
                    <strong>{suggestionPreview.questionInfo.count}</strong> questions found
                    {suggestionPreview.questionInfo.count < suggestionPreview.questionInfo.requested && (
                      <span> (requested: {suggestionPreview.questionInfo.requested})</span>
                    )}
                  </p>
                  
                  {suggestionPreview.questionInfo.count === 0 && (
                    <p className="text-xs text-red-600 mt-2">
                      ‚ö†Ô∏è No questions available for this topic/subtopic combination.
                    </p>
                  )}
                </div>

                {/* Action Button */}
                <button
                  onClick={() => {
                    handleStudySuggestionClick(suggestionPreview);
                    setSuggestionPreview(null);
                  }}
                  disabled={suggestionPreview.questionInfo.count === 0}
                  className="w-full px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold transition-all flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <Play size={18} fill="currentColor" />
                  Start Practice ({Math.min(suggestionPreview.questionInfo.count, suggestionPreview.questionInfo.requested)} Questions)
                </button>
              </div>
            </motion.div>
          </div>
        )}
      </AnimatePresence>

      {/* Day Detail Modal */}
      <AnimatePresence>
        {selectedDate && (
          <div 
            className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4"
            onClick={() => setSelectedDate(null)}
          >
            <motion.div
              initial={{ opacity: 0, scale: 0.95 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.95 }}
              onClick={(e) => e.stopPropagation()}
              className="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] overflow-y-auto"
            >
              <div className="sticky top-0 bg-white border-b p-4 flex justify-between items-center">
                <h3 className="text-lg font-black text-slate-800">
                  {new Date(selectedDate).toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    month: 'long', 
                    day: 'numeric',
                    year: 'numeric'
                  })}
                </h3>
                <button
                  onClick={() => setSelectedDate(null)}
                  className="p-2 hover:bg-slate-100 rounded-lg transition-all"
                >
                  <X size={20} />
                </button>
              </div>
              
              <div className="p-6 space-y-4">
                {calendarData[selectedDate] ? (
                  <>
                    {/* UPDATED: Exams with event type delete */}
                    {calendarData[selectedDate].exams?.map((exam) => (
                      <div key={exam.id} className="p-4 rounded-lg bg-red-50 border-2 border-red-200">
                        <div className="flex items-center justify-between mb-2">
                          <div className="flex items-center gap-2">
                            <Flag className="text-red-600" size={20} />
                            <span className="font-bold text-red-900">{exam.title}</span>
                          </div>
                          {!exam.completed && (
                            <button
                              onClick={(e) => handleDeleteEvent(exam.id, EVENT_TYPES.MAJOR_EXAM, e)}
                              className="p-2 hover:bg-red-100 rounded-lg transition-all"
                              title="Delete exam and study plan"
                            >
                              <Trash2 size={16} className="text-red-600" />
                            </button>
                          )}
                        </div>
                        {exam.topic && (
                          <div className="text-sm text-red-700">
                            üìö Topic: {exam.topic}
                            {exam.subtopic && ` ‚Üí ${exam.subtopic}`}
                          </div>
                        )}
                      </div>
                    ))}
                    
                    {/* UPDATED: Quizzes with event type delete */}
                    {calendarData[selectedDate].quizzes?.map((quiz) => (
                      <div key={quiz.id} className="p-4 rounded-lg bg-amber-50 border-2 border-amber-200">
                        <div className="flex items-center justify-between mb-2">
                          <div className="flex items-center gap-2">
                            <BookOpen className="text-amber-600" size={20} />
                            <span className="font-bold text-amber-900">{quiz.title}</span>
                          </div>
                          {!quiz.completed && (
                            <button
                              onClick={(e) => handleDeleteEvent(quiz.id, EVENT_TYPES.SMALL_QUIZ, e)}
                              className="p-2 hover:bg-amber-100 rounded-lg transition-all"
                              title="Delete quiz and study plan"
                            >
                              <Trash2 size={16} className="text-amber-600" />
                            </button>
                          )}
                        </div>
                        {quiz.topic && (
                          <div className="text-sm text-amber-700">
                            üìö Topic: {quiz.topic}
                            {quiz.subtopic && ` ‚Üí ${quiz.subtopic}`}
                          </div>
                        )}
                      </div>
                    ))}
                    
                    {/* Study Suggestions */}
                    {calendarData[selectedDate].suggestions?.map((suggestion) => {
                      const questionInfo = getAvailableQuestions(suggestion);
                      return (
                        <div
                          key={suggestion.id}
                          className="p-4 rounded-lg bg-blue-50 border-2 border-blue-200"
                        >
                          <div className="flex items-center gap-2 mb-2">
                            <CalendarIcon className="text-blue-600" size={20} />
                            <span className="font-bold text-blue-900">{suggestion.title}</span>
                            {suggestion.completed && <CheckCircle size={16} className="text-blue-600 ml-auto" />}
                          </div>
                          <div className="text-sm text-blue-700 mb-3 space-y-1">
                            <div>üìù {suggestion.questionCount} questions ‚Ä¢ Phase: {suggestion.phase}</div>
                            {suggestion.topic && (
                              <div>üìö {suggestion.topic}{suggestion.subtopic && ` ‚Üí ${suggestion.subtopic}`}</div>
                            )}
                            <div className={questionInfo.count >= questionInfo.requested ? 'text-green-600' : 'text-amber-600'}>
                              ‚úì {questionInfo.count} questions available
                            </div>
                          </div>
                          {!suggestion.completed && (
                            <button
                              onClick={() => {
                                handleStudySuggestionClick(suggestion);
                                setSelectedDate(null);
                              }}
                              disabled={questionInfo.count === 0}
                              className="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-bold transition-all flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                              <Play size={16} fill="currentColor" />
                              Start Practice
                            </button>
                          )}
                        </div>
                      );
                    })}
                    
                    {/* UPDATED: Spaced Repetitions */}
                    {calendarData[selectedDate].repetitions?.map((rep) => (
                      <button
                        key={rep.id}
                        onClick={(e) => {
                          handleSpacedRepetitionClick(rep, e);
                          setSelectedDate(null);
                        }}
                        className="w-full p-4 rounded-lg bg-purple-50 border-2 border-purple-200 hover:bg-purple-100 transition-all text-left"
                      >
                        <div className="flex items-center gap-2 mb-2">
                          <Brain className="text-purple-600" size={20} />
                          <span className="font-bold text-purple-900">{rep.title}</span>
                          {rep.completed && <CheckCircle size={16} className="text-purple-600 ml-auto" />}
                        </div>
                        <div className="text-sm text-purple-700">
                          Review interval: {rep.interval} days ‚Ä¢ Attempt #{rep.attemptCount}
                        </div>
                      </button>
                    ))}

                    {/* AI Recommendations */}
                    {calendarData[selectedDate].aiRecommendations?.map((aiRec) => (
                      <div
                        key={aiRec.id}
                        className="p-4 rounded-lg bg-gradient-to-r from-purple-50 to-pink-50 border-2 border-purple-200"
                      >
                        <div className="flex items-center gap-2 mb-2">
                          <Sparkles className="text-purple-600" size={20} />
                          <span className="font-bold text-purple-900">{aiRec.title}</span>
                        </div>
                        <div className="text-sm text-purple-700 mb-3">
                          {aiRec.description}
                        </div>
                        <div className="flex gap-2">
                          <button
                            onClick={() => {
                              handleAIRecommendationClick(aiRec);
                              setSelectedDate(null);
                            }}
                            className="flex-1 px-3 py-2 bg-purple-600 text-white rounded-lg font-bold hover:bg-purple-700 transition-all flex items-center justify-center gap-2"
                          >
                            <Play size={16} fill="currentColor" />
                            Start Practice
                          </button>
                        </div>
                      </div>
                    ))}
                    
                    {/* Completions */}
                    {calendarData[selectedDate].completions?.length > 0 && (
                      <div className="p-4 rounded-lg bg-green-50 border-2 border-green-200">
                        <div className="flex items-center gap-2 mb-2">
                          <CheckCircle className="text-green-600" size={20} />
                          <span className="font-bold text-green-900">
                            {calendarData[selectedDate].completions.length} Session(s) Completed
                          </span>
                        </div>
                        <div className="space-y-1">
                          {calendarData[selectedDate].completions.map((comp, idx) => (
                            <div key={idx} className="text-sm text-green-700">
                              {comp.questionCount} questions ‚Ä¢ {Math.round(comp.accuracy * 100)}% accuracy
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </>
                ) : (
                  <div className="text-center py-8 text-slate-400">
                    No events scheduled for this day
                  </div>
                )}
              </div>
            </motion.div>
          </div>
        )}
      </AnimatePresence>

      {/* NEW: Spaced Repetition Review Modal */}
      {reviewModal && (
        <SpacedRepetitionModal
          repetition={reviewModal.repetition}
          allRepetitions={reviewModal.allRepetitions}
          questions={questions}
          onClose={() => setReviewModal(null)}
          onStartReview={handleStartReview}
        />
      )}
    </div>
  );
}

========== src/components/dashboard/StudyPlannerCalendar.jsx ==========
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { 
  Calendar as CalendarIcon, ChevronLeft, ChevronRight, Plus, X, 
  Clock, Target, Brain, Zap, CheckCircle, Edit2, Trash2, AlertCircle 
} from 'lucide-react';
import { useLanguage } from '../../contexts/LanguageContext';
import {
  EVENT_TYPES,
  EVENT_ICONS,
  getCalendarEvents,
  addCalendarEvent,
  deleteCalendarEvent,
  getEventsForDate,
  scheduleMistakeReview,
  batchScheduleMistakeReviews,
} from '../../utils/calendarEventManager';

/**
 * Enhanced Study Planner Calendar
 * - Monthly calendar view with interactive events
 * - Exam/quiz scheduling with automatic prep suggestions
 * - Mistake-driven spaced repetition
 * - Deep linking to quiz page with parameters
 * - Real-time updates
 */
export default function StudyPlannerCalendar({ mistakes = [] }) {
  const { t } = useLanguage();
  const navigate = useNavigate();
  
  // State management
  const [currentDate, setCurrentDate] = useState(new Date());
  const [events, setEvents] = useState([]);
  const [selectedDate, setSelectedDate] = useState(null);
  const [showAddEventModal, setShowAddEventModal] = useState(false);
  const [hoveredDate, setHoveredDate] = useState(null);
  
  // Load events from storage
  useEffect(() => {
    loadEvents();
    
    // Listen for storage updates from other components
    const handleStorageUpdate = () => loadEvents();
    window.addEventListener('calendar-update', handleStorageUpdate);
    window.addEventListener('storage', handleStorageUpdate);
    
    return () => {
      window.removeEventListener('calendar-update', handleStorageUpdate);
      window.removeEventListener('storage', handleStorageUpdate);
    };
  }, []);
  
  // Auto-schedule mistake reviews when mistakes change
  useEffect(() => {
    if (mistakes.length > 0) {
      // Schedule reviews for all active mistakes
      const activeMistakes = mistakes.filter(m => (m.improvementCount || 0) < 3);
      if (activeMistakes.length > 0) {
        batchScheduleMistakeReviews(activeMistakes);
        loadEvents();
      }
    }
  }, [mistakes]);
  
  const loadEvents = () => {
    setEvents(getCalendarEvents());
  };
  
  // Calendar calculations
  const { year, month } = useMemo(() => ({
    year: currentDate.getFullYear(),
    month: currentDate.getMonth(),
  }), [currentDate]);
  
  const monthName = useMemo(() => 
    currentDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })
  , [currentDate]);
  
  const daysInMonth = useMemo(() => 
    new Date(year, month + 1, 0).getDate()
  , [year, month]);
  
  const firstDayOfMonth = useMemo(() => 
    new Date(year, month, 1).getDay()
  , [year, month]);
  
  const calendarDays = useMemo(() => {
    const days = [];
    const prevMonthDays = new Date(year, month, 0).getDate();
    
    // Previous month days
    for (let i = firstDayOfMonth - 1; i >= 0; i--) {
      days.push({
        day: prevMonthDays - i,
        isCurrentMonth: false,
        date: new Date(year, month - 1, prevMonthDays - i),
      });
    }
    
    // Current month days
    for (let day = 1; day <= daysInMonth; day++) {
      days.push({
        day,
        isCurrentMonth: true,
        date: new Date(year, month, day),
      });
    }
    
    // Next month days
    const remainingDays = 42 - days.length; // 6 rows √ó 7 days
    for (let day = 1; day <= remainingDays; day++) {
      days.push({
        day,
        isCurrentMonth: false,
        date: new Date(year, month + 1, day),
      });
    }
    
    return days;
  }, [year, month, daysInMonth, firstDayOfMonth]);
  
  // Get events for each day
  const eventsMap = useMemo(() => {
    const map = {};
    events.forEach(event => {
      if (!map[event.date]) map[event.date] = [];
      map[event.date].push(event);
    });
    return map;
  }, [events]);
  
  // Navigation
  const goToPreviousMonth = () => {
    setCurrentDate(new Date(year, month - 1, 1));
  };
  
  const goToNextMonth = () => {
    setCurrentDate(new Date(year, month + 1, 1));
  };
  
  const goToToday = () => {
    setCurrentDate(new Date());
  };
  
  // Event handling
  const handleDateClick = (dateObj) => {
    const dateStr = dateObj.date.toISOString().split('T')[0];
    const dayEvents = eventsMap[dateStr] || [];
    
    if (dayEvents.length > 0) {
      setSelectedDate({ dateStr, events: dayEvents });
    } else {
      setSelectedDate({ dateStr, events: [] });
      setShowAddEventModal(true);
    }
  };
  
  const handleEventClick = (event) => {
    // Route to quiz page with appropriate parameters
    if (event.type === EVENT_TYPES.STUDY_SUGGESTION || event.type === EVENT_TYPES.MISTAKE_REVIEW) {
      // Prepare quiz based on event type
      if (event.mistakeId) {
        // Navigate to mistake review
        navigate('/mistakes');
      } else {
        // Navigate to topic practice
        navigate(`/quiz?topic=${encodeURIComponent(event.topic)}&subtopic=${encodeURIComponent(event.subtopic || '')}&count=${event.mcqCount || 10}&mode=practice`);
      }
    }
  };
  
  const isToday = (dateObj) => {
    const today = new Date();
    return dateObj.date.toDateString() === today.toDateString();
  };
  
  const getTodayDateStr = () => new Date().toISOString().split('T')[0];
  
  return (
    <div className="bg-white rounded-2xl shadow-lg border-2 border-indigo-100 overflow-hidden">
      {/* Header */}
      <div className="bg-gradient-to-r from-indigo-600 to-purple-600 p-6">
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-3">
            <div className="w-12 h-12 rounded-xl bg-white/20 backdrop-blur flex items-center justify-center">
              <CalendarIcon className="text-white" size={28} />
            </div>
            <div>
              <h3 className="text-2xl font-black text-white">Study Planner</h3>
              <p className="text-sm text-indigo-100">Smart scheduling with spaced repetition</p>
            </div>
          </div>
          <button
            onClick={() => setShowAddEventModal(true)}
            className="px-4 py-2 bg-white text-indigo-600 rounded-lg font-bold text-sm hover:bg-indigo-50 transition-all flex items-center gap-2"
          >
            <Plus size={18} />
            Add Exam/Quiz
          </button>
        </div>
        
        {/* Month Navigation */}
        <div className="flex items-center justify-between">
          <button
            onClick={goToPreviousMonth}
            className="p-2 hover:bg-white/20 rounded-lg transition-all text-white"
          >
            <ChevronLeft size={24} />
          </button>
          
          <div className="flex items-center gap-3">
            <h4 className="text-2xl font-black text-white">{monthName}</h4>
            <button
              onClick={goToToday}
              className="px-3 py-1 bg-white/20 hover:bg-white/30 rounded-lg text-sm font-bold text-white transition-all"
            >
              Today
            </button>
          </div>
          
          <button
            onClick={goToNextMonth}
            className="p-2 hover:bg-white/20 rounded-lg transition-all text-white"
          >
            <ChevronRight size={24} />
          </button>
        </div>
      </div>
      
      {/* Calendar Grid */}
      <div className="p-6">
        {/* Day Headers */}
        <div className="grid grid-cols-7 gap-2 mb-2">
          {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day) => (
            <div key={day} className="text-center text-xs font-black text-slate-500 py-2">
              {day}
            </div>
          ))}
        </div>
        
        {/* Calendar Days */}
        <div className="grid grid-cols-7 gap-2">
          {calendarDays.map((dateObj, idx) => {
            const dateStr = dateObj.date.toISOString().split('T')[0];
            const dayEvents = eventsMap[dateStr] || [];
            const hasEvents = dayEvents.length > 0;
            const isTodayDate = isToday(dateObj);
            
            return (
              <button
                key={idx}
                onClick={() => dateObj.isCurrentMonth && handleDateClick(dateObj)}
                onMouseEnter={() => setHoveredDate(dateStr)}
                onMouseLeave={() => setHoveredDate(null)}
                disabled={!dateObj.isCurrentMonth}
                className={`
                  relative aspect-square rounded-xl p-2 transition-all
                  ${dateObj.isCurrentMonth ? 'bg-slate-50 hover:bg-indigo-50 cursor-pointer' : 'bg-slate-50/30'}
                  ${isTodayDate ? 'ring-2 ring-indigo-500 bg-indigo-100' : ''}
                  ${hasEvents ? 'border-2 border-purple-300' : 'border-2 border-transparent'}
                `}
              >
                {/* Day Number */}
                <div className={`text-sm font-bold mb-1 ${
                  dateObj.isCurrentMonth 
                    ? isTodayDate ? 'text-indigo-700' : 'text-slate-700'
                    : 'text-slate-300'
                }`}>
                  {dateObj.day}
                </div>
                
                {/* Event Indicators */}
                {hasEvents && dateObj.isCurrentMonth && (
                  <div className="flex flex-wrap gap-1 items-center justify-center">
                    {dayEvents.slice(0, 3).map((event, i) => (
                      <span key={i} className="text-lg leading-none">
                        {EVENT_ICONS[event.type]}
                      </span>
                    ))}
                    {dayEvents.length > 3 && (
                      <span className="text-xs font-black text-purple-600">
                        +{dayEvents.length - 3}
                      </span>
                    )}
                  </div>
                )}
                
                {/* Hover Tooltip */}
                {hoveredDate === dateStr && dayEvents.length > 0 && (
                  <div className="absolute left-0 top-full mt-2 z-50 bg-slate-900 text-white text-xs rounded-lg p-2 shadow-2xl min-w-[200px]">
                    <div className="font-bold mb-1">{dayEvents.length} event{dayEvents.length > 1 ? 's' : ''}</div>
                    {dayEvents.slice(0, 3).map((e, i) => (
                      <div key={i} className="truncate opacity-90">
                        {EVENT_ICONS[e.type]} {e.title}
                      </div>
                    ))}
                  </div>
                )}
              </button>
            );
          })}
        </div>
        
        {/* Legend */}
        <div className="mt-6 pt-6 border-t border-slate-200">
          <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-3">
            Event Types
          </div>
          <div className="grid grid-cols-2 md:grid-cols-5 gap-3">
            {Object.entries(EVENT_TYPES).map(([key, type]) => (
              <div key={key} className="flex items-center gap-2 text-sm">
                <span className="text-xl">{EVENT_ICONS[type]}</span>
                <span className="text-slate-600 font-semibold">
                  {key.split('_').map(w => w[0] + w.slice(1).toLowerCase()).join(' ')}
                </span>
              </div>
            ))}
          </div>
        </div>
      </div>
      
      {/* Date Detail Modal */}
      {selectedDate && !showAddEventModal && (
        <DateDetailModal
          dateStr={selectedDate.dateStr}
          events={selectedDate.events}
          onClose={() => setSelectedDate(null)}
          onEventClick={handleEventClick}
          onAddEvent={() => setShowAddEventModal(true)}
          onDeleteEvent={(eventId) => {
            deleteCalendarEvent(eventId);
            loadEvents();
          }}
        />
      )}
      
      {/* Add Event Modal */}
      {showAddEventModal && (
        <AddEventModal
          initialDate={selectedDate?.dateStr}
          onClose={() => {
            setShowAddEventModal(false);
            setSelectedDate(null);
          }}
          onSave={() => {
            loadEvents();
            setShowAddEventModal(false);
            setSelectedDate(null);
          }}
        />
      )}
    </div>
  );
}

/**
 * Date Detail Modal - Shows events for a selected date
 */
function DateDetailModal({ dateStr, events, onClose, onEventClick, onAddEvent, onDeleteEvent }) {
  const { t } = useLanguage();
  
  const formattedDate = useMemo(() => {
    const date = new Date(dateStr);
    return date.toLocaleDateString('en-US', { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    });
  }, [dateStr]);
  
  return (
    <div
      className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4"
      onClick={onClose}
    >
      <div
        className="bg-white rounded-2xl shadow-2xl w-full max-w-2xl max-h-[80vh] overflow-hidden"
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="bg-gradient-to-r from-indigo-600 to-purple-600 p-6 text-white">
          <div className="flex items-center justify-between mb-2">
            <h3 className="text-2xl font-black">{formattedDate}</h3>
            <button
              onClick={onClose}
              className="p-2 hover:bg-white/20 rounded-lg transition-all"
            >
              <X size={24} />
            </button>
          </div>
          <p className="text-indigo-100 text-sm">
            {events.length} scheduled event{events.length !== 1 ? 's' : ''}
          </p>
        </div>
        
        {/* Events List */}
        <div className="p-6 overflow-y-auto max-h-[60vh]">
          {events.length === 0 ? (
            <div className="text-center py-12">
              <CalendarIcon size={48} className="text-slate-300 mx-auto mb-4" />
              <p className="text-slate-400 font-semibold mb-4">No events scheduled</p>
              <button
                onClick={onAddEvent}
                className="px-6 py-3 bg-indigo-600 text-white rounded-lg font-bold hover:bg-indigo-700 transition-all"
              >
                <Plus size={18} className="inline mr-2" />
                Add Event
              </button>
            </div>
          ) : (
            <div className="space-y-3">
              {events.map((event) => (
                <EventCard
                  key={event.id}
                  event={event}
                  onClick={() => onEventClick(event)}
                  onDelete={() => onDeleteEvent(event.id)}
                />
              ))}
              
              <button
                onClick={onAddEvent}
                className="w-full py-3 border-2 border-dashed border-slate-300 rounded-lg text-slate-600 font-bold hover:border-indigo-400 hover:text-indigo-600 transition-all flex items-center justify-center gap-2"
              >
                <Plus size={18} />
                Add Another Event
              </button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

/**
 * Event Card Component
 */
function EventCard({ event, onClick, onDelete }) {
  const getEventStyle = () => {
    switch (event.type) {
      case EVENT_TYPES.MAJOR_EXAM:
        return 'bg-gradient-to-r from-red-50 to-orange-50 border-red-300';
      case EVENT_TYPES.SMALL_QUIZ:
        return 'bg-gradient-to-r from-blue-50 to-indigo-50 border-blue-300';
      case EVENT_TYPES.STUDY_SUGGESTION:
        return 'bg-gradient-to-r from-yellow-50 to-amber-50 border-yellow-300';
      case EVENT_TYPES.MISTAKE_REVIEW:
        return 'bg-gradient-to-r from-purple-50 to-pink-50 border-purple-300';
      case EVENT_TYPES.COMPLETED_ACTIVITY:
        return 'bg-gradient-to-r from-green-50 to-emerald-50 border-green-300';
      default:
        return 'bg-slate-50 border-slate-300';
    }
  };
  
  const isClickable = event.type === EVENT_TYPES.STUDY_SUGGESTION || 
                      event.type === EVENT_TYPES.MISTAKE_REVIEW;
  
  return (
    <div
      className={`p-4 rounded-xl border-2 ${getEventStyle()} ${isClickable ? 'cursor-pointer' : ''}`}
      onClick={isClickable ? onClick : undefined}
    >
      <div className="flex items-start justify-between mb-2">
        <div className="flex items-center gap-2">
          <span className="text-2xl">{EVENT_ICONS[event.type]}</span>
          <div>
            <h4 className="font-black text-slate-800">{event.title}</h4>
            <p className="text-sm text-slate-600">{event.description}</p>
          </div>
        </div>
        
        {(event.type === EVENT_TYPES.MAJOR_EXAM || event.type === EVENT_TYPES.SMALL_QUIZ) && (
          <button
            onClick={(e) => {
              e.stopPropagation();
              onDelete();
            }}
            className="p-2 hover:bg-red-100 rounded-lg transition-all text-red-600"
          >
            <Trash2 size={16} />
          </button>
        )}
      </div>
      
      {event.mcqCount && (
        <div className="flex items-center gap-2 text-sm font-bold text-slate-700">
          <Target size={14} />
          {event.mcqCount} MCQs
        </div>
      )}
      
      {isClickable && (
        <div className="mt-2 text-xs font-bold text-indigo-600">
          Click to start practice ‚Üí
        </div>
      )}
    </div>
  );
}

/**
 * Add Event Modal
 */
function AddEventModal({ initialDate, onClose, onSave }) {
  const [eventType, setEventType] = useState(EVENT_TYPES.MAJOR_EXAM);
  const [title, setTitle] = useState('');
  const [date, setDate] = useState(initialDate || new Date().toISOString().split('T')[0]);
  const [topic, setTopic] = useState('');
  const [subtopic, setSubtopic] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    if (!title || !date || !topic) {
      alert('Please fill in all required fields');
      return;
    }
    
    const newEvent = {
      type: eventType,
      title,
      date,
      topic,
      subtopic,
      description: `${topic}${subtopic ? ` ‚Üí ${subtopic}` : ''}`,
    };
    
    addCalendarEvent(newEvent);
    onSave();
  };
  
  return (
    <div
      className="fixed inset-0 bg-black/60 flex items-center justify-center z-[60] p-4"
      onClick={onClose}
    >
      <div
        className="bg-white rounded-2xl shadow-2xl w-full max-w-lg"
        onClick={(e) => e.stopPropagation()}
      >
        <form onSubmit={handleSubmit}>
          {/* Header */}
          <div className="bg-gradient-to-r from-indigo-600 to-purple-600 p-6 text-white rounded-t-2xl">
            <div className="flex items-center justify-between mb-2">
              <h3 className="text-2xl font-black">Add Exam/Quiz</h3>
              <button
                type="button"
                onClick={onClose}
                className="p-2 hover:bg-white/20 rounded-lg transition-all"
              >
                <X size={24} />
              </button>
            </div>
            <p className="text-indigo-100 text-sm">
              Automatic prep suggestions will be generated
            </p>
          </div>
          
          {/* Form */}
          <div className="p-6 space-y-4">
            {/* Event Type */}
            <div>
              <label className="block text-sm font-black text-slate-700 mb-2">
                Event Type *
              </label>
              <div className="grid grid-cols-2 gap-2">
                <button
                  type="button"
                  onClick={() => setEventType(EVENT_TYPES.MAJOR_EXAM)}
                  className={`p-3 rounded-lg border-2 font-bold text-sm transition-all ${
                    eventType === EVENT_TYPES.MAJOR_EXAM
                      ? 'border-red-500 bg-red-50 text-red-700'
                      : 'border-slate-200 text-slate-600 hover:border-slate-300'
                  }`}
                >
                  üö© Major Exam
                </button>
                <button
                  type="button"
                  onClick={() => setEventType(EVENT_TYPES.SMALL_QUIZ)}
                  className={`p-3 rounded-lg border-2 font-bold text-sm transition-all ${
                    eventType === EVENT_TYPES.SMALL_QUIZ
                      ? 'border-blue-500 bg-blue-50 text-blue-700'
                      : 'border-slate-200 text-slate-600 hover:border-slate-300'
                  }`}
                >
                  ‚úèÔ∏è Small Quiz
                </button>
              </div>
            </div>
            
            {/* Title */}
            <div>
              <label className="block text-sm font-black text-slate-700 mb-2">
                Title *
              </label>
              <input
                type="text"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                placeholder="e.g., Chemistry Midterm Exam"
                required
                className="w-full px-4 py-3 border-2 border-slate-200 rounded-lg focus:border-indigo-500 focus:outline-none font-semibold"
              />
            </div>
            
            {/* Date */}
            <div>
              <label className="block text-sm font-black text-slate-700 mb-2">
                Date *
              </label>
              <input
                type="date"
                value={date}
                onChange={(e) => setDate(e.target.value)}
                required
                className="w-full px-4 py-3 border-2 border-slate-200 rounded-lg focus:border-indigo-500 focus:outline-none font-semibold"
              />
            </div>
            
            {/* Topic */}
            <div>
              <label className="block text-sm font-black text-slate-700 mb-2">
                Topic *
              </label>
              <input
                type="text"
                value={topic}
                onChange={(e) => setTopic(e.target.value)}
                placeholder="e.g., Organic Chemistry"
                required
                className="w-full px-4 py-3 border-2 border-slate-200 rounded-lg focus:border-indigo-500 focus:outline-none font-semibold"
              />
            </div>
            
            {/* Subtopic */}
            <div>
              <label className="block text-sm font-black text-slate-700 mb-2">
                Subtopic (Optional)
              </label>
              <input
                type="text"
                value={subtopic}
                onChange={(e) => setSubtopic(e.target.value)}
                placeholder="e.g., Reaction Mechanisms"
                className="w-full px-4 py-3 border-2 border-slate-200 rounded-lg focus:border-indigo-500 focus:outline-none font-semibold"
              />
            </div>
            
            {/* Info Box */}
            <div className="bg-indigo-50 border-2 border-indigo-200 rounded-lg p-4">
              <div className="flex items-start gap-2">
                <Zap size={16} className="text-indigo-600 flex-shrink-0 mt-0.5" />
                <div className="text-xs text-indigo-800">
                  <strong className="font-black">Automatic Suggestions:</strong>
                  {eventType === EVENT_TYPES.MAJOR_EXAM ? (
                    <> Study plan with 10/20/40 MCQs (10-7, 6-4, 3-1 days before)</>
                  ) : (
                    <> Quick review with 5-15 MCQs (3-1 days before)</>
                  )}
                </div>
              </div>
            </div>
          </div>
          
          {/* Footer */}
          <div className="p-6 border-t border-slate-200 flex gap-3">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 px-4 py-3 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg font-bold transition-all"
            >
              Cancel
            </button>
            <button
              type="submit"
              className="flex-1 px-4 py-3 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-700 hover:to-purple-700 text-white rounded-lg font-bold transition-all flex items-center justify-center gap-2"
            >
              <CheckCircle size={18} />
              Create Event
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}

========== src/components/dashboard/EventCreationModal.jsx ==========
import React, { useState, useMemo, useEffect } from 'react';
import { X, Flag, BookOpen, Calendar, Tag, Layers, ArrowUpCircle } from 'lucide-react';
import { motion } from 'framer-motion';
import { calendarService } from '../../services/calendarService';

/**
 * EventCreationModal - COMPLETE FIX
 * 
 * FIXES:
 * ‚úÖ Topic filter LEFT, Subtopic filter RIGHT (side-by-side)
 * ‚úÖ Subtopics auto-filter when topics change (BUG FIX!)
 * ‚úÖ Selected subtopics are cleared when they're no longer in available list
 * ‚úÖ YYYY/MM/DD or MM/DD date format
 */
export default function EventCreationModal({ userId, questions = [], onClose, onEventCreated }) {
  const [eventType, setEventType] = useState('major_exam');
  const [title, setTitle] = useState('');
  const [dateInput, setDateInput] = useState('');
  const [selectedTopics, setSelectedTopics] = useState([]);
  const [selectedSubtopics, setSelectedSubtopics] = useState([]);
  const [loading, setLoading] = useState(false);

  // Extract unique topics from questions (sorted)
  const allTopics = useMemo(() => {
    const topicSet = new Set(questions.map(q => q.Topic).filter(Boolean));
    return Array.from(topicSet).sort();
  }, [questions]);

  // Extract subtopics based on selected topics
  const availableSubtopics = useMemo(() => {
    if (selectedTopics.length === 0) {
      // Show all subtopics if no topic filter
      const subtopicSet = new Set(
        questions
          .filter(q => q.Subtopic)
          .map(q => q.Subtopic)
      );
      return Array.from(subtopicSet).sort();
    }
    
    // Only show subtopics from selected topics
    const subtopicSet = new Set(
      questions
        .filter(q => selectedTopics.includes(q.Topic) && q.Subtopic)
        .map(q => q.Subtopic)
    );
    return Array.from(subtopicSet).sort();
  }, [questions, selectedTopics]);

  /**
   * üîß CRITICAL BUG FIX: Auto-filter selected subtopics when available subtopics change
   * 
   * Problem: When user selects topics 01-07, then changes to 01-04,
   * the subtopics from topics 05-07 remain selected even though they're no longer available
   * 
   * Solution: Filter out any selected subtopics that are no longer in the available list
   */
  useEffect(() => {
    if (selectedSubtopics.length > 0) {
      // Keep only subtopics that are still available
      const validSubtopics = selectedSubtopics.filter(sub => 
        availableSubtopics.includes(sub)
      );
      
      // Only update if something actually changed
      if (validSubtopics.length !== selectedSubtopics.length) {
        const removed = selectedSubtopics.filter(s => !validSubtopics.includes(s));
        console.log('üîß Auto-filtering subtopics:', {
          before: selectedSubtopics,
          after: validSubtopics,
          removed: removed
        });
        setSelectedSubtopics(validSubtopics);
      }
    }
  }, [availableSubtopics]); // Trigger when available subtopics change

  function parseDate(input) {
    if (!input) return null;
    
    const parts = input.split('/');
    const currentYear = new Date().getFullYear();
    
    let year, month, day;
    
    if (parts.length === 2) {
      [month, day] = parts;
      year = currentYear.toString();
    } else if (parts.length === 3) {
      [year, month, day] = parts;
      if (year.length === 2) {
        const yearNum = parseInt(year);
        year = yearNum <= 30 ? `20${year}` : `19${year}`;
      }
    } else {
      return null;
    }
    
    const y = parseInt(year);
    const m = parseInt(month);
    const d = parseInt(day);
    
    if (isNaN(y) || isNaN(m) || isNaN(d)) return null;
    if (m < 1 || m > 12) return null;
    if (d < 1 || d > 31) return null;
    if (y < 2000 || y > 2100) return null;
    
    return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
  }

  function handleDateInput(value) {
    const cleaned = value.replace(/[^\d\/]/g, '');
    let formatted = cleaned;
    const digits = cleaned.replace(/\//g, '');
    
    if (digits.length <= 2) {
      formatted = digits;
    } else if (digits.length <= 4) {
      if (parseInt(digits.substring(0, 2)) <= 12) {
        formatted = digits.substring(0, 2) + '/' + digits.substring(2);
      } else {
        formatted = digits;
      }
    } else if (digits.length <= 6) {
      formatted = digits.substring(0, 4) + '/' + digits.substring(4);
    } else {
      formatted = digits.substring(0, 4) + '/' + digits.substring(4, 6) + '/' + digits.substring(6, 8);
    }
    
    if (formatted.length <= 10) {
      setDateInput(formatted);
    }
  }

  function toggleTopic(topic) {
    setSelectedTopics(prev => 
      prev.includes(topic) 
        ? prev.filter(t => t !== topic)
        : [...prev, topic]
    );
  }

  function selectTopicsUpTo(targetTopic) {
    const targetIndex = allTopics.indexOf(targetTopic);
    if (targetIndex === -1) return;
    setSelectedTopics(allTopics.slice(0, targetIndex + 1));
  }

  function toggleSubtopic(subtopic) {
    setSelectedSubtopics(prev => 
      prev.includes(subtopic)
        ? prev.filter(s => s !== subtopic)
        : [...prev, subtopic]
    );
  }

  function selectSubtopicsUpTo(targetSubtopic) {
    const targetIndex = availableSubtopics.indexOf(targetSubtopic);
    if (targetIndex === -1) return;
    setSelectedSubtopics(availableSubtopics.slice(0, targetIndex + 1));
  }

  function generateTitle() {
    if (title.trim()) return title.trim();
    
    if (eventType === 'major_exam') {
      if (selectedTopics.length === 0) {
        return 'Comprehensive Exam';
      } else {
        return `${selectedTopics.slice(0, 2).join(', ')}${selectedTopics.length > 2 ? '...' : ''} Exam`;
      }
    } else {
      if (selectedTopics.length === 0) {
        return 'Comprehensive Quiz';
      } else {
        return `${selectedTopics.slice(0, 2).join(', ')}${selectedTopics.length > 2 ? '...' : ''} Quiz`;
      }
    }
  }

  async function handleSubmit(e) {
    e.preventDefault();
    
    const parsedDate = parseDate(dateInput);
    
    if (!parsedDate) {
      alert('Please enter a valid date:\n\n' +
            '‚Ä¢ MM/DD (uses current year)\n' +
            '‚Ä¢ YYYY/MM/DD (specific year)\n\n' +
            'Examples: 12/25 or 2024/12/25');
      return;
    }

    const selectedDate = new Date(parsedDate);
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    if (selectedDate < today) {
      const proceed = window.confirm('‚ö†Ô∏è Warning: This date is in the past.\n\nDo you want to continue anyway?');
      if (!proceed) return;
    }

    setLoading(true);
    
    try {
      const eventData = {
        date: parsedDate,
        title: generateTitle(),
        topics: selectedTopics.length > 0 ? selectedTopics : null,
        subtopics: selectedSubtopics.length > 0 ? selectedSubtopics : null
      };

      console.log('üìù Creating event:', eventData);

      if (eventType === 'major_exam') {
        await calendarService.addMajorExam(userId, eventData);
      } else {
        await calendarService.addSmallQuiz(userId, eventData);
      }

      alert('‚úÖ Event created successfully!');
      onEventCreated();
      onClose();
    } catch (error) {
      console.error('‚ùå Error creating event:', error);
      alert('Failed to create event:\n\n' + error.message);
    } finally {
      setLoading(false);
    }
  }

  return (
    <div 
      className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4"
      onClick={onClose}
    >
      <motion.div
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        onClick={(e) => e.stopPropagation()}
        className="bg-white rounded-2xl shadow-2xl max-w-5xl w-full max-h-[90vh] overflow-y-auto"
      >
        {/* Header */}
        <div className="border-b p-6 flex justify-between items-center sticky top-0 bg-white z-10 rounded-t-2xl">
          <div>
            <h2 className="text-2xl font-black text-slate-800">Add Event</h2>
            <p className="text-sm text-slate-500 mt-1">Schedule an exam or quiz and get a smart study plan</p>
          </div>
          <button
            onClick={onClose}
            className="p-2 hover:bg-slate-100 rounded-lg transition-all"
          >
            <X size={24} />
          </button>
        </div>

        {/* Form */}
        <form onSubmit={handleSubmit} className="p-6 space-y-6">
          {/* Event Type Selector */}
          <div>
            <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-3">
              Event Type
            </label>
            <div className="grid grid-cols-2 gap-3">
              <button
                type="button"
                onClick={() => setEventType('major_exam')}
                className={`p-4 rounded-xl border-2 transition-all ${
                  eventType === 'major_exam'
                    ? 'border-red-500 bg-red-50 shadow-lg'
                    : 'border-slate-200 hover:border-slate-300'
                }`}
              >
                <div className="flex items-center gap-3 mb-2">
                  <Flag className={eventType === 'major_exam' ? 'text-red-600' : 'text-slate-400'} size={20} />
                  <span className={`font-bold ${
                    eventType === 'major_exam' ? 'text-red-900' : 'text-slate-600'
                  }`}>
                    Major Exam
                  </span>
                </div>
                <div className="text-xs text-slate-500 text-left">
                  10-day study plan with scaled intensity
                </div>
              </button>

              <button
                type="button"
                onClick={() => setEventType('small_quiz')}
                className={`p-4 rounded-xl border-2 transition-all ${
                  eventType === 'small_quiz'
                    ? 'border-amber-500 bg-amber-50 shadow-lg'
                    : 'border-slate-200 hover:border-slate-300'
                }`}
              >
                <div className="flex items-center gap-3 mb-2">
                  <BookOpen className={eventType === 'small_quiz' ? 'text-amber-600' : 'text-slate-400'} size={20} />
                  <span className={`font-bold ${
                    eventType === 'small_quiz' ? 'text-amber-900' : 'text-slate-600'
                  }`}>
                    Small Quiz
                  </span>
                </div>
                <div className="text-xs text-slate-500 text-left">
                  3-day focused review plan
                </div>
              </button>
            </div>
          </div>

          {/* Date Input */}
          <div>
            <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-2">
              Exam/Quiz Date <span className="text-red-500">*</span>
            </label>
            <input
              type="text"
              value={dateInput}
              onChange={(e) => handleDateInput(e.target.value)}
              placeholder="MM/DD or YYYY/MM/DD (e.g., 12/25 or 2024/12/25)"
              maxLength={10}
              className="w-full px-4 py-3 rounded-lg border-2 border-slate-200 focus:border-indigo-500 focus:outline-none transition-all font-medium text-lg"
              required
            />
            <p className="text-xs text-slate-500 mt-2">
              üìÖ Quick: <strong>12/25</strong> ‚Üí {new Date().getFullYear()}/12/25 | Full: <strong>2024/12/25</strong>
            </p>
          </div>

          {/* Topic & Subtopic Filters - SIDE BY SIDE */}
          <div>
            <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-3">
              Filter Topics & Subtopics
            </label>

            <div className="grid grid-cols-2 gap-4">
              {/* LEFT: Topic Filter */}
              <div>
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <Tag size={14} className="text-slate-600" />
                    <span className="text-sm font-bold text-slate-600">
                      Topics ({selectedTopics.length}/{allTopics.length})
                    </span>
                  </div>
                  <button
                    type="button"
                    onClick={() => setSelectedTopics([])}
                    className="text-xs text-indigo-600 hover:text-indigo-700 font-bold"
                  >
                    Clear
                  </button>
                </div>

                <div className="border-2 border-slate-200 rounded-lg p-3 bg-white h-96 overflow-y-auto">
                  <div className="space-y-2">
                    {allTopics.map((topic) => (
                      <div key={topic} className="flex items-center gap-2">
                        <button
                          type="button"
                          onClick={() => toggleTopic(topic)}
                          className={`flex-1 px-3 py-2 rounded-lg text-left transition-all flex items-center gap-2 text-sm ${
                            selectedTopics.includes(topic)
                              ? 'bg-indigo-100 border-2 border-indigo-500 text-indigo-900 font-bold'
                              : 'bg-slate-50 border-2 border-transparent hover:bg-slate-100'
                          }`}
                        >
                          <div className={`w-4 h-4 rounded border-2 flex items-center justify-center flex-shrink-0 ${
                            selectedTopics.includes(topic)
                              ? 'border-indigo-600 bg-indigo-600'
                              : 'border-slate-300'
                          }`}>
                            {selectedTopics.includes(topic) && (
                              <svg className="w-3 h-3 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
                              </svg>
                            )}
                          </div>
                          <span className="truncate">{topic}</span>
                        </button>

                        <button
                          type="button"
                          onClick={() => selectTopicsUpTo(topic)}
                          title={`Select all topics up to and including "${topic}"`}
                          className="px-2 py-2 bg-purple-100 hover:bg-purple-200 rounded-lg transition-all flex items-center gap-1 text-xs font-bold text-purple-700 flex-shrink-0"
                        >
                          <ArrowUpCircle size={14} />
                        </button>
                      </div>
                    ))}
                  </div>
                </div>
                <p className="text-xs text-slate-500 mt-2 italic">
                  üí° Click "Up to" to select all topics up to that item
                </p>
              </div>

              {/* RIGHT: Subtopic Filter */}
              <div>
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <Layers size={14} className="text-slate-600" />
                    <span className="text-sm font-bold text-slate-600">
                      Subtopics ({selectedSubtopics.length}/{availableSubtopics.length})
                    </span>
                  </div>
                  <button
                    type="button"
                    onClick={() => setSelectedSubtopics([])}
                    className="text-xs text-indigo-600 hover:text-indigo-700 font-bold"
                  >
                    Clear
                  </button>
                </div>

                <div className="border-2 border-slate-200 rounded-lg p-3 bg-white h-96 overflow-y-auto">
                  {availableSubtopics.length === 0 ? (
                    <div className="flex items-center justify-center h-full text-slate-400 text-sm">
                      {selectedTopics.length === 0 ? 'Select topics to filter subtopics' : 'No subtopics available'}
                    </div>
                  ) : (
                    <div className="space-y-2">
                      {availableSubtopics.map((subtopic) => (
                        <div key={subtopic} className="flex items-center gap-2">
                          <button
                            type="button"
                            onClick={() => toggleSubtopic(subtopic)}
                            className={`flex-1 px-3 py-2 rounded-lg text-left transition-all flex items-center gap-2 text-sm ${
                              selectedSubtopics.includes(subtopic)
                                ? 'bg-purple-100 border-2 border-purple-500 text-purple-900 font-bold'
                                : 'bg-slate-50 border-2 border-transparent hover:bg-slate-100'
                            }`}
                          >
                            <div className={`w-4 h-4 rounded border-2 flex items-center justify-center flex-shrink-0 ${
                              selectedSubtopics.includes(subtopic)
                                ? 'border-purple-600 bg-purple-600'
                                : 'border-slate-300'
                            }`}>
                              {selectedSubtopics.includes(subtopic) && (
                                <svg className="w-3 h-3 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
                                </svg>
                              )}
                            </div>
                            <span className="truncate">{subtopic}</span>
                          </button>

                          <button
                            type="button"
                            onClick={() => selectSubtopicsUpTo(subtopic)}
                            title={`Select all subtopics up to and including "${subtopic}"`}
                            className="px-2 py-2 bg-purple-100 hover:bg-purple-200 rounded-lg transition-all flex items-center gap-1 text-xs font-bold text-purple-700 flex-shrink-0"
                          >
                            <ArrowUpCircle size={14} />
                          </button>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
                <p className="text-xs text-slate-500 mt-2 italic">
                  üí° Subtopics auto-filter based on selected topics
                </p>
              </div>
            </div>
          </div>

          {/* Custom Title */}
          <div>
            <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-2">
              Custom Title <span className="text-slate-400 text-xs font-normal">(Optional)</span>
            </label>
            <input
              type="text"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder={`Auto: ${generateTitle()}`}
              className="w-full px-4 py-3 rounded-lg border-2 border-slate-200 focus:border-indigo-500 focus:outline-none transition-all font-medium"
            />
          </div>

          {/* Study Plan Preview */}
          <div className={`p-4 rounded-xl border-2 ${
            eventType === 'major_exam' 
              ? 'bg-red-50 border-red-200' 
              : 'bg-amber-50 border-amber-200'
          }`}>
            <div className="flex items-center gap-2 mb-3">
              <Calendar className={eventType === 'major_exam' ? 'text-red-600' : 'text-amber-600'} size={18} />
              <span className={`font-bold text-sm ${
                eventType === 'major_exam' ? 'text-red-900' : 'text-amber-900'
              }`}>
                Auto-Generated Study Plan
              </span>
            </div>
            {eventType === 'major_exam' ? (
              <ul className="space-y-1 text-xs text-red-700">
                <li>‚Ä¢ <strong>10-7 days before:</strong> 10 MCQs/day (Warm-up)</li>
                <li>‚Ä¢ <strong>6-4 days before:</strong> 20 MCQs/day (Consolidation)</li>
                <li>‚Ä¢ <strong>3-1 days before:</strong> 40 MCQs/day (Sprint Intensity)</li>
              </ul>
            ) : (
              <ul className="space-y-1 text-xs text-amber-700">
                <li>‚Ä¢ <strong>3 days before:</strong> 5 MCQs (Initial Review)</li>
                <li>‚Ä¢ <strong>2 days before:</strong> 10 MCQs (Topic Focus)</li>
                <li>‚Ä¢ <strong>1 day before:</strong> 15 MCQs (Final Polish)</li>
              </ul>
            )}
            <p className="text-xs font-bold mt-2 text-slate-700">
              üìö Focus: {
                selectedTopics.length === 0 ? 'All Topics' : `${selectedTopics.length} topic${selectedTopics.length > 1 ? 's' : ''}`
              }
              {selectedSubtopics.length > 0 && ` ‚Ä¢ ${selectedSubtopics.length} subtopic${selectedSubtopics.length > 1 ? 's' : ''}`}
            </p>
          </div>

          {/* Submit Buttons */}
          <div className="flex gap-3 pt-4 border-t">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 px-6 py-3 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-xl font-bold transition-all"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={loading}
              className={`flex-1 px-6 py-3 rounded-xl font-bold transition-all text-white ${
                eventType === 'major_exam'
                  ? 'bg-red-600 hover:bg-red-700'
                  : 'bg-amber-600 hover:bg-amber-700'
              } disabled:opacity-50 disabled:cursor-not-allowed shadow-lg`}
            >
              {loading ? 'Creating...' : `Create Event & Study Plan`}
            </button>
          </div>
        </form>
      </motion.div>
    </div>
  );
}

========== src/components/dashboard/CalendarHeatmap.jsx ==========
import React, { useMemo } from 'react';
import { Calendar } from 'lucide-react';
import { useLanguage } from '../../contexts/LanguageContext';

/**
 * CalendarHeatmap: 30-day mistake-clearing activity visualization
 * Shows daily progress on a calendar grid with color intensity
 */
export default function CalendarHeatmap({ mistakes = [] }) {
  const { t } = useLanguage();

  const activityMap = useMemo(() => {
    const map = {};
    const now = new Date();

    // Initialize 30-day map
    for (let i = 0; i < 30; i++) {
      const d = new Date(now);
      d.setDate(d.getDate() - i);
      const dateStr = d.toISOString().split('T')[0];
      map[dateStr] = 0;
    }

    // Count correct answers by date
    mistakes.forEach((mistake) => {
      if (mistake.lastCorrect) {
        const dateStr = new Date(mistake.lastCorrect).toISOString().split('T')[0];
        if (map[dateStr] !== undefined) {
          map[dateStr]++;
        }
      }
    });

    return map;
  }, [mistakes]);

  const days = Object.entries(activityMap).reverse();
  const maxActivity = Math.max(...Object.values(activityMap), 1);

  const getColor = (count) => {
    const intensity = count / maxActivity;
    if (intensity === 0) return 'bg-slate-100 hover:bg-slate-200';
    if (intensity < 0.33) return 'bg-green-200 hover:bg-green-300';
    if (intensity < 0.67) return 'bg-green-400 hover:bg-green-500';
    return 'bg-green-600 hover:bg-green-700';
  };

  const getTotalCleared = () => Object.values(activityMap).reduce((a, b) => a + b, 0);

  return (
    <div className="bg-white rounded-2xl shadow-lg border-2 border-slate-100 p-6">
      {/* Header */}
      <div className="flex items-center gap-3 mb-6">
        <div className="w-12 h-12 rounded-xl bg-green-100 flex items-center justify-center">
          <Calendar className="text-green-600" size={28} />
        </div>
        <div>
          <h3 className="text-xl font-black text-slate-800">Activity Tracker</h3>
          <p className="text-xs text-slate-500 mt-1">30-day mistake-clearing consistency</p>
        </div>
      </div>

      {/* Stats Row */}
      <div className="grid grid-cols-2 gap-4 mb-6">
        <div className="text-center">
          <div className="text-sm text-slate-600 font-medium mb-1">Total Cleared (30 days)</div>
          <div className="text-3xl font-black text-green-600">{getTotalCleared()}</div>
        </div>
        <div className="text-center">
          <div className="text-sm text-slate-600 font-medium mb-1">Busiest Day</div>
          <div className="text-3xl font-black text-green-600">{maxActivity}</div>
        </div>
      </div>

      {/* Calendar Grid */}
      <div className="overflow-x-auto mb-4">
        <div className="inline-block min-w-full">
          <div className="grid gap-1" style={{ gridTemplateColumns: 'repeat(7, 1fr)' }}>
            {/* Day headers */}
            {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day, idx) => (
              <div
                key={`header-${idx}`}
                className="text-center text-xs font-bold text-slate-400 h-6 flex items-center justify-center"
              >
                {day.slice(0, 1)}
              </div>
            ))}

            {/* Calendar cells */}
            {days.map(([dateStr, count]) => {
              const date = new Date(dateStr);
              const dayOfWeek = date.getDay();
              const isToday = dateStr === new Date().toISOString().split('T')[0];

              return (
                <div
                  key={dateStr}
                  className={`w-8 h-8 rounded flex items-center justify-center text-xs font-bold text-slate-700 transition-all cursor-pointer ring-2 ring-offset-1 ${
                    isToday ? 'ring-indigo-400 ring-offset-slate-100' : 'ring-transparent'
                  } ${getColor(count)}`}
                  title={`${dateStr}: ${count} question${count !== 1 ? 's' : ''} cleared`}
                >
                  {count > 0 && <span className="text-white font-black text-xs">{count}</span>}
                </div>
              );
            })}
          </div>
        </div>
      </div>

      {/* Legend */}
      <div className="flex items-center justify-center gap-3 text-xs text-slate-600 pt-4 border-t border-slate-200">
        <span className="font-medium">Less</span>
        <div className="flex gap-1">
          {[0, 0.33, 0.67, 1.0].map((i, idx) => (
            <div
              key={idx}
              className={`w-3 h-3 rounded transition-colors ${getColor(i * maxActivity).split(' ')[0]}`}
            />
          ))}
        </div>
        <span className="font-medium">More</span>
      </div>

      {/* Motivational Message */}
      <div className="mt-4 pt-4 border-t border-slate-200 bg-green-50 rounded-lg p-3">
        <p className="text-sm text-green-800 font-semibold text-center">
          üî• Keep the streak going! Consistency builds mastery.{' '}
        </p>
      </div>
    </div>
  );
}


========== src/services/calendarService.js ==========
/**
 * Calendar Service - FIXED FOR FLAT FIRESTORE STRUCTURE
 * 
 * CRITICAL FIXES:
 * 1. ‚úÖ Uses /calendar_events/{eventId} instead of /calendar/{userId}/events/{eventId}
 * 2. ‚úÖ Properly stores userId as a field
 * 3. ‚úÖ Fixed AI recommendation to calendar conversion
 * 4. ‚úÖ Fixed spaced repetition visibility
 */

import { db } from '../firebase/config';
import { 
  collection, 
  doc, 
  setDoc, 
  getDoc, 
  getDocs, 
  query, 
  where, 
  orderBy,
  deleteDoc,
  updateDoc,
  writeBatch,
  Timestamp
} from 'firebase/firestore';
import { performanceService } from './performanceService';

export const EVENT_TYPES = {
  MAJOR_EXAM: 'major_exam',
  SMALL_QUIZ: 'small_quiz',
  STUDY_SUGGESTION: 'study_suggestion',
  SPACED_REPETITION: 'spaced_repetition',
  AI_RECOMMENDATION: 'ai_recommendation'
};

/**
 * Add a major exam to the calendar
 */
export async function addMajorExam(userId, examData) {
  const { date, title, topics, subtopics } = examData;
  
  const examEvent = {
    id: `exam_${Date.now()}`,
    userId,  // CRITICAL: Add userId as field
    type: EVENT_TYPES.MAJOR_EXAM,
    date,
    title,
    topics,
    subtopics,
    completed: false,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };

  console.log('üìù Creating exam event:', examEvent);

  // Save main event to flat collection
  await setDoc(
    doc(db, 'calendar_events', examEvent.id),
    examEvent
  );

  // Generate study plan (10-day)
  const studyPlan = generateMajorExamPlan(examEvent);
  
  // Save study suggestions
  for (const suggestion of studyPlan) {
    await setDoc(
      doc(db, 'calendar_events', suggestion.id),
      suggestion
    );
  }

  console.log('‚úÖ Created exam + study plan:', { exam: examEvent.id, suggestions: studyPlan.length });

  return { examEvent, studyPlan };
}

/**
 * Add a small quiz to the calendar
 */
export async function addSmallQuiz(userId, quizData) {
  const { date, title, topics, subtopics } = quizData;
  
  const quizEvent = {
    id: `quiz_${Date.now()}`,
    userId,  // CRITICAL: Add userId as field
    type: EVENT_TYPES.SMALL_QUIZ,
    date,
    title,
    topics,
    subtopics,
    completed: false,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };

  console.log('üìù Creating quiz event:', quizEvent);

  // Save main event
  await setDoc(
    doc(db, 'calendar_events', quizEvent.id),
    quizEvent
  );

  // Generate study plan (3-day)
  const studyPlan = generateSmallQuizPlan(quizEvent);
  
  // Save study suggestions
  for (const suggestion of studyPlan) {
    await setDoc(
      doc(db, 'calendar_events', suggestion.id),
      suggestion
    );
  }

  console.log('‚úÖ Created quiz + study plan:', { quiz: quizEvent.id, suggestions: studyPlan.length });

  return { quizEvent, studyPlan };
}

/**
 * Generate major exam study plan (10 days before)
 */
function generateMajorExamPlan(examEvent) {
  const examDate = new Date(examEvent.date);
  const suggestions = [];
  
  // 10-day plan with scaled intensity
  const schedule = [
    { days: [10, 9, 8, 7], count: 10, phase: 'Warm-up' },
    { days: [6, 5, 4], count: 20, phase: 'Consolidation' },
    { days: [3, 2, 1], count: 40, phase: 'Sprint' }
  ];
  
  schedule.forEach(({ days, count, phase }) => {
    days.forEach(daysBefore => {
      const suggestionDate = new Date(examDate);
      suggestionDate.setDate(suggestionDate.getDate() - daysBefore);
      
      suggestions.push({
        id: `suggestion_${examEvent.id}_day${daysBefore}`,
        userId: examEvent.userId,  // CRITICAL: Include userId
        type: EVENT_TYPES.STUDY_SUGGESTION,
        parentEventId: examEvent.id,
        linkedEventId: examEvent.id,
        date: suggestionDate.toISOString().split('T')[0],
        title: `${phase} - ${count} MCQs`,
        description: `Day ${daysBefore} before exam`,
        questionCount: count,
        phase,
        topics: examEvent.topics,
        subtopics: examEvent.subtopics,
        completed: false,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      });
    });
  });
  
  return suggestions;
}

/**
 * Generate small quiz study plan (3 days before)
 */
function generateSmallQuizPlan(quizEvent) {
  const quizDate = new Date(quizEvent.date);
  const suggestions = [];
  
  const schedule = [
    { day: 3, count: 5, phase: 'Initial Review' },
    { day: 2, count: 10, phase: 'Topic Focus' },
    { day: 1, count: 15, phase: 'Final Polish' }
  ];
  
  schedule.forEach(({ day, count, phase }) => {
    const suggestionDate = new Date(quizDate);
    suggestionDate.setDate(suggestionDate.getDate() - day);
    
    suggestions.push({
      id: `suggestion_${quizEvent.id}_day${day}`,
      userId: quizEvent.userId,  // CRITICAL: Include userId
      type: EVENT_TYPES.STUDY_SUGGESTION,
      parentEventId: quizEvent.id,
      linkedEventId: quizEvent.id,
      date: suggestionDate.toISOString().split('T')[0],
      title: `${phase} - ${count} MCQs`,
      description: `Day ${day} before quiz`,
      questionCount: count,
      phase,
      topics: quizEvent.topics,
      subtopics: quizEvent.subtopics,
      completed: false,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    });
  });
  
  return suggestions;
}

/**
 * üîß NEW: Create AI recommendation as calendar event
 */
export async function createAIRecommendationEvent(userId, recommendation) {
  const aiEvent = {
    id: `ai_rec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    userId,
    type: EVENT_TYPES.AI_RECOMMENDATION,
    date: recommendation.suggestedDate,
    title: `AI: ${recommendation.subtopic}`,
    description: recommendation.reason,
    topic: recommendation.topic,
    subtopic: recommendation.subtopic,
    questionCount: recommendation.questionCount,
    priority: recommendation.priority,
    currentAccuracy: recommendation.currentAccuracy,
    sourceRecommendationId: recommendation.id,
    completed: false,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };

  console.log('ü§ñ Creating AI recommendation event:', aiEvent);

  await setDoc(
    doc(db, 'calendar_events', aiEvent.id),
    aiEvent
  );

  // Mark recommendation as accepted
  await performanceService.acceptRecommendation(userId, recommendation.id);

  console.log('‚úÖ AI recommendation added to calendar');

  return aiEvent;
}

/**
 * üîß NEW: Create spaced repetition event
 */
export async function createSpacedRepetitionEvent(userId, mistakeData) {
  const { questionId, topic, subtopic, interval, attemptCount } = mistakeData;
  
  const reviewDate = new Date();
  reviewDate.setDate(reviewDate.getDate() + interval);
  
  const repEvent = {
    id: `rep_${questionId}_${Date.now()}`,
    userId,
    type: EVENT_TYPES.SPACED_REPETITION,
    date: reviewDate.toISOString().split('T')[0],
    title: 'Review Mistake',
    description: `${topic} ‚Üí ${subtopic}`,
    topic,
    subtopic,
    questionId,
    interval,
    attemptCount: attemptCount || 0,
    completed: false,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };

  console.log('üß† Creating spaced repetition event:', repEvent);

  await setDoc(
    doc(db, 'calendar_events', repEvent.id),
    repEvent
  );

  return repEvent;
}

/**
 * Mark an event as completed
 */
export async function markEventCompleted(eventId, completionData = {}) {
  try {
    const eventRef = doc(db, 'calendar_events', eventId);
    
    await updateDoc(eventRef, {
      completed: true,
      completedAt: new Date().toISOString(),
      completionData,
      updatedAt: new Date().toISOString()
    });

    console.log('‚úÖ Event marked as completed:', eventId);
  } catch (error) {
    console.error('‚ùå Error marking event as completed:', error);
    throw error;
  }
}

/**
 * Delete an event and its children
 */
export async function deleteEvent(eventId, cascadeDelete = true) {
  try {
    console.log('üóëÔ∏è Deleting event:', eventId, '(cascade:', cascadeDelete, ')');

    // Get the event first to check userId
    const eventRef = doc(db, 'calendar_events', eventId);
    const eventSnap = await getDoc(eventRef);
    
    if (!eventSnap.exists()) {
      throw new Error('Event not found');
    }

    const eventData = eventSnap.data();
    
    // Delete main event
    await deleteDoc(eventRef);
    console.log('‚úÖ Deleted main event:', eventId);

    // Delete child events if cascade
    if (cascadeDelete) {
      const childrenQuery = query(
        collection(db, 'calendar_events'),
        where('userId', '==', eventData.userId),
        where('linkedEventId', '==', eventId)
      );
      
      const childrenSnapshot = await getDocs(childrenQuery);
      
      console.log('üîç Found', childrenSnapshot.size, 'child events to delete');
      
      const batch = writeBatch(db);
      childrenSnapshot.forEach((childDoc) => {
        batch.delete(childDoc.ref);
      });
      
      if (childrenSnapshot.size > 0) {
        await batch.commit();
        console.log('‚úÖ Deleted', childrenSnapshot.size, 'child events');
      }
    }

    console.log('‚úÖ Event deletion complete');
  } catch (error) {
    console.error('‚ùå Error deleting event:', error);
    throw error;
  }
}

/**
 * Get calendar data for a specific month
 */
export async function getCalendarData(userId, year, month) {
  const startDate = new Date(year, month, 1);
  const endDate = new Date(year, month + 1, 0);
  
  const startDateStr = startDate.toISOString().split('T')[0];
  const endDateStr = endDate.toISOString().split('T')[0];

  console.log('üìÖ Loading calendar for:', { userId, year, month, startDateStr, endDateStr });

  // Query events for this user and date range
  const eventsQuery = query(
    collection(db, 'calendar_events'),
    where('userId', '==', userId),
    where('date', '>=', startDateStr),
    where('date', '<=', endDateStr)
  );

  const eventsSnapshot = await getDocs(eventsQuery);
  
  console.log('üìä Found', eventsSnapshot.size, 'events');

  // Organize by date
  const calendarData = {};

  eventsSnapshot.forEach(doc => {
    const event = { id: doc.id, ...doc.data() };
    
    if (!calendarData[event.date]) {
      calendarData[event.date] = {
        exams: [],
        quizzes: [],
        suggestions: [],
        repetitions: [],
        aiRecommendations: []
      };
    }

    if (event.type === EVENT_TYPES.MAJOR_EXAM) {
      calendarData[event.date].exams.push(event);
    } else if (event.type === EVENT_TYPES.SMALL_QUIZ) {
      calendarData[event.date].quizzes.push(event);
    } else if (event.type === EVENT_TYPES.STUDY_SUGGESTION) {
      calendarData[event.date].suggestions.push(event);
    } else if (event.type === EVENT_TYPES.SPACED_REPETITION) {
      calendarData[event.date].repetitions.push(event);
    } else if (event.type === EVENT_TYPES.AI_RECOMMENDATION) {
      calendarData[event.date].aiRecommendations.push(event);
    }
  });

  console.log('‚úÖ Calendar data organized:', Object.keys(calendarData).length, 'days with events');

  return calendarData;
}

/**
 * üîß NEW: Log quiz completion with performance tracking
 */
export async function logCompletion(userId, dateStr, sessionData, questions = [], answers = {}) {
  try {
    console.log('üìù Logging completion:', { userId, date: dateStr, sessionData });

    // First, record performance if questions and answers provided
    if (questions.length > 0 && Object.keys(answers).length > 0) {
      console.log('üìä Recording performance data...');
      await performanceService.recordQuizResults(userId, questions, answers);
    }

    // Note: We're not creating completion events in calendar_events
    // Completions are tracked by marking existing events as completed
    
    console.log('‚úÖ Completion logged successfully');
  } catch (error) {
    console.error('‚ùå Error logging completion:', error);
    throw error;
  }
}

export const calendarService = {
  addMajorExam,
  addSmallQuiz,
  createAIRecommendationEvent,
  createSpacedRepetitionEvent,
  markEventCompleted,
  deleteEvent,
  getCalendarData,
  logCompletion
};

export default calendarService;

========== src/utils/calendarEventManager.js ==========
/**
 * Calendar Event Manager (Merged)
 * Combines user-specific storage with spaced repetition and event management
 */

import { auth } from '../firebase/config';

// Event Types
export const EVENT_TYPES = {
  MAJOR_EXAM: 'major_exam',
  SMALL_QUIZ: 'small_quiz',
  STUDY_SUGGESTION: 'study_suggestion',
  MISTAKE_REVIEW: 'mistake_review',
  COMPLETED_ACTIVITY: 'completed_activity',
};

// Event Icons
export const EVENT_ICONS = {
  [EVENT_TYPES.MAJOR_EXAM]: 'üö©',
  [EVENT_TYPES.SMALL_QUIZ]: '‚úèÔ∏è',
  [EVENT_TYPES.STUDY_SUGGESTION]: 'üí°',
  [EVENT_TYPES.MISTAKE_REVIEW]: 'üß†',
  [EVENT_TYPES.COMPLETED_ACTIVITY]: '‚úÖ',
};

/**
 * Get user-specific storage key (Firebase auth aware)
 */
function getUserStorageKey(suffix) {
  const user = auth.currentUser;
  if (!user) return `studyCalendar_guest_${suffix}`;
  return `studyCalendar_${user.uid}_${suffix}`;
}

/**
 * Load calendar data from localStorage (user-specific)
 */
export function loadCalendarData() {
  try {
    const data = localStorage.getItem(getUserStorageKey('data'));
    return data ? JSON.parse(data) : { events: [], completedSessions: {} };
  } catch (error) {
    console.error('Error loading calendar data:', error);
    return { events: [], completedSessions: {} };
  }
}

/**
 * Save calendar data to localStorage (user-specific)
 */
export function saveCalendarData(data) {
  try {
    localStorage.setItem(getUserStorageKey('data'), JSON.stringify(data));
    // Trigger storage event for cross-component updates
    window.dispatchEvent(new Event('calendar-update'));
  } catch (error) {
    console.error('Error saving calendar data:', error);
  }
}

/**
 * Get all calendar events
 */
export function getCalendarEvents() {
  const data = loadCalendarData();
  return data.events || [];
}

/**
 * Save calendar events
 */
export function saveCalendarEvents(events) {
  const data = loadCalendarData();
  data.events = events;
  saveCalendarData(data);
}

/**
 * Calculate spaced repetition interval based on mistake improvement count
 * Uses SM-2 inspired algorithm with mistake-specific adjustments
 */
export function calculateSpacedRepetitionDate(mistake) {
  const now = new Date();
  const improvementCount = mistake.improvementCount || 0;
  
  // Spaced repetition intervals (in days)
  const intervals = {
    0: 1,   // First review: next day
    1: 3,   // Second review: 3 days later
    2: 7,   // Third review: 1 week later
    3: 14,  // Mastered but reinforce: 2 weeks
  };
  
  const daysToAdd = intervals[improvementCount] || 14;
  const reviewDate = new Date(now);
  reviewDate.setDate(reviewDate.getDate() + daysToAdd);
  
  return reviewDate.toISOString().split('T')[0];
}

/**
 * Generate study suggestions based on exam date and topic
 * Returns array of suggestion events with scaled MCQ counts
 */
export function generateExamPrepSuggestions(examDate, topic, subtopic = null) {
  const exam = new Date(examDate);
  const suggestions = [];
  
  // Major Exam Scaling Algorithm
  const prepSchedule = [
    { daysBeforeStart: 10, daysBeforeEnd: 7, mcqCount: 10, phase: 'Warm-up' },
    { daysBeforeStart: 6, daysBeforeEnd: 4, mcqCount: 20, phase: 'Consolidation' },
    { daysBeforeStart: 3, daysBeforeEnd: 1, mcqCount: 40, phase: 'Sprint' },
  ];
  
  prepSchedule.forEach(({ daysBeforeStart, daysBeforeEnd, mcqCount, phase }) => {
    for (let day = daysBeforeStart; day >= daysBeforeEnd; day--) {
      const suggestionDate = new Date(exam);
      suggestionDate.setDate(suggestionDate.getDate() - day);
      
      suggestions.push({
        id: `prep_${topic}_${day}`,
        type: EVENT_TYPES.STUDY_SUGGESTION,
        date: suggestionDate.toISOString().split('T')[0],
        title: `${phase} - ${mcqCount} MCQs`,
        description: `Practice ${mcqCount} questions on ${topic}`,
        topic,
        subtopic,
        mcqCount,
        phase,
        linkedExamId: examDate,
      });
    }
  });
  
  return suggestions;
}

/**
 * Generate quiz prep suggestions (smaller scale)
 */
export function generateQuizPrepSuggestions(quizDate, topic, subtopic) {
  const quiz = new Date(quizDate);
  const suggestions = [];
  
  // Small Quiz: 3-1 days before with 5-15 MCQs on subtopic
  for (let day = 3; day >= 1; day--) {
    const suggestionDate = new Date(quiz);
    suggestionDate.setDate(suggestionDate.getDate() - day);
    
    const mcqCount = day === 1 ? 15 : (day === 2 ? 10 : 5);
    
    suggestions.push({
      id: `quiz_prep_${subtopic}_${day}`,
      type: EVENT_TYPES.STUDY_SUGGESTION,
      date: suggestionDate.toISOString().split('T')[0],
      title: `Quiz Prep - ${mcqCount} MCQs`,
      description: `Review ${mcqCount} questions on ${subtopic}`,
      topic,
      subtopic,
      mcqCount,
      linkedQuizId: quizDate,
    });
  }
  
  return suggestions;
}

/**
 * Add a new event (exam or quiz)
 */
export function addCalendarEvent(event) {
  const events = getCalendarEvents();
  
  // Add the main event
  events.push({
    ...event,
    id: event.id || `${event.type}_${Date.now()}`,
    createdAt: new Date().toISOString(),
  });
  
  // Generate prep suggestions if it's an exam or quiz
  if (event.type === EVENT_TYPES.MAJOR_EXAM) {
    const suggestions = generateExamPrepSuggestions(event.date, event.topic, event.subtopic);
    events.push(...suggestions);
  } else if (event.type === EVENT_TYPES.SMALL_QUIZ) {
    const suggestions = generateQuizPrepSuggestions(event.date, event.topic, event.subtopic);
    events.push(...suggestions);
  }
  
  saveCalendarEvents(events);
  return events;
}

/**
 * Delete an event and its associated suggestions
 */
export function deleteCalendarEvent(eventId) {
  const events = getCalendarEvents();
  const filtered = events.filter(e => 
    e.id !== eventId && 
    e.linkedExamId !== eventId && 
    e.linkedQuizId !== eventId
  );
  saveCalendarEvents(filtered);
  return filtered;
}

/**
 * Mark event as completed
 */
export function completeCalendarEvent(eventId, completedData = {}) {
  const events = getCalendarEvents();
  const event = events.find(e => e.id === eventId);
  
  if (event) {
    // Mark original as completed
    event.completed = true;
    event.completedAt = new Date().toISOString();
    event.completedData = completedData;
    
    // Add completion badge
    events.push({
      id: `completed_${eventId}`,
      type: EVENT_TYPES.COMPLETED_ACTIVITY,
      date: event.date,
      title: `‚úÖ ${event.title}`,
      description: `Completed: ${event.description}`,
      parentEventId: eventId,
    });
  }
  
  saveCalendarEvents(events);
  return events;
}

/**
 * Schedule mistake review based on spaced repetition
 */
export function scheduleMistakeReview(mistake) {
  const events = getCalendarEvents();
  const reviewDate = calculateSpacedRepetitionDate(mistake);
  
  // Remove old review for this mistake
  const filtered = events.filter(e => 
    !(e.type === EVENT_TYPES.MISTAKE_REVIEW && e.mistakeId === mistake.ID)
  );
  
  // Add new review
  filtered.push({
    id: `review_${mistake.ID}_${Date.now()}`,
    type: EVENT_TYPES.MISTAKE_REVIEW,
    date: reviewDate,
    title: `Review Mistake`,
    description: `${mistake.Topic} ‚Üí ${mistake.Subtopic}`,
    topic: mistake.Topic,
    subtopic: mistake.Subtopic,
    mistakeId: mistake.ID,
    improvementCount: mistake.improvementCount || 0,
  });
  
  saveCalendarEvents(filtered);
  return filtered;
}

/**
 * Batch schedule mistake reviews for all active mistakes
 */
export function batchScheduleMistakeReviews(mistakes) {
  const events = getCalendarEvents();
  
  // Remove all existing mistake reviews
  const filtered = events.filter(e => e.type !== EVENT_TYPES.MISTAKE_REVIEW);
  
  // Add new reviews for all mistakes
  mistakes.forEach(mistake => {
    const reviewDate = calculateSpacedRepetitionDate(mistake);
    
    filtered.push({
      id: `review_${mistake.ID}_${Date.now()}`,
      type: EVENT_TYPES.MISTAKE_REVIEW,
      date: reviewDate,
      title: `Review Mistake`,
      description: `${mistake.Topic}${mistake.Subtopic ? ` ‚Üí ${mistake.Subtopic}` : ''}`,
      topic: mistake.Topic,
      subtopic: mistake.Subtopic,
      mistakeId: mistake.ID,
      improvementCount: mistake.improvementCount || 0,
    });
  });
  
  saveCalendarEvents(filtered);
  return filtered;
}

/**
 * Get events for a specific date
 */
export function getEventsForDate(dateStr) {
  const events = getCalendarEvents();
  return events.filter(e => e.date === dateStr && !e.completed);
}

/**
 * Get events for a date range
 */
export function getEventsForDateRange(startDate, endDate) {
  const events = getCalendarEvents();
  const start = new Date(startDate);
  const end = new Date(endDate);
  
  return events.filter(e => {
    const eventDate = new Date(e.date);
    return eventDate >= start && eventDate <= end && !e.completed;
  });
}

/**
 * Get events in range (alias for compatibility)
 */
export function getEventsInRange(startDate, endDate) {
  return getEventsForDateRange(startDate, endDate);
}

/**
 * Get upcoming events (next 7 days)
 */
export function getUpcomingEvents(days = 7) {
  const today = new Date();
  const future = new Date();
  future.setDate(future.getDate() + days);
  
  return getEventsForDateRange(
    today.toISOString().split('T')[0],
    future.toISOString().split('T')[0]
  ).sort((a, b) => new Date(a.date) - new Date(b.date));
}

/**
 * Add completed session to calendar
 */
export function addCompletedSession(date, sessionType, details = {}) {
  const calendarData = loadCalendarData();
  const dateStr = date.toISOString().split('T')[0];
  
  if (!calendarData.completedSessions[dateStr]) {
    calendarData.completedSessions[dateStr] = [];
  }
  
  calendarData.completedSessions[dateStr].push({
    type: sessionType,
    timestamp: new Date().toISOString(),
    ...details
  });
  
  saveCalendarData(calendarData);
}

/**
 * Get completed sessions for a specific date
 */
export function getCompletedSessions(date) {
  const calendarData = loadCalendarData();
  const dateStr = date.toISOString().split('T')[0];
  return calendarData.completedSessions[dateStr] || [];
}

/**
 * Remove event from calendar (alias for compatibility)
 */
export function removeCalendarEvent(eventId) {
  return deleteCalendarEvent(eventId);
}

/**
 * Clear old data (older than 6 months)
 */
export function clearOldCalendarData() {
  const calendarData = loadCalendarData();
  const sixMonthsAgo = new Date();
  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
  
  // Filter old events
  calendarData.events = calendarData.events.filter(event => 
    new Date(event.date) >= sixMonthsAgo
  );
  
  // Filter old completed sessions
  Object.keys(calendarData.completedSessions).forEach(dateStr => {
    if (new Date(dateStr) < sixMonthsAgo) {
      delete calendarData.completedSessions[dateStr];
    }
  });
  
  saveCalendarData(calendarData);
}
