MILLIONAIRE GAME QUIZ - COMBINED SOURCE
Generated: 2026-02-14T20:39:51.641Z
Project: /Users/Hugo/Desktop/chemleungmcq-platform-2



===== FILE: src/pages/MillionaireQuiz.jsx =====


import React, { useEffect, useId, useMemo, useRef, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { doc, updateDoc, increment } from 'firebase/firestore';
import { Sparkles, PhoneCall, BarChart3, Percent, X, Menu, Info } from 'lucide-react';
import { motion, useMotionValue, useSpring } from 'framer-motion';

import { db } from '../firebase/config';
import { useAuth } from '../contexts/AuthContext';
import ChemistryLoading from '../components/ChemistryLoading';
import { quizService } from '../services/quizService';
import { fetchMillionaireQuestionsFiltered, MILLIONAIRE_LEVELS } from '../services/millionaireService';
import MoneyLadder from '../components/millionaire/MoneyLadder';
import GameOverModal from '../components/millionaire/GameOverModal';
import ChemLeungModal from '../components/millionaire/ChemLeungModal';
import ProbabilityModal from '../components/millionaire/ProbabilityModal';

const LADDER_TOKENS = [1, 2, 3, 4, 5, 6, 7, 9, 11, 14, 17, 20, 23, 28, 35];

function computeFailReward(levelReached) {
  const lvl = Number(levelReached || 0);
  if (!Number.isFinite(lvl) || lvl <= 0) return 0;
  if (lvl < 5) return 0;
  if (lvl >= 6 && lvl <= 10) return 5;
  if (lvl >= 11 && lvl <= 15) return 14;
  return 0;
}

export default function MillionaireQuiz({ questions: allQuestions = [] }) {
  const navigate = useNavigate();
  const { currentUser } = useAuth();

  const [loading, setLoading] = useState(true);
  const [questions, setQuestions] = useState([]);
  const [currentIndex, setCurrentIndex] = useState(0);

  const [selectedOption, setSelectedOption] = useState(null);
  const [lockedOption, setLockedOption] = useState(null);
  const [answers, setAnswers] = useState({});
  const [revealState, setRevealState] = useState(null); // null | 'correct' | 'wrong'
  const [victoryOverlay, setVictoryOverlay] = useState(false);
  const [milestoneOverlay, setMilestoneOverlay] = useState(null); // null | { level, tokens }
  const [pendingBank, setPendingBank] = useState(0);

  const [gameOver, setGameOver] = useState(false);
  const [finalReward, setFinalReward] = useState(0);
  const [finalReason, setFinalReason] = useState(null);
  const [savingReward, setSavingReward] = useState(false);

  const [lifeline5050Used, setLifeline5050Used] = useState(false);
  const [lifelineChemUsed, setLifelineChemUsed] = useState(false);
  const [lifelineProbUsed, setLifelineProbUsed] = useState(false);
  const [hiddenOptions, setHiddenOptions] = useState(new Set());
  const [showChemModal, setShowChemModal] = useState(false);
  const [showProbModal, setShowProbModal] = useState(false);

  const [ladderOpenMobile, setLadderOpenMobile] = useState(false);
  const [showExitConfirm, setShowExitConfirm] = useState(false);

  const [shimmerOption, setShimmerOption] = useState(null);
  const [lockInPending, setLockInPending] = useState(false);
  const [expandModal, setExpandModal] = useState(null); // null | { title, text }

  const finalizeOnceRef = useRef(false);

  const currentQuestion = questions[currentIndex];
  const level = currentIndex + 1;
  const currentBank = useMemo(() => {
    if (level <= 1) return 0;
    return LADDER_TOKENS[level - 2] || 0;
  }, [level]);

  const ladderData = useMemo(() => {
    return LADDER_TOKENS.map((amt, idx) => ({
      level: idx + 1,
      amount: amt,
      safe: idx + 1 === 5 || idx + 1 === 10,
    }));
  }, []);

  useEffect(() => {
    const prev = document.body.style.overflow;
    document.body.style.overflow = 'hidden';
    return () => {
      document.body.style.overflow = prev;
    };
  }, []);

  useEffect(() => {
    try {
      setLoading(true);
      const picked = fetchMillionaireQuestionsFiltered(allQuestions, [], MILLIONAIRE_LEVELS);
      setQuestions(picked);
    } catch (e) {
      console.error(e);
      alert(e.message || 'Failed to start Millionaire mode');
      navigate('/');
    } finally {
      setLoading(false);
    }
  }, [allQuestions, navigate]);

  const resetPerQuestionState = () => {
    setSelectedOption(null);
    setLockedOption(null);
    setRevealState(null);
    setHiddenOptions(new Set());
    setPendingBank(0);
  };

  const awardTokensToUser = async (amount) => {
    if (!currentUser?.uid || !amount || amount <= 0) return;
    const userRef = doc(db, 'users', currentUser.uid);
    await updateDoc(userRef, { tokens: increment(amount) });
  };

  const finalizeGame = async ({ reward, reason }) => {
    if (finalizeOnceRef.current) return;
    finalizeOnceRef.current = true;

    setSavingReward(true);
    try {
      if (currentUser?.uid) {
        const attemptedQuestions = questions.slice(0, Math.min(currentIndex + 1, questions.length));
        const correctAnswers = attemptedQuestions.reduce((acc, q) => {
          const chosen = String(answers[q.ID] || '').toUpperCase();
          const correct = String(q.CorrectOption || '').toUpperCase();
          return acc + (chosen && chosen === correct ? 1 : 0);
        }, 0);

        const totalQuestions = attemptedQuestions.length;
        const percentage = totalQuestions > 0 ? Math.round((correctAnswers / totalQuestions) * 100) : 0;
        const topics = [...new Set(attemptedQuestions.map(q => q.Topic))].filter(Boolean);

        await quizService.saveAttempt(currentUser.uid, {
          score: percentage,
          totalQuestions,
          correctAnswers,
          percentage,
          topics,
          timeSpent: null,
          questionTimes: null,
          answers,
          questions: attemptedQuestions,
          mode: 'millionaire',
          millionaireLevelReached: level,
          millionaireFinalReward: reward,
          millionaireReason: reason,
          millionaireWin: reason === 'win',
        });
      }

      await awardTokensToUser(reward);
    } catch (e) {
      console.error(e);
      alert(e.message || 'Failed to update token balance');
    } finally {
      setFinalReward(reward);
      setFinalReason(reason);
      setSavingReward(false);
      setGameOver(true);
      setVictoryOverlay(false);
      setMilestoneOverlay(null);
      setLadderOpenMobile(false);
      console.log('Millionaire finalize:', { reward, reason });
    }
  };

  const handleSelect = (opt) => {
    if (!currentQuestion || gameOver || savingReward) return;
    if (lockedOption) return;
    if (hiddenOptions.has(opt)) return;
    setSelectedOption(opt);
  };

  const handleLockIn = async () => {
    if (!currentQuestion || gameOver || savingReward) return;
    if (!selectedOption) return;

    const correct = String(currentQuestion.CorrectOption).toUpperCase();
    const chosen = String(selectedOption).toUpperCase();
    setLockedOption(chosen);
    setShimmerOption(chosen);
    setLockInPending(true);
    setAnswers(prev => ({ ...prev, [currentQuestion.ID]: chosen }));

    const isCorrect = chosen === correct;
    setRevealState(isCorrect ? 'correct' : 'wrong');

    window.setTimeout(async () => {
      setLockInPending(false);
      if (isCorrect) {
        const passedLevel = level;
        const bankAfter = LADDER_TOKENS[passedLevel - 1] || 0;
        setPendingBank(bankAfter);

        if (passedLevel === 5 || passedLevel === 10) {
          setMilestoneOverlay({ level: passedLevel, tokens: bankAfter });
          return;
        }

        if (passedLevel >= MILLIONAIRE_LEVELS) {
          await finalizeGame({ reward: bankAfter, reason: 'win' });
          return;
        }

        setVictoryOverlay(true);
      } else {
        const levelReached = level;
        const reward = computeFailReward(levelReached);
        await finalizeGame({ reward, reason: 'wrong_answer' });
      }
    }, 650);

    window.setTimeout(() => {
      setShimmerOption(null);
    }, 750);
  };

  const handleContinue = () => {
    if (gameOver || savingReward) return;
    setVictoryOverlay(false);
    resetPerQuestionState();
    setCurrentIndex(i => i + 1);
  };

  const handleCashOut = async () => {
    if (gameOver || savingReward) return;
    const reward = pendingBank > 0 ? pendingBank : currentBank;
    await finalizeGame({ reward, reason: 'cash_out' });
  };

  const handleMilestoneContinue = () => {
    if (!milestoneOverlay) return;
    setMilestoneOverlay(null);

    const passedLevel = milestoneOverlay.level;
    if (passedLevel >= MILLIONAIRE_LEVELS) {
      finalizeGame({ reward: milestoneOverlay.tokens, reason: 'win' });
      return;
    }

    resetPerQuestionState();
    setCurrentIndex(i => i + 1);
  };

  const use5050 = () => {
    if (!currentQuestion || lifeline5050Used || lockedOption || gameOver) return;
    const correct = String(currentQuestion.CorrectOption).toUpperCase();
    const wrongs = ['A', 'B', 'C', 'D'].filter(o => o !== correct);
    const hide = shuffle(wrongs).slice(0, 2);
    setHiddenOptions(new Set(hide));
    setLifeline5050Used(true);
  };

  const useChemLeung = () => {
    if (!currentQuestion || lifelineChemUsed || gameOver) return;
    setShowChemModal(true);
    setLifelineChemUsed(true);
  };

  const useProbability = () => {
    if (!currentQuestion || lifelineProbUsed || gameOver) return;
    setShowProbModal(true);
    setLifelineProbUsed(true);
  };

  const optionText = useMemo(() => {
    if (!currentQuestion) return {};
    return {
      A: currentQuestion.OptionA,
      B: currentQuestion.OptionB,
      C: currentQuestion.OptionC,
      D: currentQuestion.OptionD,
    };
  }, [currentQuestion]);

  const isWide = useMediaQuery('(min-width: 768px)');

  const getFittedText = (raw) => {
    const s = normalizeQuestionText(raw, isWide);
    const len = s.length;

    let fontSize = 18;
    if (len > 60) fontSize = 16;
    if (len > 100) fontSize = 14;

    const needsTruncate = fontSize === 14 && len > 160;
    const text = needsTruncate ? s.slice(0, 150) : s;

    return { fullText: s, displayText: text, fontSize, truncated: needsTruncate };
  };

  const correctOption = useMemo(() => {
    return String(currentQuestion?.CorrectOption || '').toUpperCase();
  }, [currentQuestion]);

  const getOptionClass = (opt) => {
    const isHidden = hiddenOptions.has(opt);
    if (isHidden) return 'opacity-0 pointer-events-none';

    const base = 'm-hex m-hex--svg m-hex--idle m-hex--hover transition-all duration-300';
    const isSelected = selectedOption === opt;
    const isLocked = lockedOption === opt;

    if (!lockedOption) {
      return `${base} ${isSelected ? 'm-hex--selected' : ''}`;
    }

    if (lockInPending) {
      if (isLocked) return `${base} m-hex--selected scale-[1.02] animate-pulse`;
      return `${base} opacity-15 transition-opacity duration-700`;
    }

    if (revealState === 'correct') {
      if (opt === correctOption) return `${base} m-hex--correct scale-[1.02]`;
      if (isLocked) return `${base} m-hex--wrong`;
      return `${base} m-hex--dim`;
    }

    if (revealState === 'wrong') {
      if (isLocked) return `${base} m-hex--wrong scale-[1.02]`;
      if (opt === correctOption) return `${base} m-hex--correct m-hex--flash`;
      return `${base} m-hex--dim`;
    }

    return `${base}`;
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-[#020230]">
        <ChemistryLoading />
      </div>
    );
  }

  if (!currentQuestion) return null;

  const rewardIfClear = LADDER_TOKENS[level - 1] || 0;

  return (
    <div
      className="h-screen overflow-hidden text-white"
      style={{
        background: 'radial-gradient(circle at top, #020230 0%, #000000 70%)'
      }}
    >
      <div className="max-w-7xl mx-auto px-4 py-4 h-full flex flex-col">
        <div className="flex items-center justify-between gap-3 mb-4 flex-none">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 rounded-xl bg-white/10 border border-white/10 flex items-center justify-center">
              <Sparkles className="text-amber-300" size={20} />
            </div>
            <div>
              <div className="text-xs uppercase tracking-widest text-white/70">Millionaire</div>
              <div className="text-xl font-black">Q{level} / {MILLIONAIRE_LEVELS}</div>
            </div>
          </div>

          <div className="flex items-center gap-2">
            <div className="hidden sm:block text-right">
              <div className="text-[11px] text-white/70">Reward if you clear</div>
              <div className="text-lg font-black text-amber-300">+{rewardIfClear} tokens</div>
            </div>

            <button
              onClick={() => setShowExitConfirm(true)}
              disabled={savingReward}
              className="hidden sm:inline-flex m-quit w-10 h-10 items-center justify-center rounded-xl bg-red-600/25 border border-red-400/40 text-red-200 hover:bg-red-600/35 transition disabled:opacity-50"
              title="Quit"
            >
              <X size={18} />
            </button>

            <button
              onClick={() => setLadderOpenMobile(true)}
              className="sm:hidden px-3 py-2 rounded-xl bg-white/10 border border-white/10"
            >
              <Menu size={18} />
            </button>
          </div>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-[1fr_260px] gap-6 flex-1 min-h-0 pb-24">
          {/* Left: Question + Answers */}
          <div className="min-h-0 h-full flex flex-col gap-4">
            <div className="flex-none flex items-center justify-between">
              <div className="text-xs uppercase tracking-widest text-white/60">Question</div>
              <div className="text-sm font-black text-white/90">Q{level}/{MILLIONAIRE_LEVELS}</div>
            </div>

            {/* Question Hex (taller to fit longer chemistry stems) */}
            <div className="flex-none w-full m-hex-wrap" style={{ ['--m-hex-span']: '90%' }}>
              <div className="m-hex-extend" />
              <div
                className="m-hex m-hex--svg m-hex--idle px-0 shadow-2xl flex items-center justify-center"
                style={{ width: 'var(--m-hex-span)', marginLeft: 'auto', marginRight: 'auto', height: '180px' }}
              >
                <HexNeonOutline />
                {(() => {
                  const q = getFittedText(currentQuestion.Question);
                  return (
                    <div
                      className="m-hex-content text-center font-black leading-relaxed flex items-center justify-center"
                      style={{ fontSize: q.fontSize, height: '100%' }}
                    >
                      <span>{q.displayText}</span>
                      {q.truncated && (
                        <button
                          className="ml-1 inline-flex align-middle font-black text-white hover:text-white/90"
                          onClick={() => setExpandModal({ title: `Question ${level}`, text: q.fullText })}
                          title="View full question"
                        >
                          ...
                        </button>
                      )}
                    </div>
                  );
                })()}
              </div>
            </div>

            {/* Lifelines (moved here) */}
            {!victoryOverlay && (
              <div className="flex-none flex flex-wrap items-center gap-3">
                <MagneticIconButton
                  label="50:50"
                  onClick={use5050}
                  disabled={lifeline5050Used || !!lockedOption || savingReward || gameOver}
                  used={lifeline5050Used}
                >
                  <Percent size={18} />
                </MagneticIconButton>
                <MagneticIconButton
                  label="ChemLeung"
                  onClick={useChemLeung}
                  disabled={lifelineChemUsed || savingReward || gameOver}
                  used={lifelineChemUsed}
                >
                  <PhoneCall size={18} />
                </MagneticIconButton>
                <MagneticIconButton
                  label="AI Tips"
                  onClick={useProbability}
                  disabled={lifelineProbUsed || savingReward || gameOver}
                  used={lifelineProbUsed}
                >
                  <BarChart3 size={18} />
                </MagneticIconButton>
              </div>
            )}

            {/* Middle Expand Area: Answers OR Decision Card */}
            <div className="flex-1 min-h-0 flex flex-col justify-center">
              {!victoryOverlay ? (
                <div
                  className="grid grid-cols-1 md:grid-cols-2 gap-x-10 gap-y-[10px] flex-1 min-h-0 lg:content-stretch"
                  style={{ width: '90%', marginLeft: 'auto', marginRight: 'auto', gridTemplateRows: '60px 60px' }}
                >
                  {(['A', 'B', 'C', 'D']).map((opt) => (
                    <div key={opt} className="m-hex-wrap" style={{ ['--m-hex-span']: '100%' }}>
                      <div className="m-hex-extend" />
                      <MagneticMotionButton
                        onClick={() => handleSelect(opt)}
                        disabled={savingReward || gameOver || hiddenOptions.has(opt)}
                        className={`px-6 sm:px-8 text-left shadow-xl ${getOptionClass(opt)} hover:scale-[1.02] w-full flex items-center`}
                        style={{ height: '60px' }}
                      >
                        {shimmerOption === opt && <span className="m-shimmer" />}
                        <HexNeonOutline />
                        <span className="m-answer-connectors" />
                        {(() => {
                          const a = getFittedText(optionText[opt] || '');
                          return (
                            <div className="m-hex-content flex items-center gap-3 w-full">
                              <div className="font-black text-base sm:text-lg">
                                <span className="m-opt-label">{opt}:</span>
                              </div>
                              <div className="font-bold leading-relaxed text-white" style={{ fontSize: a.fontSize }}>
                                {a.displayText}
                                {a.truncated && (
                                  <button
                                    className="ml-1 inline-flex align-middle font-black text-white hover:text-white/90"
                                    onClick={(e) => {
                                      e.stopPropagation();
                                      setExpandModal({ title: `Answer ${opt}`, text: a.fullText });
                                    }}
                                    title="View full answer"
                                  >
                                    ...
                                  </button>
                                )}
                              </div>
                            </div>
                          );
                        })()}
                      </MagneticMotionButton>
                    </div>
                  ))}
                </div>
              ) : (
                <div className="flex-1 min-h-0 flex items-center justify-center">
                  <div className="w-full max-w-2xl m-glass rounded-3xl p-8 shadow-2xl">
                    <div className="text-center">
                      <div className="text-xs uppercase tracking-widest text-white/60">Decision</div>
                      <div className="text-3xl font-black mt-2">Correct!</div>
                      <div className="text-white/80 mt-2">
                        You cleared Q{level}. Current reward:
                        <span className="font-black text-amber-300"> {pendingBank} tokens</span>
                      </div>
                    </div>

                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-8">
                      <button
                        onClick={handleCashOut}
                        disabled={savingReward}
                        className="px-6 py-5 rounded-2xl font-black bg-amber-600 hover:bg-amber-500 transition disabled:opacity-50"
                      >
                        CASH OUT ({pendingBank} Tokens)
                      </button>
                      <button
                        onClick={handleContinue}
                        disabled={savingReward}
                        className="px-6 py-5 rounded-2xl font-black bg-blue-600 hover:bg-blue-500 transition disabled:opacity-50"
                      >
                        NEXT QUESTION
                      </button>
                    </div>
                  </div>
                </div>
              )}
            </div>

            {/* Bottom: Lock In + Bank (anchored above dock) */}
            <div className="flex-none">
              {!victoryOverlay && (
                <button
                  onClick={handleLockIn}
                  disabled={!selectedOption || !!lockedOption || savingReward || gameOver}
                  className="w-full px-6 py-4 rounded-xl font-black text-lg bg-blue-600 hover:bg-blue-500 transition disabled:bg-white/10 disabled:text-white/40"
                >
                  Lock In
                </button>
              )}

              <div className="text-sm text-white/70 mt-3">
                Current Bank: <span className="font-black text-amber-300">{currentBank}</span> tokens
              </div>
            </div>
          </div>

          {/* Right: Ladder (desktop) */}
          <div className="hidden lg:block min-h-0 h-full">
            <MoneyLadder ladder={ladderData} currentLevel={level} />
          </div>
        </div>
      </div>

      {/* Floating Pill Dock */}
      <div className="fixed left-1/2 -translate-x-1/2 bottom-4 z-30">
        <div className="bg-black/50 backdrop-blur-xl border border-white/10 rounded-full shadow-2xl px-3 py-2 flex items-center gap-2 sm:hidden">
          <DockIconButton
            label="Quit"
            onClick={() => setShowExitConfirm(true)}
            disabled={savingReward}
            used={false}
            variant="danger"
          >
            <X size={18} />
          </DockIconButton>
        </div>
      </div>

      {/* Exit Warning */}
      {showExitConfirm && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
          <div className="absolute inset-0 bg-black/70" onClick={() => setShowExitConfirm(false)} />
          <div className="relative w-full max-w-lg m-glass rounded-3xl p-8 shadow-2xl">
            <div className="text-xs uppercase tracking-widest text-white/60">High Stakes</div>
            <div className="text-2xl font-black mt-2">Quit now and lose current tokens?</div>
            <div className="text-white/75 mt-2 leading-relaxed">
              You currently have <span className="font-black text-amber-300">{currentBank}</span> tokens.
            </div>

            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 mt-8">
              <button
                onClick={async () => {
                  setShowExitConfirm(false);
                  await handleCashOut();
                }}
                className="px-6 py-4 rounded-2xl font-black bg-amber-600 hover:bg-amber-500 transition"
              >
                CASH OUT
              </button>
              <button
                onClick={() => setShowExitConfirm(false)}
                className="px-6 py-4 rounded-2xl font-black bg-blue-600 hover:bg-blue-500 transition"
              >
                STAY
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Ladder Drawer (mobile/tablet) */}
      {ladderOpenMobile && (
        <div className="fixed inset-0 z-40">
          <div className="absolute inset-0 bg-black/70" onClick={() => setLadderOpenMobile(false)} />
          <div className="absolute right-0 top-0 h-full w-[85%] max-w-sm p-4">
            <div className="h-full">
              <MoneyLadder ladder={ladderData} currentLevel={level} />
            </div>
          </div>
        </div>
      )}

      {/* Milestone Overlay */}
      {milestoneOverlay && (
        <div className="fixed inset-0 z-50 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
          <div className="w-full max-w-2xl bg-gradient-to-br from-amber-600/30 to-slate-900/90 border-2 border-amber-400 rounded-3xl shadow-2xl overflow-hidden">
            <div className="p-8 text-center">
              <div className="text-4xl font-black text-amber-300">SAFETY NET REACHED</div>
              <div className="text-white/90 mt-3 text-lg font-bold">
                Your <span className="text-amber-300 font-black">{milestoneOverlay.tokens}</span> tokens are now guaranteed.
              </div>
              <div className="text-white/60 mt-2">
                Safe Haven: Q{milestoneOverlay.level}
              </div>
              <div className="mt-6">
                <button
                  onClick={handleMilestoneContinue}
                  disabled={savingReward}
                  className="w-full px-6 py-4 rounded-2xl font-black bg-blue-600 hover:bg-blue-500 transition disabled:opacity-50"
                >
                  Continue to Q{milestoneOverlay.level + 1}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Lifeline Modals */}
      {showChemModal && (
        <ChemLeungModal
          explanation={currentQuestion.Explanation}
          onClose={() => setShowChemModal(false)}
        />
      )}
      {showProbModal && (
        <ProbabilityModal
          correctOption={correctOption}
          options={['A', 'B', 'C', 'D']}
          onClose={() => setShowProbModal(false)}
        />
      )}

      {/* Game Over */}
      {gameOver && (
        <GameOverModal
          winAmount={`${finalReward} tokens`}
          questionsAnswered={level}
          fallbackReward={computeFailReward(level)}
          reason={finalReason}
          onPlayAgain={() => window.location.reload()}
          onExit={() => navigate('/')}
        />
      )}

      {expandModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-0 sm:p-4">
          <div className="absolute inset-0 bg-black/70" onClick={() => setExpandModal(null)} />
          <div className="relative w-full h-full sm:h-auto sm:max-h-[85vh] sm:max-w-3xl m-glass sm:rounded-3xl p-6 sm:p-8 shadow-2xl overflow-y-auto">
            <div className="text-xs uppercase tracking-widest text-white/60">Details</div>
            <div className="text-2xl font-black mt-2">{expandModal.title}</div>
            <div className="text-white/85 mt-4 leading-relaxed whitespace-pre-line">
              {expandModal.text}
            </div>
            <div className="mt-6">
              <button
                onClick={() => setExpandModal(null)}
                className="px-6 py-4 rounded-2xl font-black bg-blue-600 hover:bg-blue-500 transition"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

function useMediaQuery(query) {
  const [matches, setMatches] = useState(() => {
    if (typeof window === 'undefined') return true;
    return window.matchMedia(query).matches;
  });

  useEffect(() => {
    if (typeof window === 'undefined') return;
    const mql = window.matchMedia(query);
    const onChange = () => setMatches(mql.matches);
    onChange();
    mql.addEventListener('change', onChange);
    return () => mql.removeEventListener('change', onChange);
  }, [query]);

  return matches;
}

function HexNeonOutline() {
  const filterId = useId();
  return (
    <svg className="m-hex-outline" viewBox="0 0 100 100" preserveAspectRatio="none" aria-hidden="true">
      <defs>
        <filter id={filterId} x="-30%" y="-30%" width="160%" height="160%" colorInterpolationFilters="sRGB">
          <feGaussianBlur in="SourceGraphic" stdDeviation="1.6" result="blur" />
          <feMerge>
            <feMergeNode in="blur" />
            <feMergeNode in="SourceGraphic" />
          </feMerge>
        </filter>
      </defs>
      <polygon
        className="m-hex-glow"
        points="16,0 84,0 100,50 84,100 16,100 0,50"
        fill="none"
        strokeWidth="2.6"
        filter={`url(#${filterId})`}
        opacity="0.95"
      />
      <polygon
        className="m-hex-core"
        points="16,0 84,0 100,50 84,100 16,100 0,50"
        fill="none"
        strokeWidth="1.2"
        opacity="0.98"
      />
    </svg>
  );
}

function normalizeQuestionText(raw, preserveBreaks) {
  const s = String(raw || '');
  if (!s) return '';
  if (preserveBreaks) {
    return s.replace(/<br\s*\/?>/gi, '\n');
  }
  return s.replace(/<br\s*\/?>/gi, ' ');
}

function DockIconButton({ label, onClick, disabled, used, children, variant }) {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      title={label}
      className={`relative w-11 h-11 rounded-full border flex items-center justify-center transition ${
        used
          ? 'bg-white/5 border-white/10 text-white/35'
          : variant === 'danger'
            ? 'bg-red-600/25 border-red-400/40 hover:bg-red-600/35 text-red-200'
            : 'bg-white/10 border-white/10 hover:bg-white/15 text-white'
      } ${disabled ? 'opacity-60 cursor-not-allowed' : ''}`}
    >
      {children}
      {used && (
        <span className="pointer-events-none absolute inset-0">
          <span className="absolute left-1/2 top-1/2 w-12 h-[2px] bg-red-500 -translate-x-1/2 -translate-y-1/2 rotate-[-35deg] rounded" />
        </span>
      )}
    </button>
  );
}

function useMousePosition() {
  const [pos, setPos] = useState({ x: 0, y: 0 });
  useEffect(() => {
    const onMove = (e) => setPos({ x: e.clientX, y: e.clientY });
    window.addEventListener('mousemove', onMove, { passive: true });
    return () => window.removeEventListener('mousemove', onMove);
  }, []);
  return pos;
}

function MagneticMotionButton({ className, disabled, onClick, children }) {
  const ref = useRef(null);
  const mouse = useMousePosition();
  const x = useMotionValue(0);
  const y = useMotionValue(0);
  const sx = useSpring(x, { stiffness: 420, damping: 26, mass: 0.55 });
  const sy = useSpring(y, { stiffness: 420, damping: 26, mass: 0.55 });

  useEffect(() => {
    const el = ref.current;
    if (!el || disabled) {
      x.set(0);
      y.set(0);
      return;
    }

    const rect = el.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;

    const dx = mouse.x - cx;
    const dy = mouse.y - cy;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const radius = 40;
    const strength = 12;

    if (dist < radius) {
      const pull = (1 - dist / radius) * strength;
      x.set((dx / (dist || 1)) * pull);
      y.set((dy / (dist || 1)) * pull);
    } else {
      x.set(0);
      y.set(0);
    }
  }, [mouse.x, mouse.y, disabled, x, y]);

  return (
    <motion.button
      ref={ref}
      style={{ x: sx, y: sy }}
      onClick={onClick}
      disabled={disabled}
      className={`${className} ${disabled ? 'opacity-60 cursor-not-allowed' : ''}`}
    >
      {children}
    </motion.button>
  );
}

function MagneticIconButton({ label, onClick, disabled, used, children }) {
  return (
    <MagneticMotionButton
      onClick={onClick}
      disabled={disabled}
      className={`relative flex items-center gap-2 px-4 py-3 rounded-2xl m-glass shadow-xl transition ${
        used ? 'text-white/35' : 'text-white hover:bg-white/10'
      }`}
    >
      <span className="flex items-center justify-center w-8 h-8 rounded-xl bg-white/5 border border-white/10">
        {children}
      </span>
      <span className="text-sm font-black">{label}</span>
      {used && (
        <span className="pointer-events-none absolute inset-0">
          <span className="absolute left-1/2 top-1/2 w-[110%] h-[2px] bg-red-500/80 -translate-x-1/2 -translate-y-1/2 rotate-[-12deg] rounded" />
        </span>
      )}
    </MagneticMotionButton>
  );
}


===== FILE: src/components/millionaire/MoneyLadder.jsx =====

import React, { useEffect, useMemo, useRef } from 'react';
import { animate } from 'framer-motion';
import { Lock } from 'lucide-react';

export default function MoneyLadder({ ladder, currentLevel }) {
  const containerRef = useRef(null);
  const nodeRefs = useRef({});

  const steps = useMemo(() => {
    return Array.isArray(ladder) ? [...ladder].reverse() : [];
  }, [ladder]);

  useEffect(() => {
    const container = containerRef.current;
    const node = nodeRefs.current[currentLevel];
    if (!container || !node) return;

    const containerRect = container.getBoundingClientRect();
    const nodeRect = node.getBoundingClientRect();

    const nodeCenterWithinContainer = (nodeRect.top - containerRect.top) + nodeRect.height / 2;
    const targetScrollTop = container.scrollTop + nodeCenterWithinContainer - containerRect.height / 2;

    try {
      const controls = animate(container.scrollTop, targetScrollTop, {
        duration: 0.45,
        ease: 'easeInOut',
        onUpdate: (v) => {
          container.scrollTop = v;
        }
      });
      return () => controls?.stop?.();
    } catch (_) {
      container.scrollTo({ top: targetScrollTop, behavior: 'smooth' });
    }
  }, [currentLevel]);

  return (
    <div className="bg-gradient-to-br from-slate-900/80 to-blue-900/70 backdrop-blur-xl rounded-2xl border-2 border-blue-500/40 p-4 shadow-2xl h-full overflow-hidden">
      <div className="mb-3">
        <div className="text-xs uppercase tracking-widest text-white/60">Skill Tree</div>
        <div className="text-lg font-black text-amber-300">Token Ladder</div>
      </div>

      <div
        ref={containerRef}
        className="relative overflow-y-auto scroll-smooth rounded-xl border border-white/10 bg-black/20"
        style={{ height: '100%', maxHeight: '100%' }}
      >
        <div className="relative py-8 px-4" style={{ paddingBottom: 'calc(2rem + 20px)' }}>
          {/* Glowing path */}
          <div className="absolute left-[39px] top-6 bottom-6 w-[3px] rounded-full bg-gradient-to-b from-white/10 via-white/10 to-white/5" />
          <div
            className="absolute left-[38px] bottom-6 w-[4px] rounded-full m-skill-flow shadow-[0_0_26px_rgba(34,211,238,0.35)]"
            style={{ height: `${Math.max(0, Math.min(100, (currentLevel / Math.max(1, steps.length)) * 100))}%` }}
          />

          <div className="space-y-5">
            {steps.map((step) => {
              const isCurrent = step.level === currentLevel;
              const isCompleted = step.level < currentLevel;
              const isFuture = step.level > currentLevel;

              const nodeBg = isCompleted
                ? 'bg-amber-400'
                : isCurrent
                  ? 'bg-blue-500'
                  : 'bg-slate-700';

              const ring = isCompleted
                ? 'ring-amber-300/70'
                : isCurrent
                  ? 'ring-blue-300/80'
                  : 'ring-white/10';

              const glow = isCurrent
                ? 'shadow-[0_0_24px_rgba(59,130,246,0.55)]'
                : isCompleted
                  ? 'shadow-[0_0_18px_rgba(251,191,36,0.35)]'
                  : '';

              return (
                <div key={step.level} className="relative flex items-center justify-between">
                  <div className="flex items-center gap-3">
                    <div
                      ref={(el) => {
                        if (el) nodeRefs.current[step.level] = el;
                      }}
                      className={`relative w-11 h-11 rounded-full ${nodeBg} ring-4 ${ring} ${glow} flex items-center justify-center transition-all ${isCurrent ? 'm-radar' : ''}`}
                    >
                      {step.safe && (
                        <div className="absolute -top-2 -right-2 w-6 h-6 rounded-full bg-slate-900 border border-amber-400 flex items-center justify-center">
                          <Lock size={14} className="text-amber-300" />
                        </div>
                      )}
                      <span className={`text-sm font-black ${isFuture ? 'text-white/60' : 'text-slate-900'}`}>{step.level}</span>
                    </div>

                    <div className="leading-tight">
                      <div className={`text-sm font-black ${isFuture ? 'text-white/40' : 'text-white'}`}>
                        {step.amount} tokens
                      </div>
                      {step.safe && (
                        <div className="text-[11px] font-bold text-amber-300/90">Safety Net</div>
                      )}
                    </div>
                  </div>

                  <div className={`text-xs font-bold ${isCompleted ? 'text-amber-300' : isCurrent ? 'text-blue-200' : 'text-white/30'}`}>
                    {isCompleted ? 'CLEARED' : isCurrent ? 'NOW' : ''}
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      </div>
    </div>
  );
}


===== FILE: src/components/millionaire/GameOverModal.jsx =====

import React from 'react';
import { Trophy, Home, RotateCw, TrendingUp, Award } from 'lucide-react';

export default function GameOverModal({ winAmount, questionsAnswered, fallbackReward = 0, reason, onPlayAgain, onExit }) {
  const parseAmount = (amt) => {
    if (!amt) return 0;
    const s = String(amt);
    const digits = s.match(/\d+/g);
    if (!digits) return 0;
    return parseInt(digits.join(''), 10);
  };
  
  const amountValue = parseAmount(winAmount);
  const isWinner = reason === 'win' || amountValue >= 35;
  const isCashOut = reason === 'cash_out';
  const isWrong = reason === 'wrong_answer';
  const safetyNetTier = fallbackReward >= 14 ? 14 : fallbackReward >= 5 ? 5 : 0;

  return (
    <div className="fixed inset-0 bg-black/90 flex items-center justify-center z-50 p-4 animate-in fade-in">
      <div className="bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900 rounded-3xl border-2 border-amber-500 max-w-2xl w-full shadow-2xl overflow-hidden animate-in zoom-in duration-500">
        {/* Confetti effect for winner */}
        {isWinner && (
          <div className="absolute inset-0 pointer-events-none overflow-hidden">
            {[...Array(50)].map((_, i) => (
              <div
                key={i}
                className="absolute animate-ping"
                style={{
                  left: `${Math.random() * 100}%`,
                  top: `${Math.random() * 100}%`,
                  animationDelay: `${Math.random() * 2}s`,
                  animationDuration: `${2 + Math.random() * 2}s`,
                }}
              >
                ✨
              </div>
            ))}
          </div>
        )}

        {/* Header */}
        <div className={`p-8 text-center border-b-2 ${isWinner ? 'bg-gradient-to-r from-emerald-600/70 to-emerald-500/60 border-emerald-300/60' : 'bg-gradient-to-r from-blue-900 to-slate-900 border-blue-500/50'}`}>
          {isWinner ? (
            <>
              <Trophy className="mx-auto mb-4 text-white animate-bounce" size={64} />
              <h2 className="text-4xl font-black text-white mb-2">
                CONGRATULATIONS!
              </h2>
              <p className="text-amber-100 text-lg font-bold">
                You cleared all 15 questions.
              </p>
            </>
          ) : amountValue > 0 ? (
            <>
              <Award className="mx-auto mb-4 text-amber-400" size={56} />
              <h2 className="text-3xl font-black text-white mb-2">
                {isCashOut ? 'Cash Out Confirmed' : 'Well Played!'}
              </h2>
              <p className="text-blue-200 text-lg">
                {isCashOut ? 'You secured your current bank.' : 'You walked away with a reward.'}
              </p>
            </>
          ) : (
            <>
              <TrendingUp className="mx-auto mb-4 text-blue-400" size={56} />
              <h2 className="text-3xl font-black text-white mb-2">
                Better Luck Next Time!
              </h2>
              <p className="text-blue-200 text-lg">
                {safetyNetTier > 0 ? (
                  <>
                    You reached the <span className="font-black text-amber-200">{safetyNetTier}</span> token Safety Net!
                  </>
                ) : (
                  'Keep practicing and try again'
                )}
              </p>
            </>
          )}
        </div>

        {/* Stats */}
        <div className="p-8 space-y-6">
          {/* Win Amount */}
          <div className="text-center p-6 bg-gradient-to-br from-amber-900/40 to-amber-800/20 rounded-2xl border-2 border-amber-500/40">
            <div className="text-amber-400 text-sm font-bold mb-2">
              {isWinner ? 'You Won' : isCashOut ? 'You Cashed Out' : 'Final Reward'}
            </div>
            <div className="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-amber-400 via-yellow-300 to-amber-400">
              {winAmount}
            </div>
          </div>

          {/* Safety Net fallback */}
          {isWrong && (
            <div className="p-5 bg-white/5 rounded-2xl border border-white/10">
              <div className="text-xs uppercase tracking-widest text-white/60">Safety Net</div>
              <div className="text-white/85 mt-1 leading-relaxed">
                Fallback reward based on safe havens (Q5 / Q10):
                <span className="font-black text-amber-300"> {fallbackReward} tokens</span>
              </div>
              <div className="text-white/55 text-sm mt-1">
                (0 if fail &lt; Q5, 5 if fail Q6–Q10, 14 if fail Q11–Q15)
              </div>
            </div>
          )}

          {/* Questions Stats */}
          <div className="grid grid-cols-2 gap-4">
            <div className="p-4 bg-blue-900/30 rounded-xl border border-blue-500/30 text-center">
              <div className="text-blue-300 text-sm font-bold mb-1">
                Questions Answered
              </div>
              <div className="text-3xl font-black text-white">
                {questionsAnswered}
              </div>
            </div>
            
            <div className="p-4 bg-purple-900/30 rounded-xl border border-purple-500/30 text-center">
              <div className="text-purple-300 text-sm font-bold mb-1">
                Out of
              </div>
              <div className="text-3xl font-black text-white">
                15
              </div>
            </div>
          </div>

          {/* Performance Message */}
          <div className="p-4 bg-slate-800/50 rounded-xl border border-slate-700">
            <p className="text-slate-300 text-center leading-relaxed">
              {isWinner ? (
                "Perfect run. Your reward is locked in."
              ) : amountValue >= 14 ? (
                "Excellent performance. You reached the Q10 safety net tier."
              ) : amountValue >= 5 ? (
                "Good effort. You reached the Q5 safety net tier."
              ) : questionsAnswered >= 10 ? (
                "Close one. Review the topics and try again."
              ) : (
                "Keep studying. Every attempt makes you stronger."
              )}
            </p>
          </div>
        </div>

        {/* Actions */}
        <div className="p-6 bg-slate-900/50 border-t border-slate-700 grid grid-cols-2 gap-4">
          <button
            onClick={onPlayAgain}
            className="flex items-center justify-center gap-2 py-4 bg-gradient-to-r from-green-600 to-green-500 hover:from-green-500 hover:to-green-400 text-white rounded-xl font-bold transition-all transform hover:scale-105 shadow-lg"
          >
            <RotateCw size={20} />
            Play Again
          </button>
          
          <button
            onClick={onExit}
            className="flex items-center justify-center gap-2 py-4 bg-gradient-to-r from-blue-600 to-blue-500 hover:from-blue-500 hover:to-blue-400 text-white rounded-xl font-bold transition-all transform hover:scale-105 shadow-lg"
          >
            <Home size={20} />
            Exit to Home
          </button>
        </div>
      </div>
    </div>
  );
}


===== FILE: src/components/millionaire/ProbabilityModal.jsx =====

import React, { useState, useEffect } from 'react';
import { X, BarChart3 } from 'lucide-react';

export default function ProbabilityModal({ correctOption, options, onClose }) {
  const [showChart, setShowChart] = useState(false);
  const [probabilities, setProbabilities] = useState({});

  useEffect(() => {
    // Generate probabilities with correct answer having 65-75% chance
    const correctProb = 65 + Math.random() * 10; // 65-75%
    const remaining = 100 - correctProb;
    
    // Distribute remaining percentage among wrong answers
    const wrongOptions = options.filter(opt => opt !== correctOption);
    const probs = {};
    
    let remainingProb = remaining;
    wrongOptions.forEach((option, index) => {
      if (index === wrongOptions.length - 1) {
        // Last option gets whatever is left
        probs[option] = remainingProb;
      } else {
        // Random distribution between 5-15%
        const prob = 5 + Math.random() * 10;
        probs[option] = Math.min(prob, remainingProb - 5); // Keep at least 5% for last option
        remainingProb -= probs[option];
      }
    });
    
    probs[correctOption] = correctProb;
    setProbabilities(probs);

    // Show chart after brief delay
    setTimeout(() => setShowChart(true), 500);
  }, [correctOption, options]);

  const maxProb = Math.max(...Object.values(probabilities));

  return (
    <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4 animate-in fade-in">
      <div className="bg-gradient-to-br from-slate-900 to-purple-900 rounded-2xl border-2 border-purple-500 max-w-3xl w-full shadow-2xl animate-in slide-in-from-bottom duration-500">
        {/* Header */}
        <div className="bg-purple-600 p-4 rounded-t-xl flex items-center justify-between border-b-2 border-purple-500">
          <div className="flex items-center gap-3">
            <BarChart3 className="text-white" size={28} />
            <div>
              <h3 className="text-white font-black text-xl">Probability Analysis</h3>
              <p className="text-purple-200 text-sm">AI-Powered Answer Distribution</p>
            </div>
          </div>
          <button
            onClick={onClose}
            className="text-white hover:text-purple-200 transition-colors p-2 rounded-full hover:bg-purple-700"
          >
            <X size={24} />
          </button>
        </div>

        {/* Chart Body */}
        <div className="p-8">
          <div className="mb-6 text-center">
            <p className="text-purple-300 text-sm">
              Based on analysis patterns, here's the probability distribution:
            </p>
          </div>

          <div className="space-y-4">
            {options.map((option) => {
              const prob = probabilities[option] || 0;
              const percentage = prob.toFixed(1);
              const barWidth = showChart ? (prob / maxProb) * 100 : 0;
              const isHighest = prob === maxProb;

              return (
                <div key={option} className="space-y-2">
                  <div className="flex justify-between items-center">
                    <span className={`font-black text-lg ${isHighest ? 'text-amber-400' : 'text-white'}`}>
                      Option {option}
                    </span>
                    <span className={`font-bold ${isHighest ? 'text-amber-400' : 'text-purple-300'}`}>
                      {percentage}%
                    </span>
                  </div>
                  
                  <div className="bg-slate-800 rounded-full h-8 overflow-hidden border border-slate-700">
                    <div
                      className={`h-full rounded-full transition-all duration-1000 ease-out flex items-center justify-end pr-3 ${
                        isHighest
                          ? 'bg-gradient-to-r from-amber-600 to-amber-400'
                          : 'bg-gradient-to-r from-purple-600 to-purple-400'
                      }`}
                      style={{ width: `${barWidth}%` }}
                    >
                      {barWidth > 20 && (
                        <span className="text-white font-bold text-sm">
                          {percentage}%
                        </span>
                      )}
                    </div>
                  </div>
                </div>
              );
            })}
          </div>

          <div className="mt-6 p-4 bg-amber-900/30 border border-amber-500/50 rounded-xl">
            <p className="text-amber-300 text-sm text-center">
              ⚠️ This is a probability estimate, not a guarantee. Use your knowledge!
            </p>
          </div>
        </div>

        {/* Footer */}
        <div className="bg-slate-900/50 p-4 rounded-b-xl border-t border-slate-700">
          <button
            onClick={onClose}
            className="w-full py-3 bg-purple-600 hover:bg-purple-700 text-white rounded-xl font-bold transition-all transform hover:scale-105"
          >
            Got it!
          </button>
        </div>
      </div>
    </div>
  );
}


===== FILE: src/components/millionaire/ChemLeungModal.jsx =====

import React, { useState, useEffect } from 'react';
import { X, User, MessageCircle } from 'lucide-react';

export default function ChemLeungModal({ explanation, onClose }) {
  const [showTyping, setShowTyping] = useState(true);
  const [showMessage, setShowMessage] = useState(false);

  useEffect(() => {
    // Simulate typing delay
    const typingTimer = setTimeout(() => {
      setShowTyping(false);
      setShowMessage(true);
    }, 2000);

    return () => clearTimeout(typingTimer);
  }, []);

  return (
    <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4 animate-in fade-in">
      <div className="bg-gradient-to-br from-slate-900 to-blue-900 rounded-2xl border-2 border-green-500 max-w-2xl w-full shadow-2xl animate-in slide-in-from-bottom duration-500">
        {/* Header */}
        <div className="bg-green-600 p-4 rounded-t-xl flex items-center justify-between border-b-2 border-green-500">
          <div className="flex items-center gap-3">
            <div className="w-12 h-12 bg-white rounded-full flex items-center justify-center">
              <User className="text-green-600" size={24} />
            </div>
            <div>
              <h3 className="text-white font-black text-xl">ChemLeung</h3>
              <p className="text-green-200 text-sm">Chemistry Expert</p>
            </div>
          </div>
          <button
            onClick={onClose}
            className="text-white hover:text-green-200 transition-colors p-2 rounded-full hover:bg-green-700"
          >
            <X size={24} />
          </button>
        </div>

        {/* Chat Body */}
        <div className="p-6 min-h-[300px] max-h-[500px] overflow-y-auto">
          {/* Incoming call animation */}
          <div className="flex items-center gap-3 mb-6 animate-pulse">
            <MessageCircle className="text-green-400" size={24} />
            <span className="text-green-400 font-bold">ChemLeung is analyzing the question...</span>
          </div>

          {/* Typing indicator */}
          {showTyping && (
            <div className="flex items-start gap-3 mb-4">
              <div className="w-10 h-10 bg-green-600 rounded-full flex items-center justify-center flex-shrink-0">
                <User className="text-white" size={20} />
              </div>
              <div className="bg-slate-800 rounded-2xl rounded-tl-none px-4 py-3 flex gap-2">
                <div className="w-2 h-2 bg-green-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
                <div className="w-2 h-2 bg-green-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
                <div className="w-2 h-2 bg-green-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
              </div>
            </div>
          )}

          {/* Message */}
          {showMessage && (
            <div className="flex items-start gap-3 animate-in slide-in-from-left">
              <div className="w-10 h-10 bg-green-600 rounded-full flex items-center justify-center flex-shrink-0">
                <User className="text-white" size={20} />
              </div>
              <div className="bg-slate-800 rounded-2xl rounded-tl-none px-5 py-4 border-2 border-green-500/30 shadow-lg">
                <p className="text-white leading-relaxed text-lg">
                  {explanation || "Here's my expert analysis of this question..."}
                </p>
                <div className="mt-3 pt-3 border-t border-slate-700 text-sm text-slate-400">
                  Remember, this is guidance - make your final decision!
                </div>
              </div>
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="bg-slate-900/50 p-4 rounded-b-xl border-t border-slate-700">
          <button
            onClick={onClose}
            className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold transition-all transform hover:scale-105"
          >
            Thanks, ChemLeung!
          </button>
        </div>
      </div>
    </div>
  );
}


===== FILE: src/services/millionaireService.js =====

export const MILLIONAIRE_LEVELS = 15;

export function isValidMillionaireQuestion(q) {
  return !!(
    q &&
    q.ID &&
    q.Question &&
    q.OptionA &&
    q.OptionB &&
    q.OptionC &&
    q.OptionD &&
    q.CorrectOption
  );
}

function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

export function fetchMillionaireQuestionsFiltered(allQuestions = [], availableTopics = [], count = MILLIONAIRE_LEVELS) {
  const pool = (Array.isArray(allQuestions) ? allQuestions : [])
    .filter(isValidMillionaireQuestion)
    .filter(q => {
      if (!Array.isArray(availableTopics) || availableTopics.length === 0) return true;
      return availableTopics.includes(q.Topic);
    });

  const selected = shuffle(pool).slice(0, Math.min(count, pool.length));

  if (selected.length < count) {
    const err = new Error(`Not enough valid questions for Millionaire. Need ${count}, got ${selected.length}.`);
    err.code = 'MILLIONAIRE_INSUFFICIENT_QUESTIONS';
    throw err;
  }

  return selected;
}


===== FILE: src/services/rewardLogic.js =====

// ============================================================================
// REWARD LOGIC - Token Awards with Anti-Cheat
// ============================================================================

import { awardTokens, canClaimReward, recordRewardClaim, recordRewardClaimsBatch } from './tokenService';

// ────────────────────────────────────────────────────────────────────────────
// REWARD TIERS
// ────────────────────────────────────────────────────────────────────────────

const REWARDS = {
  // Per-question rewards
  FIRST_CORRECT: 2,
  CORRECTED_MISTAKE: 1,

  // Quiz completion bonus (only if totalQuestions >= 10)
  QUIZ_BONUS_100: 20,
  QUIZ_BONUS_80: 15,
  QUIZ_BONUS_50: 10,

  // Streak Bonuses
  STREAK_WEEK: 15,      // 7-day streak
  STREAK_MONTH: 50,     // 30-day streak

  // Special Events
  FIRST_QUIZ: 20,       // First quiz completion
  FORUM_POST: 2,        // Per helpful post (manual approval)
};

const MILLIONAIRE_REWARD_LADDER = [
  1, 2, 3, 4, 5, 6, 7, 9, 11, 14, 17, 20, 23, 28, 35
];

export async function rewardMillionaire(userId, levelReached, attemptId = null) {
  try {
    const level = Number(levelReached || 0);
    if (!userId || !Number.isFinite(level) || level <= 0) {
      return { success: false, tokensAwarded: 0 };
    }

    const idx = Math.min(level, MILLIONAIRE_REWARD_LADDER.length) - 1;
    const tokensAwarded = MILLIONAIRE_REWARD_LADDER[idx] || 0;
    if (tokensAwarded <= 0) {
      return { success: false, tokensAwarded: 0 };
    }

    const reason = `Millionaire Reward: Reached Q${level}`;
    await awardTokens(userId, tokensAwarded, reason, {
      category: 'millionaire',
      levelReached: level,
      attemptId
    });

    return { success: true, tokensAwarded };
  } catch (error) {
    console.error('Error rewarding Millionaire:', error);
    return { success: false, tokensAwarded: 0 };
  }
}

// ────────────────────────────────────────────────────────────────────────────
// MCQ COMPLETION REWARDS
// ────────────────────────────────────────────────────────────────────────────

/**
 * Award tokens for MCQ quiz completion
 */
export async function rewardMCQCompletion(userId, attemptData) {
  try {
    const { percentage, totalQuestions, correctAnswers, topics, attemptId } = attemptData;

    let tokensAwarded = 0;
    let rewardTier = '';

    // Quiz completion bonus only applies if quiz has 10+ questions
    if (totalQuestions >= 10) {
      if (percentage === 100) {
        tokensAwarded = REWARDS.QUIZ_BONUS_100;
        rewardTier = '100% Bonus';
      } else if (percentage >= 80) {
        tokensAwarded = REWARDS.QUIZ_BONUS_80;
        rewardTier = '80% Bonus';
      } else if (percentage >= 50) {
        tokensAwarded = REWARDS.QUIZ_BONUS_50;
        rewardTier = '50% Bonus';
      } else {
        tokensAwarded = 0;
        rewardTier = 'No Bonus';
      }
    } else {
      tokensAwarded = 0;
      rewardTier = 'No Bonus (min 10 questions)';
    }

    const reason = `MCQ Completed (${percentage}%) - ${rewardTier}`;
    
    if (tokensAwarded > 0) {
      await awardTokens(userId, tokensAwarded, reason, {
        category: 'quiz_bonus',
        percentage,
        totalQuestions,
        correctAnswers,
        topics,
        attemptId
      });
    }

    return {
      success: true,
      tokensAwarded,
      message: tokensAwarded > 0 ? `+${tokensAwarded} tokens! ${rewardTier}` : `No token bonus (${rewardTier})`
    };
  } catch (error) {
    console.error('Error rewarding MCQ completion:', error);
    return { success: false, tokensAwarded: 0 };
  }
}

// ────────────────────────────────────────────────────────────────────────────
// MISTAKE NOTEBOOK REWARDS (with Anti-Cheat)
// ────────────────────────────────────────────────────────────────────────────

/**
 * Reward clearing a mistake (once per question per 24h)
 */
export async function rewardMistakeCleared(userId, questionId) {
  try {
    const rewardKey = `mistake_${questionId}`;
    
    // Anti-cheat: Check cooldown
    const { canClaim, hoursRemaining } = await canClaimReward(userId, rewardKey);
    
    if (!canClaim) {
      return {
        success: false,
        message: `You can claim this reward again in ${hoursRemaining}h`,
        tokensAwarded: 0
      };
    }

    // This reward is now handled by per-question corrected-mistake logic.
    return {
      success: false,
      tokensAwarded: 0
    };
  } catch (error) {
    console.error('Error rewarding mistake cleared:', error);
    return { success: false, tokensAwarded: 0 };
  }
}

// ────────────────────────────────────────────────────────────────────────────
// LEADERBOARD REWARDS
// ────────────────────────────────────────────────────────────────────────────

/**
 * Award tokens for leaderboard placement
 */
export async function rewardLeaderboardPlacement(userId, rank, period = 'weekly') {
  try {
    let tokensAwarded = 0;
    const weekly = Math.max(0, 11 - Number(rank || 0));
    if (period === 'weekly') {
      tokensAwarded = weekly;
    } else if (period === 'monthly') {
      tokensAwarded = weekly * 3;
    }

    if (tokensAwarded === 0) {
      return { success: false, tokensAwarded: 0 };
    }

    const reason = `Leaderboard Reward: ${period} #${rank}`;

    await awardTokens(userId, tokensAwarded, reason, {
      category: 'leaderboard',
      rank,
      period
    });

    return {
      success: true,
      tokensAwarded,
      message: `+${tokensAwarded} tokens!`
    };
  } catch (error) {
    console.error('Error rewarding leaderboard placement:', error);
    return { success: false, tokensAwarded: 0 };
  }
}

// ────────────────────────────────────────────────────────────────────────────
// PER-QUESTION REWARDS (First-correct + corrected mistakes)
// ────────────────────────────────────────────────────────────────────────────

export async function rewardQuizQuestionTokens(userId, questions = [], answers = {}, quizMode = 'practice') {
  try {
    if (!userId || !Array.isArray(questions) || questions.length === 0) {
      return { success: false, tokensAwarded: 0 };
    }

    const isMistakeLikeMode = ['mistakes', 'spaced-repetition'].includes(quizMode);

    const firstCorrectRewardKeys = [];
    const correctedRewardKeys = [];

    const checks = await Promise.all(
      questions.map(async (q) => {
        const qid = q?.ID;
        if (!qid) return null;
        const wasCorrect = answers[qid] && answers[qid] === q.CorrectOption;
        if (!wasCorrect) return null;

        const firstKey = `first_correct_${qid}`;
        const correctedKey = `corrected_${qid}`;

        const [first, corrected] = await Promise.all([
          canClaimReward(userId, firstKey),
          isMistakeLikeMode ? canClaimReward(userId, correctedKey) : Promise.resolve({ canClaim: false })
        ]);

        return { qid, firstKey, correctedKey, canFirst: !!first?.canClaim, canCorrected: !!corrected?.canClaim };
      })
    );

    checks.filter(Boolean).forEach((c) => {
      if (c.canFirst) firstCorrectRewardKeys.push(c.firstKey);
      if (c.canCorrected) correctedRewardKeys.push(c.correctedKey);
    });

    const firstCount = firstCorrectRewardKeys.length;
    const correctedCount = correctedRewardKeys.length;
    const tokensAwarded = (firstCount * REWARDS.FIRST_CORRECT) + (correctedCount * REWARDS.CORRECTED_MISTAKE);

    if (tokensAwarded <= 0) {
      return { success: true, tokensAwarded: 0 };
    }

    const reason = `MCQ Rewards: ${firstCount} first-correct, ${correctedCount} corrected`;
    await awardTokens(userId, tokensAwarded, reason, {
      category: 'mcq_per_question',
      quizMode,
      firstCorrectCount: firstCount,
      correctedCount
    });

    // first-correct should never be claimable again; corrected has 24h cooldown
    await recordRewardClaimsBatch(userId, firstCorrectRewardKeys, 99999);
    await recordRewardClaimsBatch(userId, correctedRewardKeys, 24);

    return { success: true, tokensAwarded };
  } catch (error) {
    console.error('Error rewarding per-question tokens:', error);
    return { success: false, tokensAwarded: 0 };
  }
}

// ────────────────────────────────────────────────────────────────────────────
// STREAK REWARDS
// ────────────────────────────────────────────────────────────────────────────

/**
 * Award tokens for study streaks
 */
export async function rewardStreak(userId, streakDays) {
  try {
    let tokensAwarded = 0;
    let milestone = '';

    if (streakDays === 7) {
      tokensAwarded = REWARDS.STREAK_WEEK;
      milestone = '7-Day Streak! 🔥';
    } else if (streakDays === 30) {
      tokensAwarded = REWARDS.STREAK_MONTH;
      milestone = '30-Day Streak! 🔥🔥🔥';
    } else if (streakDays % 7 === 0 && streakDays > 7) {
      // Bonus for every week after first
      tokensAwarded = Math.floor(REWARDS.STREAK_WEEK * 1.5);
      milestone = `${streakDays}-Day Streak! 🔥`;
    }

    if (tokensAwarded === 0) {
      return { success: false, tokensAwarded: 0 };
    }

    const rewardKey = `streak_${streakDays}`;
    
    // Check if already claimed
    const { canClaim } = await canClaimReward(userId, rewardKey);
    if (!canClaim) {
      return { success: false, message: 'Streak reward already claimed' };
    }

    const reason = `Study Streak: ${milestone}`;

    await awardTokens(userId, tokensAwarded, reason, {
      category: 'streak',
      streakDays
    });

    // Record to prevent duplicate claims
    await recordRewardClaim(userId, rewardKey, 720); // 30 days

    return {
      success: true,
      tokensAwarded,
      message: `${milestone} - +${tokensAwarded} tokens!`
    };
  } catch (error) {
    console.error('Error rewarding streak:', error);
    return { success: false, tokensAwarded: 0 };
  }
}

// ────────────────────────────────────────────────────────────────────────────
// SPECIAL MILESTONE REWARDS
// ────────────────────────────────────────────────────────────────────────────

/**
 * Award first-time achievement bonuses
 */
export async function rewardFirstTimeAchievement(userId, achievementType) {
  try {
    const rewardKey = `first_${achievementType}`;
    
    const { canClaim } = await canClaimReward(userId, rewardKey);
    if (!canClaim) {
      return { success: false, message: 'Achievement already unlocked' };
    }

    let tokensAwarded = 0;
    let message = '';

    switch (achievementType) {
      case 'quiz':
        tokensAwarded = REWARDS.FIRST_QUIZ;
        message = 'First Quiz Completed! 🎉';
        break;
      case 'forum_post':
        tokensAwarded = REWARDS.FORUM_POST;
        message = 'Forum Contributor! 💬';
        break;
      default:
        return { success: false };
    }

    const reason = `First Time: ${message}`;

    await awardTokens(userId, tokensAwarded, reason, {
      category: 'first_time',
      achievementType
    });

    await recordRewardClaim(userId, rewardKey, 99999); // Never reset

    return {
      success: true,
      tokensAwarded,
      message: `${message} - +${tokensAwarded} tokens!`
    };
  } catch (error) {
    console.error('Error rewarding first-time achievement:', error);
    return { success: false, tokensAwarded: 0 };
  }
}

// ────────────────────────────────────────────────────────────────────────────
// EXPORTS
// ────────────────────────────────────────────────────────────────────────────

export const REWARD_AMOUNTS = REWARDS;

export default {
  rewardMCQCompletion,
  rewardMistakeCleared,
  rewardLeaderboardPlacement,
  rewardStreak,
  rewardFirstTimeAchievement,
  REWARDS
};


===== FILE: src/App_Final.jsx =====

import React from 'react';
import ForumPage from './pages/ForumPage';
import { BrowserRouter as Router, Routes, Route, Navigate, useLocation } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import { LanguageProvider } from './contexts/LanguageContext';
import PrivateRoute from './components/PrivateRoute';
import Header from './components/Header';
import LoginPage from './pages/LoginPage';
import RegisterPage from './pages/RegisterPage';
import DashboardPage from './pages/DashboardPage_Fixed';
import TopicSelectionPage from './pages/TopicSelectionPage_Updated';
import PracticeModeSelection from './pages/PracticeModeSelection';
import QuizPage from './pages/QuizPage';
import ResultsPage from './pages/ResultsPage_Updated_Fixed';
import MillionaireQuiz from './pages/MillionaireQuiz';
import LeaderboardPage from './pages/LeaderboardPage';
import ProfilePage from './pages/ProfilePage';
import HistoryPage from './pages/HistoryPage_Fixed';
import MistakeNotebookPage from './pages/MistakeNotebookPage';
import FirebaseTestPage from './pages/FirebaseTestPage';
import DebugDashboard from './pages/DebugDashboard';
import { useQuizData } from './hooks/useQuizData';
import ChemistryLoading from './components/ChemistryLoading';
import ChemStore from './components/ChemStore';
import TokenLog from './components/TokenLog';

const SHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTK36yaUN-NMCkQNT-DAHgc6FMZPjUc0Yv3nYEK4TA9W2qE9V1TqVD10Tq98-wXQoAvKOZlwGWRSDkU/pub?gid=1182550140&single=true&output=csv';

function AppContent() {
  const location = useLocation();
  const { questions, loading, error } = useQuizData(SHEET_URL);
  const isNotebookRoute = location.pathname === '/notebook';
  const noShellRoutes = new Set(['/dashboard', '/login', '/register', '/millionaire']);
  const useNoShell = noShellRoutes.has(location.pathname);
  const hideHeaderRoutes = new Set(['/login', '/register', '/millionaire']);
  const showHeader = !hideHeaderRoutes.has(location.pathname);

  if (loading) {
    return (
      <div className="flex h-screen items-center justify-center bg-gray-50">
        <ChemistryLoading persistKey="startup" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex h-screen items-center justify-center bg-gray-50">
        <div className="text-center bg-white p-8 rounded-2xl shadow-xl border-2 border-red-200">
          <p className="text-red-500 font-bold mb-2">Error loading questions</p>
          <p className="text-academic-slate">{error}</p>
        </div>
      </div>
    );
  }

  return (
    <>
      {showHeader && <Header />}
      <div className={useNoShell ? '' : isNotebookRoute ? '' : 'container mx-auto px-4 py-6'}>
        <Routes>
          {/* Public Routes */}
          <Route path="/login" element={<LoginPage />} />
          <Route path="/register" element={<RegisterPage />} />

          {/* Protected Routes */}
          {/* ✅ FIXED: Now passes questions prop to DashboardPage */}
          <Route
            path="/dashboard"
            element={
              <PrivateRoute>
                <DashboardPage questions={questions} />
              </PrivateRoute>
            }
          />
          
          {/* Practice Mode Selection - NEW */}
          <Route
            path="/"
            element={
              <PrivateRoute>
                <PracticeModeSelection questions={questions} />
              </PrivateRoute>
            }
          />
          
          {/* Legacy Topic Selection */}
          <Route
            path="/topics"
            element={
              <PrivateRoute>
                <TopicSelectionPage questions={questions} />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/quiz"
            element={
              <PrivateRoute>
                <QuizPage />
              </PrivateRoute>
            }
          />

          <Route
            path="/millionaire"
            element={
              <PrivateRoute>
                <MillionaireQuiz questions={questions} />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/results"
            element={
              <PrivateRoute>
                <ResultsPage />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/leaderboard"
            element={
              <PrivateRoute>
                <LeaderboardPage />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/profile"
            element={
              <PrivateRoute>
                <ProfilePage />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/history"
            element={
              <PrivateRoute>
                <HistoryPage />
              </PrivateRoute>
            }
          />
          
          {/* Mistake Notebook - NEW */}
          <Route
            path="/notebook"
            element={
              <PrivateRoute>
                <MistakeNotebookPage questions={questions} />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/forum"
            element={
              <PrivateRoute>
                <ForumPage />
              </PrivateRoute>
            }
          />

          {/* ChemStore - FIXED: Now inside Routes */}
          <Route
            path="/store"
            element={
              <PrivateRoute>
                <ChemStore />
              </PrivateRoute>
            }
          />

          {/* Token Log - FIXED: Now inside Routes */}
          <Route
            path="/token-log"
            element={
              <PrivateRoute>
                <TokenLog />
              </PrivateRoute>
            }
          />

          {/* Firebase Test Page - for debugging */}
          <Route
            path="/test-firebase"
            element={
              <PrivateRoute>
                <FirebaseTestPage />
              </PrivateRoute>
            }
          />
          
          {/* Debug Dashboard - comprehensive diagnostics */}
          <Route
            path="/debug"
            element={
              <PrivateRoute>
                <DebugDashboard />
              </PrivateRoute>
            }
          />

          {/* Catch all - redirect to dashboard */}
          <Route path="*" element={<Navigate to="/dashboard" replace />} />
        </Routes>
      </div>
    </>
  );
}

function AppShell() {
  const location = useLocation();
  const noShellRoutes = new Set(['/dashboard', '/login', '/register']);
  const useNoShell = noShellRoutes.has(location.pathname);

  return (
    <div className={useNoShell ? 'min-h-screen' : 'min-h-screen bg-gray-50'}>
      <AppContent />
    </div>
  );
}

export default function App() {
  return (
    <LanguageProvider>
      <AuthProvider>
        <Router>
          <AppShell />
        </Router>
      </AuthProvider>
    </LanguageProvider>
  );
}


===== FILE: src/index.css (Millionaire styles excerpt from .m-glass onward) =====


.m-glass {
  background: rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(15px);
  -webkit-backdrop-filter: blur(15px);
  border: 1px solid rgba(255, 255, 255, 0.10);
}

.m-hex {
  position: relative;
  overflow: hidden;
  clip-path: polygon(16% 0%, 84% 0%, 100% 50%, 84% 100%, 16% 100%, 0% 50%);
  transform: translateZ(0);
  background-image: linear-gradient(180deg, rgba(255, 255, 255, 0.16) 0%, rgba(255, 255, 255, 0.00) 18%);
  background-blend-mode: screen;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.22);
  --m-neon-core: rgba(255, 255, 255, 0.98);
  --m-neon-glow: rgba(34, 211, 238, 0.78);
}

 .m-quit {
   position: relative;
 }

 .m-quit:hover {
   animation: m-shatter 420ms ease-in-out 1;
 }

.m-hex::before {
  content: '';
  position: absolute;
  inset: 0;
  clip-path: inherit;
  border: 1px solid rgba(219, 234, 254, 0.85);
  pointer-events: none;
  z-index: 2;
}

.m-hex::after {
  content: '';
  position: absolute;
  inset: -2px;
  clip-path: inherit;
  border: 1px solid rgba(255, 255, 255, 0.22);
  filter:
    drop-shadow(0 0 12px rgba(34, 211, 238, 0.65))
    drop-shadow(0 0 24px rgba(255, 255, 255, 0.25));
  pointer-events: none;
  z-index: 1;
}

 .m-hex--svg::before,
 .m-hex--svg::after {
   opacity: 0;
 }

 .m-hex-outline {
   position: absolute;
   inset: 0;
   width: 100%;
   height: 100%;
   pointer-events: none;
   z-index: 2;
 }

 .m-hex-outline .m-hex-glow {
   stroke: var(--m-neon-glow);
 }

 .m-hex-outline .m-hex-core {
   stroke: var(--m-neon-core);
 }

.m-hex--idle {
  background: rgba(37, 99, 235, 0.18);
}

.m-hex--hover:hover {
  background: rgba(37, 99, 235, 0.26);
}

 .m-hex--hover:hover::after {
   animation: m-neon-hover 900ms ease-in-out infinite;
 }

 .m-hex--hover:hover .m-hex-outline {
   animation: m-svg-neon-hover 900ms ease-in-out infinite;
 }

.m-hex--selected::before {
  border-color: rgba(251, 146, 60, 0.98);
  animation: m-amber-pulse 900ms ease-in-out infinite;
}

 .m-hex--selected {
   --m-neon-core: rgba(251, 146, 60, 0.98);
   --m-neon-glow: rgba(251, 146, 60, 0.70);
 }

.m-hex--selected::after {
  filter: drop-shadow(0 0 12px rgba(251, 146, 60, 0.55)) drop-shadow(0 0 20px rgba(255, 255, 255, 0.22));
}

.m-hex--correct {
  background: rgba(16, 185, 129, 0.25);
}

 .m-hex--correct {
   --m-neon-core: rgba(52, 211, 153, 0.98);
   --m-neon-glow: rgba(16, 185, 129, 0.85);
 }

.m-hex--correct::before {
  border-color: rgba(52, 211, 153, 0.98);
}

.m-hex--correct::after {
  filter:
    drop-shadow(0 0 18px rgba(16, 185, 129, 0.85))
    drop-shadow(0 0 42px rgba(16, 185, 129, 0.35))
    drop-shadow(0 0 22px rgba(255, 255, 255, 0.22));
}

.m-hex--flash::before {
  animation: m-correct-flash 520ms ease-in-out 2;
}

.m-hex--wrong {
  background: rgba(244, 63, 94, 0.22);
  animation: m-power-flicker 1200ms linear infinite;
}

 .m-hex--wrong {
   --m-neon-core: rgba(248, 113, 113, 0.98);
   --m-neon-glow: rgba(244, 63, 94, 0.75);
 }

.m-hex--wrong::before {
  border-color: rgba(248, 113, 113, 0.98);
}

 .m-hex-content {
   position: relative;
   z-index: 3;
   padding-left: clamp(40px, 15%, 84px);
   padding-right: clamp(40px, 15%, 84px);
 }

 .m-opt-label {
   color: #ffa500;
 }

 .m-answer-connectors {
   position: absolute;
   inset: 0;
   pointer-events: none;
   z-index: 0;
 }

 .m-hex-wrap {
   position: relative;
   --m-hex-span: 88%;
 }

 .m-hex-extend {
   position: absolute;
   left: 0;
   right: 0;
   top: 50%;
   height: 1px;
   transform: translateY(-50%);
   pointer-events: none;
   z-index: 0;
 }

 .m-hex-extend::before,
 .m-hex-extend::after {
   content: '';
   position: absolute;
   top: 0;
   height: 1px;
   background: var(--m-neon-core);
   box-shadow: 0 0 10px rgba(34, 211, 238, 0.25);
   opacity: 0.95;
 }

 .m-hex-extend::before {
   left: 0;
   width: calc(((100% - var(--m-hex-span)) / 2) + 2px);
 }

 .m-hex-extend::after {
   right: 0;
   width: calc(((100% - var(--m-hex-span)) / 2) + 2px);
 }

 .m-answer-connectors::before,
 .m-answer-connectors::after {
   content: '';
   position: absolute;
   top: 50%;
   height: 1px;
   transform: translateY(-50%);
   background: linear-gradient(90deg, rgba(255, 255, 255, 0.85), rgba(34, 211, 238, 0.25));
   box-shadow: 0 0 8px rgba(34, 211, 238, 0.28);
   opacity: 0.8;
 }

 .m-answer-connectors::before {
   left: 0;
   width: 18%;
 }

 .m-answer-connectors::after {
   right: 0;
   width: 18%;
   transform: translateY(-50%) scaleX(-1);
 }

.m-hex--wrong::after {
  filter: drop-shadow(0 0 12px rgba(244, 63, 94, 0.70)) drop-shadow(0 0 22px rgba(255, 255, 255, 0.22));
}

.m-hex--dim {
  opacity: 0.65;
}

.m-shimmer {
  position: absolute;
  inset: -40% -30%;
  background: linear-gradient(110deg, transparent 20%, rgba(255, 255, 255, 0.35) 45%, transparent 70%);
  transform: translateX(-60%);
  animation: m-shimmer-sweep 650ms ease-out 1;
  pointer-events: none;
  z-index: 2;
}

.m-skill-flow {
  background: linear-gradient(
    180deg,
    rgba(34, 211, 238, 0.0) 0%,
    rgba(34, 211, 238, 0.65) 18%,
    rgba(59, 130, 246, 0.35) 55%,
    rgba(34, 211, 238, 0.15) 100%
  );
  background-size: 100% 240%;
  animation: m-flow 1600ms linear infinite;
}

.m-radar {
  position: relative;
}

.m-radar::after {
  content: '';
  position: absolute;
  inset: -10px;
  border-radius: 9999px;
  border: 2px solid rgba(34, 211, 238, 0.45);
  animation: m-radar 1200ms ease-out infinite;
  pointer-events: none;
}

@keyframes m-amber-pulse {
  0%, 100% { filter: drop-shadow(0 0 0 rgba(251, 146, 60, 0)); }
  50% { filter: drop-shadow(0 0 14px rgba(251, 146, 60, 0.55)); }
}

 @keyframes m-neon-hover {
   0%, 100% {
     filter:
       drop-shadow(0 0 12px rgba(34, 211, 238, 0.55))
       drop-shadow(0 0 24px rgba(255, 255, 255, 0.22));
   }
   50% {
     filter:
       drop-shadow(0 0 18px rgba(34, 211, 238, 0.95))
       drop-shadow(0 0 34px rgba(255, 255, 255, 0.30));
   }
 }

 @keyframes m-svg-neon-hover {
   0%, 100% { filter: drop-shadow(0 0 10px rgba(34, 211, 238, 0.45)) drop-shadow(0 0 18px rgba(255, 255, 255, 0.18)); }
   50% { filter: drop-shadow(0 0 16px rgba(34, 211, 238, 0.95)) drop-shadow(0 0 28px rgba(255, 255, 255, 0.30)); }
 }

@keyframes m-shimmer-sweep {
  0% { transform: translateX(-60%) rotate(8deg); opacity: 0; }
  15% { opacity: 1; }
  100% { transform: translateX(60%) rotate(8deg); opacity: 0; }
}

@keyframes m-flow {
  0% { background-position: 0% 0%; }
  100% { background-position: 0% 100%; }
}

@keyframes m-radar {
  0% { transform: scale(0.75); opacity: 0.9; }
  70% { opacity: 0.0; }
  100% { transform: scale(1.65); opacity: 0.0; }
}

@keyframes m-correct-flash {
  0%, 100% { border-color: rgba(52, 211, 153, 0.35); }
  50% { border-color: rgba(52, 211, 153, 0.98); }
}

@keyframes m-power-flicker {
  0% { opacity: 1; filter: saturate(1); }
  6% { opacity: 0.35; filter: saturate(0.8); }
  9% { opacity: 1; }
  18% { opacity: 0.55; }
  22% { opacity: 1; }
  72% { opacity: 1; }
  78% { opacity: 0.40; filter: saturate(0.6); }
  82% { opacity: 1; }
  100% { opacity: 1; }
}

@keyframes m-shatter {
  0% { transform: translateZ(0) rotate(0deg); }
  20% { transform: translateZ(0) translateX(1px) rotate(-6deg); }
  45% { transform: translateZ(0) translateX(-2px) rotate(8deg); }
  70% { transform: translateZ(0) translateX(1px) rotate(-4deg); }
  100% { transform: translateZ(0) rotate(0deg); }
}
